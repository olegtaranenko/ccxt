# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.binance import ImplicitAPI
import hashlib
import json
from ccxt.base.types import Balances, BorrowInterest, Conversion, CrossBorrowRate, Currencies, Currency, DepositAddress, Greeks, Int, IsolatedBorrowRate, IsolatedBorrowRates, LedgerEntry, Leverage, Leverages, LeverageTier, LeverageTiers, LongShortRatio, MarginMode, MarginModes, MarginModification, Market, MarketInterface, Num, Option, Order, OrderBook, OrderRequest, OrderSide, OrderType, Str, Strings, Ticker, Tickers, FundingRate, FundingRates, Trade, TradingFeeInterface, TradingFees, Transaction, TransferEntry
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import OperationRejected
from ccxt.base.errors import MarginModeAlreadySet
from ccxt.base.errors import MarketClosed
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import OrderImmediatelyFillable
from ccxt.base.errors import OrderNotFillable
from ccxt.base.errors import NotSupported
from ccxt.base.errors import OperationFailed
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout
from ccxt.base.errors import BadResponse
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class binance(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(binance, self).describe(), {
            'api': {
                # the API structure below will need 3-layer apidefs
                'dapiData': {
                    'get': {
                        'basis': 1,
                        'delivery-price': 1,
                        'globalLongShortAccountRatio': 1,
                        'openInterestHist': 1,
                        'takerBuySellVol': 1,
                        'topLongShortAccountRatio': 1,
                        'topLongShortPositionRatio': 1,
                    },
                },
                'dapiPrivate': {
                    'delete': {
                        'allOpenOrders': 1,
                        'batchOrders': 5,
                        'listenKey': 1,
                        'order': 1,
                    },
                    'get': {
                        'account': 5,
                        'adlQuantile': 5,
                        'allOrders': {'cost': 20, 'noSymbol': 40},
                        'balance': 1,
                        'commissionRate': 20,
                        'forceOrders': {'cost': 20, 'noSymbol': 50},
                        'income': 20,
                        'income/asyn': 5,
                        'income/asyn/id': 5,
                        'leverageBracket': 1,
                        'openOrder': 1,
                        'openOrders': {'cost': 1, 'noSymbol': 5},
                        'order': 1,
                        'order/asyn': 0.5,
                        'order/asyn/id': 0.5,
                        'orderAmendment': 1,
                        'pmAccountInfo': 0.5,  # Weight(IP): 5 => cost = 0.1 * 5 = 0.5
                        'pmExchangeInfo': 0.5,  # Weight(IP): 5 => cost = 0.1 * 5 = 0.5
                        'positionMargin/history': 1,
                        'positionRisk': 1,
                        'positionSide/dual': 30,
                        'trade/asyn': 0.5,
                        'trade/asyn/id': 0.5,
                        'userTrades': {'cost': 20, 'noSymbol': 40},
                    },
                    'post': {
                        'batchOrders': 5,
                        'countdownCancelAll': 10,
                        'leverage': 1,
                        'listenKey': 1,
                        'marginType': 1,
                        'order': 4,
                        'positionMargin': 1,
                        'positionSide/dual': 1,
                    },
                    'put': {
                        'batchOrders': 5,
                        'listenKey': 1,
                        'order': 1,
                    },
                },
                'dapiPrivateV2': {
                    'get': {
                        'leverageBracket': 1,
                    },
                },
                'dapiPublic': {
                    'get': {
                        'aggTrades': 20,
                        'constituents': 2,
                        'continuousKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                        },
                        'depth': {'cost': 2, 'byLimit': [[50, 2], [100, 5], [500, 10], [1000, 20]]},
                        'exchangeInfo': 1,
                        'fundingInfo': 1,
                        'fundingRate': 1,
                        'historicalTrades': 20,
                        'indexPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                        },
                        'klines': {'cost': 1, 'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]},
                        'markPriceKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                        },
                        'openInterest': 1,
                        'ping': 1,
                        'premiumIndex': 10,
                        'premiumIndexKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                        },
                        'ticker/24hr': {'cost': 1, 'noSymbol': 40},
                        'ticker/bookTicker': {'cost': 2, 'noSymbol': 5},
                        'ticker/price': {'cost': 1, 'noSymbol': 2},
                        'time': 1,
                        'trades': 5,
                    },
                },
                'eapiPrivate': {
                    'delete': {
                        'allOpenOrders': 1,
                        'allOpenOrdersByUnderlying': 1,
                        'batchOrders': 1,
                        'block/order/create': 5,
                        'listenKey': 1,
                        'order': 1,
                    },
                    'get': {
                        'account': 3,
                        'bill': 1,
                        'block/order/execute': 5,
                        'block/order/orders': 5,
                        'block/user-trades': 5,
                        'blockTrades': 5,
                        'countdownCancelAll': 1,
                        'exerciseRecord': 5,
                        'historyOrders': 3,
                        'income/asyn': 5,
                        'income/asyn/id': 5,
                        'marginAccount': 3,
                        'mmp': 1,
                        'openOrders': {'cost': 1, 'noSymbol': 40},
                        'order': 1,
                        'position': 5,
                        'userTrades': 5,
                    },
                    'post': {
                        'batchOrders': 5,
                        'block/order/create': 5,
                        'block/order/execute': 5,
                        'countdownCancelAll': 1,
                        'countdownCancelAllHeartBeat': 10,
                        'listenKey': 1,
                        'mmpReset': 1,
                        'mmpSet': 1,
                        'order': 1,
                    },
                    'put': {
                        'block/order/create': 5,
                        'listenKey': 1,
                    },
                },
                'eapiPublic': {
                    'get': {
                        'depth': 1,
                        'exchangeInfo': 1,
                        'exerciseHistory': 3,
                        'historicalTrades': 20,
                        'index': 1,
                        'klines': 1,
                        'mark': 5,
                        'openInterest': 3,
                        'ping': 1,
                        'ticker': 5,
                        'time': 1,
                        'trades': 5,
                    },
                },
                'fapiData': {
                    'get': {
                        'basis': 1,
                        'delivery-price': 1,
                        'globalLongShortAccountRatio': 1,
                        'openInterestHist': 1,
                        'takerlongshortRatio': 1,
                        'topLongShortAccountRatio': 1,
                        'topLongShortPositionRatio': 1,
                    },
                },
                'fapiPrivate': {
                    'delete': {
                        'allOpenOrders': 1,
                        'batchOrders': 1,
                        'listenKey': 1,
                        'order': 1,
                    },
                    'get': {
                        'account': 5,
                        'accountConfig': 5,
                        'adlQuantile': 5,
                        'allOrders': 5,
                        # broker endpoints
                        'apiReferral/customization': 1,
                        'apiReferral/ifNewUser': 1,
                        'apiReferral/overview': 1,
                        'apiReferral/rebateVol': 1,
                        'apiReferral/traderNum': 1,
                        'apiReferral/traderSummary': 1,
                        'apiReferral/tradeVol': 1,
                        'apiReferral/userCustomization': 1,
                        'apiTradingStatus': 1,
                        'balance': 5,
                        'commissionRate': 20,
                        'convert/orderStatus': 5,
                        'feeBurn': 1,
                        'forceOrders': {'cost': 20, 'noSymbol': 50},
                        'income': 30,
                        'income/asyn': 1000,
                        'income/asyn/id': 10,
                        'leverageBracket': 1,
                        'multiAssetsMargin': 30,
                        'openOrder': 1,
                        'openOrders': {'cost': 1, 'noSymbol': 40},
                        'order': 1,
                        'order/asyn': 1000,
                        'order/asyn/id': 10,
                        'orderAmendment': 1,
                        'pmAccountInfo': 5,
                        'positionMargin/history': 1,
                        'positionRisk': 5,
                        'positionSide/dual': 30,
                        'rateLimit/order': 1,
                        'symbolConfig': 5,
                        'trade/asyn': 1000,
                        'trade/asyn/id': 10,
                        'userTrades': 5,
                    },
                    'post': {
                        # broker endpoints
                        'apiReferral/customization': 1,
                        'apiReferral/userCustomization': 1,
                        'batchOrders': 5,
                        'convert/acceptQuote': 20,
                        'convert/getQuote': 200,  # 360 requests per hour
                        'countdownCancelAll': 10,
                        'feeBurn': 1,
                        'leverage': 1,
                        'listenKey': 1,
                        'marginType': 1,
                        'multiAssetsMargin': 1,
                        'order': 4,
                        'positionMargin': 1,
                        'positionSide/dual': 1,
                    },
                    'put': {
                        'batchOrders': 5,
                        'listenKey': 1,
                        'order': 1,
                    },
                },
                'fapiPrivateV2': {
                    'get': {
                        'account': 1,
                        'balance': 1,
                        'positionRisk': 1,
                    },
                },
                'fapiPrivateV3': {
                    'get': {
                        'account': 1,
                        'balance': 1,
                        'positionRisk': 1,
                    },
                },
                'fapiPublic': {
                    'get': {
                        'aggTrades': 20,
                        'apiTradingStatus': {'cost': 1, 'noSymbol': 10},
                        'assetIndex': {'cost': 1, 'noSymbol': 10},
                        'constituents': 2,
                        'continuousKlines': {
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                            'cost': 1,
                        },
                        'convert/exchangeInfo': 4,
                        'depth': {'byLimit': [[50, 2], [100, 5], [500, 10], [1000, 20]], 'cost': 2},
                        'exchangeInfo': 1,
                        'fundingInfo': 1,
                        'fundingRate': 1,
                        'historicalTrades': 20,
                        'indexInfo': 1,
                        'indexPriceKlines': {
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                            'cost': 1,
                        },
                        'klines': {'cost': 1, 'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]]},
                        'lvtKlines': 1,
                        'markPriceKlines': {
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                            'cost': 1,
                        },
                        'openInterest': 1,
                        'ping': 1,
                        'premiumIndex': 1,
                        'premiumIndexKlines': {
                            'cost': 1,
                            'byLimit': [[99, 1], [499, 2], [1000, 5], [10000, 10]],
                        },
                        'ticker/24hr': {'cost': 1, 'noSymbol': 40},
                        'ticker/bookTicker': {'cost': 1, 'noSymbol': 2},
                        'ticker/price': {'cost': 1, 'noSymbol': 2},
                        'time': 1,
                        'trades': 5,
                    },
                },
                'fapiPublicV2': {
                    'get': {
                        'ticker/price': 0,
                    },
                },
                'fapiPublicV3': {
                    'get': {},
                },
                'papi': {
                    'delete': {
                        'cm/allOpenOrders': 1,
                        'cm/conditional/allOpenOrders': 1,
                        'cm/conditional/order': 1,
                        'cm/order': 1,
                        'listenKey': 0.2,
                        'margin/allOpenOrders': 5,
                        'margin/order': 2,
                        'margin/orderList': 2,
                        'um/allOpenOrders': 1,
                        'um/conditional/allOpenOrders': 1,
                        'um/conditional/order': 1,
                        'um/order': 1,
                    },
                    # IP(papi) request rate limit of 6000 per minute
                    # 1 IP(papi) => cost = 0.2 =>(1000 / (50 * 0.2)) * 60 = 6000
                    # Order(papi) request rate limit of 1200 per minute
                    # 1 Order(papi) => cost = 1 =>(1000 / (50 * 1)) * 60 = 1200
                    'get': {
                        'account': 4,
                        'balance': 4,
                        'cm/account': 1,
                        'cm/accountConfig': 1,
                        'cm/adlQuantile': 5,
                        'cm/allOrders': 20,
                        'cm/commissionRate': 4,
                        'cm/conditional/allOrders': 40,
                        'cm/conditional/openOrder': 1,
                        'cm/conditional/openOrders': {'cost': 1, 'noSymbol': 40},
                        'cm/conditional/orderHistory': 1,
                        'cm/forceOrders': {'cost': 20, 'noSymbol': 50},
                        'cm/income': 6,
                        'cm/leverageBracket': 0.2,
                        'cm/openOrder': 1,
                        'cm/openOrders': {'cost': 1, 'noSymbol': 40},
                        'cm/order': 1,
                        'cm/orderAmendment': 1,
                        'cm/positionRisk': 0.2,
                        'cm/positionSide/dual': 6,
                        'cm/symbolConfig': 1,
                        'cm/userTrades': 20,
                        'margin/allOrderList': 100,
                        'margin/allOrders': 100,
                        'margin/forceOrders': 1,
                        'margin/marginInterestHistory': 0.2,
                        'margin/marginLoan': 2,
                        'margin/maxBorrowable': 1,
                        'margin/maxWithdraw': 1,
                        'margin/myTrades': 5,
                        'margin/openOrderList': 5,
                        'margin/openOrders': 5,
                        'margin/order': 10,
                        'margin/orderList': 5,
                        'margin/repayLoan': 2,
                        'ping': 0.2,
                        'portfolio/interest-history': 10,
                        'rateLimit/order': 1,
                        'repay-futures-switch': 6,
                        'um/account': 1,
                        'um/accountConfig': 1,
                        'um/adlQuantile': 5,
                        'um/allOrders': 5,
                        'um/apiTradingStatus': {'cost': 0.2, 'noSymbol': 2},
                        'um/commissionRate': 4,
                        'um/conditional/allOrders': {'cost': 1, 'noSymbol': 40},
                        'um/conditional/openOrder': 1,
                        'um/conditional/openOrders': {'cost': 1, 'noSymbol': 40},
                        'um/conditional/orderHistory': 1,
                        'um/feeBurn': 30,
                        'um/forceOrders': {'cost': 20, 'noSymbol': 50},
                        'um/income': 6,
                        'um/income/asyn': 300,
                        'um/income/asyn/id': 2,
                        'um/leverageBracket': 0.2,
                        'um/openOrder': 1,
                        'um/openOrders': {'cost': 1, 'noSymbol': 40},
                        'um/order': 1,
                        'um/order/asyn': 300,
                        'um/order/asyn/id': 2,
                        'um/orderAmendment': 1,
                        'um/positionRisk': 1,
                        'um/positionSide/dual': 6,
                        'um/symbolConfig': 1,
                        'um/trade/asyn': 300,
                        'um/trade/asyn/id': 2,
                        'um/userTrades': 5,
                    },
                    'post': {
                        'asset-collection': 6,
                        'auto-collection': 150,
                        'bnb-transfer': 150,
                        'cm/conditional/order': 1,
                        'cm/leverage': 0.2,
                        'cm/order': 1,
                        'cm/positionSide/dual': 0.2,
                        'listenKey': 0.2,
                        'margin/order': 1,
                        'margin/order/oco': 1,
                        'margin/repay-debt': 3000,
                        'marginLoan': 100,
                        'repay-futures-negative-balance': 150,
                        'repay-futures-switch': 150,
                        'repayLoan': 100,
                        'um/conditional/order': 1,
                        'um/feeBurn': 1,
                        'um/leverage': 0.2,
                        'um/order': 1,
                        'um/positionSide/dual': 0.2,
                    },
                    'put': {
                        'cm/order': 1,
                        'listenKey': 0.2,
                        'um/order': 1,
                    },
                },
                'papiV2': {
                    'get': {
                        'um/account': 1,
                    },
                },
                'private': {
                    'delete': {
                        'openOrders': 0.2,
                        'order': 0.2,
                        'orderList': 0.2,  # oco
                    },
                    'get': {
                        'account': 4,
                        'account/commission': 4,
                        'allOrderList': 4,  # oco Weight(IP): 20 => cost = 0.2 * 20 = 4
                        'allOrders': 4,
                        'myAllocations': 4,
                        'myPreventedMatches': 4,  # Weight(IP): 20 => cost = 0.2 * 20 = 4
                        'myTrades': 4,
                        'openOrderList': 1.2,  # oco Weight(IP): 6 => cost = 0.2 * 6 = 1.2
                        'openOrders': {'cost': 1.2, 'noSymbol': 16},
                        'order': 0.8,
                        'orderList': 0.8,  # oco
                        'rateLimit/order': 8,  # Weight(IP): 40 => cost = 0.2 * 40 = 8
                    },
                    'post': {
                        'order': 0.2,
                        'order/cancelReplace': 0.2,
                        'order/oco': 0.2,
                        'order/test': 0.2,
                        'orderList/oco': 0.2,
                        'orderList/oto': 0.2,
                        'orderList/otoco': 0.2,
                        'sor/order': 0.2,
                        'sor/order/test': 0.2,
                    },
                },
                'public': {
                    'delete': {
                        'userDataStream': 0.4,
                    },
                    # IP(api) request rate limit of 6000 per minute
                    # 1 IP(api) => cost = 0.2 =>(1000 / (50 * 0.2)) * 60 = 6000
                    'get': {
                        'aggTrades': 0.4,
                        'avgPrice': 0.4,
                        'depth': {'byLimit': [[100, 1], [500, 5], [1000, 10], [5000, 50]], 'cost': 1},
                        'exchangeInfo': 4,  # Weight(IP): 20 => cost = 0.2 * 20 = 4
                        'historicalTrades': 2,  # Weight(IP): 10 => cost = 0.2 * 10 = 2
                        'klines': 0.4,
                        'ping': 0.2,  # Weight(IP): 1 => cost = 0.2 * 1 = 0.2
                        'ticker': {'cost': 0.4, 'noSymbol': 16},
                        'ticker/24hr': {'cost': 0.4, 'noSymbol': 16},
                        'ticker/bookTicker': {'cost': 0.4, 'noSymbol': 0.8},
                        'ticker/price': {'cost': 0.4, 'noSymbol': 0.8},
                        'ticker/tradingDay': 0.8,
                        'time': 0.2,
                        'trades': 2,  # Weight(IP): 10 => cost = 0.2 * 10 = 2
                        'uiKlines': 0.4,
                    },
                    'post': {
                        'userDataStream': 0.4,
                    },
                    'put': {
                        'userDataStream': 0.4,
                    },
                },
                'sapi': {
                    'delete': {
                        # 'account/apiRestrictions/ipRestriction/ipList': 1, discontinued
                        'algo/futures/order': 0.1,
                        'algo/spot/order': 0.1,
                        # brokerage API TODO NO MENTION OF RATELIMIT IN BROKERAGE DOCS
                        'broker/subAccountApi': 1,
                        'broker/subAccountApi/ipRestriction/ipList': 1,
                        'margin/isolated/account': 2.0001,  # Weight(UID): 300 => cost =  0.006667 * 300 = 2.0001
                        'margin/openOrders': 0.1,
                        'margin/order': 0.006667,  # Weight(UID): 1 => cost = 0.006667
                        'margin/orderList': 0.006667,
                        'sub-account/subAccountApi/ipRestriction/ipList': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1,
                    },
                    # IP(sapi) request rate limit of 12 000 per minute
                    # 1 IP(sapi) => cost = 0.1 =>(1000 / (50 * 0.1)) * 60 = 12000
                    # 10 IP(sapi) => cost = 1
                    # UID(sapi) request rate limit of 180 000 per minute
                    # 1 UID(sapi) => cost = 0.006667 =>(1000 / (50 * 0.006667)) * 60 = 180000
                    'get': {
                        # copy trading
                        'copyTrading/futures/userStatus': 2,
                        'copyTrading/futures/leadSymbol': 2,
                        'system/status': 0.1,
                        # these endpoints require self.apiKey
                        'account/info': 0.1,
                        'accountSnapshot': 240,  # Weight(IP): 2400 => cost = 0.1 * 2400 = 240
                        'margin/allAssets': 0.1,
                        'margin/allPairs': 0.1,
                        'margin/asset': 1,  # Weight(IP): 10 => cost = 0.1 * 10 = 1
                        'margin/pair': 1,
                        'margin/priceIndex': 1,
                        # these endpoints require self.apiKey + self.secret
                        'account/apiRestrictions/ipRestriction': 0.1,
                        'account/apiTradingStatus': 0.1,
                        'account/status': 0.1,
                        'asset/assetDetail': 0.1,
                        'asset/assetDividend': 1,
                        'asset/convert-transfer/queryByPage': 0.033335,
                        'asset/custody/transfer-history': 6,  # Weight(IP): 60 => cost = 0.1 * 60 = 6
                        'asset/dribblet': 0.1,
                        'asset/ledger-transfer/cloud-mining/queryByPage': 4.0002,  # Weight(UID): 600 => cost = 0.006667 * 600 = 4.0002
                        'asset/tradeFee': 0.1,
                        'asset/transfer': 0.1,
                        'asset/wallet/balance': 6,  # Weight(IP): 60 => cost = 0.1 * 60 = 6
                        'bnbBurn': 0.1,
                        'capital/config/getall': 1,  # get networks for withdrawing USDT ERC20 vs USDT Omni
                        'capital/contract/convertible-coins': 4.0002,  # Weight(UID): 600 => cost = 0.006667 * 600 = 4.0002
                        'capital/deposit/address': 1,
                        'capital/deposit/address/list': 1,
                        'capital/deposit/hisrec': 0.1,
                        'capital/deposit/subAddress': 0.1,
                        'capital/deposit/subHisrec': 0.1,
                        'capital/withdraw/address/list': 10,
                        'capital/withdraw/history': 2,  # Weight(UID): 18000 + (Additional: 10 requests per second => cost = ( 1000 / rateLimit ) / 10 = 2
                        'convert/assetInfo': 10,
                        'convert/exchangeInfo': 50,
                        'convert/limit/queryOpenOrders': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'convert/orderStatus': 0.6667,
                        'convert/tradeFlow': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'fiat/orders': 600.03,  # Weight(UID): 90000 => cost = 0.006667 * 90000 = 600.03
                        'fiat/payments': 0.1,
                        'futures/histDataLink': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'futures/transfer': 1,
                        'loan/borrow/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/collateral/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/borrow/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40, check flexible rate loans order history before 2024-02-27 08:00(UTC)
                        'loan/flexible/collateral/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/loanable/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/ltv/adjustment/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40, check flexible rate loans order history before 2024-02-27 08:00(UTC)
                        'loan/flexible/ongoing/orders': 30,  # TODO: Deprecating at 2024-04-24 03:00(UTC)
                        'loan/flexible/repay/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40, check flexible rate loans order history before 2024-02-27 08:00(UTC)
                        'loan/income': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'loan/loanable/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/ltv/adjustment/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/ongoing/orders': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/repay/collateral/rate': 600,  # Weight(IP): 6000 => cost = 0.1 * 6000 = 600
                        'loan/repay/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/vip/collateral/account': 600,  # Weight(IP): 6000 => cost = 0.1 * 6000 = 600
                        'loan/vip/collateral/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/vip/loanable/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/vip/ongoing/orders': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/vip/repay/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/vip/request/data': 2.6668,  # Weight(UID): 400 => cost = 0.006667 * 400 = 2.6668
                        'loan/vip/request/interestRate': 2.6668,  # Weight(UID): 400 => cost = 0.006667 * 400 = 2.6668
                        'managed-subaccount/accountSnapshot': 240,
                        'managed-subaccount/asset': 0.1,
                        'managed-subaccount/deposit/address': 0.006667,  # Weight(UID): 1 => cost = 0.006667 * 1 = 0.006667
                        'managed-subaccount/fetch-future-asset': 0.40002,  # Weight(UID): 60 => cost = 0.006667 * 60 = 0.40002
                        'managed-subaccount/info': 0.40002,  # Weight(UID): 60 => cost = 0.006667 * 60 = 0.40002
                        'managed-subaccount/marginAsset': 0.1,
                        'managed-subaccount/query-trans-log': 0.40002,
                        'managed-subaccount/queryTransLogForInvestor': 0.1,
                        'managed-subaccount/queryTransLogForTradeParent': 0.40002,  # Weight(UID): 60 => cost = 0.006667 * 60 = 0.40002
                        'margin/account': 1,
                        'margin/allOrderList': 20,  # Weight(IP): 200 => cost = 0.1 * 200 = 20
                        'margin/allOrders': 20,  # Weight(IP): 200 => cost = 0.1 * 200 = 20
                        'margin/available-inventory': 0.3334,  # Weight(UID): 50 => cost = 0.006667 * 50 = 0.3334
                        'margin/borrow-repay': 1,
                        'margin/capital-flow': 10,  # Weight(IP): 100 => cost = 0.1 * 100 = 10
                        'margin/crossMarginCollateralRatio': 10,
                        'margin/crossMarginData': {'cost': 0.1, 'noCoin': 0.5},
                        'margin/delist-schedule': 10,  # Weight(IP): 100 => cost = 0.1 * 100 = 10
                        'margin/dribblet': 0.1,
                        'margin/dust': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20
                        'margin/exchange-small-liability': 0.6667,
                        'margin/exchange-small-liability-history': 0.6667,
                        'margin/forceLiquidationRec': 0.1,
                        'margin/interestHistory': 0.1,
                        'margin/interestRateHistory': 0.1,
                        'margin/isolated/account': 1,
                        'margin/isolated/accountLimit': 0.1,
                        'margin/isolated/allPairs': 1,
                        'margin/isolated/pair': 1,
                        'margin/isolated/transfer': 0.1,
                        'margin/isolatedMarginData': {'cost': 0.1, 'noCoin': 1},
                        'margin/isolatedMarginTier': 0.1,
                        'margin/leverageBracket': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'margin/loan': 1,
                        'margin/maxBorrowable': 5,  # Weight(IP): 50 => cost = 0.1 * 50 = 5
                        'margin/maxTransferable': 5,
                        'margin/myTrades': 1,
                        'margin/next-hourly-interest-rate': 0.6667,
                        'margin/openOrderList': 1,
                        'margin/openOrders': 1,
                        'margin/order': 1,
                        'margin/orderList': 1,
                        'margin/rateLimit/order': 2,
                        'margin/repay': 1,
                        'margin/tradeCoeff': 1,
                        'margin/transfer': 0.1,
                        'rebate/taxQuery': 80.004,  # Weight(UID): 12000 => cost = 0.006667 * 12000 = 80.004
                        # these endpoints require self.apiKey + self.secret
                        'spot/delist-schedule': 10,
                        'sub-account/apiRestrictions/ipRestriction/thirdPartyList': 1,
                        'sub-account/futures/account': 1,
                        'sub-account/futures/accountSummary': 0.1,
                        'sub-account/futures/internalTransfer': 0.1,
                        'sub-account/futures/positionRisk': 1,
                        'sub-account/list': 0.1,
                        'sub-account/margin/account': 1,
                        'sub-account/margin/accountSummary': 1,
                        'sub-account/spotSummary': 0.1,
                        'sub-account/status': 1,
                        'sub-account/sub/transfer/history': 0.1,
                        'sub-account/subAccountApi/ipRestriction': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'sub-account/transaction-statistics': 0.40002,  # Weight(UID): 60 => cost = 0.006667 * 60 = 0.40002
                        'sub-account/transfer/subUserHistory': 0.1,
                        'sub-account/universalTransfer': 0.1,
                        # lending endpoints
                        'lending/daily/product/list': 0.1,
                        'lending/daily/token/position': 0.1,
                        'lending/daily/userLeftQuota': 0.1,
                        'lending/daily/userRedemptionQuota': 0.1,
                        'lending/project/list': 0.1,
                        'lending/project/position/list': 0.1,
                        'lending/union/account': 0.1,
                        'lending/union/interestHistory': 0.1,
                        'lending/union/purchaseRecord': 0.1,
                        'lending/union/redemptionRecord': 0.1,
                        # eth-staking
                        'eth-staking/account': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/history/rateHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/history/redemptionHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/history/rewardsHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/history/stakingHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/history/wbethRewardsHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/quota': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/wbeth/history/unwrapHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/wbeth/history/wrapHistory': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'sol-staking/account': 15,
                        'sol-staking/sol/history/bnsolRewardsHistory': 15,
                        'sol-staking/sol/history/rateHistory': 15,
                        'sol-staking/sol/history/redemptionHistory': 15,
                        'sol-staking/sol/history/stakingHistory': 15,
                        'sol-staking/sol/quota': 15,
                        # mining endpoints
                        'mining/payment/list': 0.5,
                        'mining/payment/uid': 0.5,
                        'mining/pub/algoList': 0.1,
                        'mining/pub/coinList': 0.1,
                        'mining/statistics/user/list': 0.5,
                        'mining/statistics/user/status': 0.5,
                        'mining/worker/detail': 0.5,  # Weight(IP): 5 => cost = 0.1 * 5 = 0.5
                        'mining/worker/list': 0.5,
                        # liquid swap endpoints
                        'bswap/addLiquidityPreview': 1.00005,  # Weight(UID): 150 => cost = 0.006667 * 150 = 1.00005
                        'bswap/claimedHistory': 6.667,  # Weight(UID): 1000 => cost = 0.006667 * 1000 = 6.667
                        'bswap/liquidity': {'cost': 0.1, 'noPoolId': 1},
                        'bswap/liquidityOps': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'bswap/poolConfigure': 1.00005,  # Weight(UID): 150 => cost = 0.006667 * 150 = 1.00005
                        'bswap/pools': 0.1,
                        'bswap/quote': 1.00005,  # Weight(UID): 150 => cost = 0.006667 * 150 = 1.00005
                        'bswap/removeLiquidityPreview': 1.00005,  # Weight(UID): 150 => cost = 0.006667 * 150 = 1.00005
                        'bswap/swap': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'bswap/unclaimedRewards': 6.667,  # Weight(UID): 1000 => cost = 0.006667 * 1000 = 6.667
                        # leveraged token endpoints
                        'blvt/redeem/record': 0.1,
                        'blvt/subscribe/record': 0.1,
                        'blvt/tokenInfo': 0.1,
                        'blvt/userLimit': 0.1,
                        # broker api TODO(NOT IN DOCS)
                        'apiReferral/customization': 1,
                        'apiReferral/ifNewUser': 1,
                        'apiReferral/kickback/historicalRecord': 1,
                        'apiReferral/kickback/recentRecord': 1,
                        'apiReferral/rebate/historicalRecord': 1,
                        'apiReferral/rebate/recentRecord': 1,
                        'apiReferral/userCustomization': 1,
                        # brokerage API TODO https://binance-docs.github.io/Brokerage-API/General/ does not state ratelimits
                        'broker/info': 1,
                        'broker/rebate/futures/recentRecord': 1,
                        'broker/rebate/historicalRecord': 1,
                        'broker/rebate/recentRecord': 1,
                        'broker/subAccount': 1,
                        'broker/subAccount/bnbBurn/status': 1,
                        'broker/subAccount/depositHist': 1,
                        'broker/subAccount/futuresSummary': 1,
                        'broker/subAccount/marginSummary': 1,
                        'broker/subAccount/spotSummary': 1,
                        'broker/subAccountApi': 1,
                        'broker/subAccountApi/commission/coinFutures': 1,
                        'broker/subAccountApi/commission/futures': 1,
                        'broker/subAccountApi/ipRestriction': 1,
                        'broker/transfer': 1,
                        'broker/transfer/futures': 1,
                        'broker/universalTransfer': 1,
                        # v2 not supported yet
                        # GET /sapi/v2/broker/subAccount/futuresSummary
                        'account/apiRestrictions': 0.1,
                        # c2c / p2p
                        'c2c/orderMatch/listUserOrderHistory': 0.1,
                        # nft endpoints
                        'nft/history/transactions': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'nft/history/deposit': 20.001,
                        'nft/history/withdraw': 20.001,
                        'nft/user/getAsset': 20.001,
                        'pay/transactions': 20.001,
                        'giftcard/verify': 0.1,
                        'giftcard/cryptography/rsa-public-key': 0.1,
                        'giftcard/buyCode/token-limit': 0.1,
                        'algo/spot/openOrders': 0.1,
                        'algo/spot/historicalOrders': 0.1,
                        'algo/spot/subOrders': 0.1,
                        'algo/futures/openOrders': 0.1,
                        'algo/futures/historicalOrders': 0.1,
                        'algo/futures/subOrders': 0.1,
                        'portfolio/account': 0.1,
                        'portfolio/collateralRate': 5,
                        'portfolio/pmLoan': 3.3335,
                        'portfolio/interest-history': 0.6667,
                        'portfolio/asset-index-price': 0.1,
                        'portfolio/repay-futures-switch': 3,  # Weight(IP): 30 => cost = 0.1 * 30 = 3
                        'portfolio/margin-asset-leverage': 5,  # Weight(IP): 50 => cost = 0.1 * 50 = 5
                        'portfolio/balance': 2,
                        # staking
                        'lending/auto-invest/all/asset': 0.1,
                        'lending/auto-invest/history/list': 0.1,
                        'lending/auto-invest/index/info': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/index/user-summary': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/one-off/status': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/plan/id': 0.1,
                        'lending/auto-invest/plan/list': 0.1,
                        'lending/auto-invest/rebalance/history': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/redeem/history': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/source-asset/list': 0.1,
                        'lending/auto-invest/target-asset/list': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/target-asset/roi/list': 0.1,
                        'staking/personalLeftQuota': 0.1,
                        'staking/position': 0.1,
                        'staking/productList': 0.1,
                        'staking/stakingRecord': 0.1,
                        # simple earn
                        'simple-earn/flexible/list': 15,
                        'simple-earn/locked/list': 15,
                        'simple-earn/flexible/personalLeftQuota': 15,
                        'simple-earn/locked/personalLeftQuota': 15,
                        'simple-earn/flexible/subscriptionPreview': 15,
                        'simple-earn/locked/subscriptionPreview': 15,
                        'simple-earn/flexible/history/rateHistory': 15,
                        'simple-earn/flexible/position': 15,
                        'simple-earn/locked/position': 15,
                        'simple-earn/account': 15,
                        'simple-earn/flexible/history/subscriptionRecord': 15,
                        'simple-earn/locked/history/subscriptionRecord': 15,
                        'simple-earn/flexible/history/redemptionRecord': 15,
                        'simple-earn/locked/history/redemptionRecord': 15,
                        'simple-earn/flexible/history/rewardsRecord': 15,
                        'simple-earn/locked/history/rewardsRecord': 15,
                        'simple-earn/flexible/history/collateralRecord': 0.1,
                        # Convert
                        'dci/product/list': 0.1,
                        'dci/product/positions': 0.1,
                        'dci/product/accounts': 0.1,
                    },
                    'post': {
                        'account/disableFastWithdrawSwitch': 0.1,
                        'account/enableFastWithdrawSwitch': 0.1,
                        'asset/convert-transfer': 0.033335,
                        'asset/dust': 0.06667,  # Weight(UID): 10 => cost = 0.006667 * 10 = 0.06667
                        'asset/dust-btc': 0.1,
                        'asset/get-funding-asset': 0.1,
                        'asset/transfer': 6.0003,  # Weight(UID): 900 => cost = 0.006667 * 900 = 6.0003
                        'bnbBurn': 0.1,
                        'capital/contract/convertible-coins': 4.0002,
                        'capital/deposit/credit-apply': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'capital/withdraw/apply': 4.0002,  # Weight(UID): 600 => cost = 0.006667 * 600 = 4.0002
                        'futures/transfer': 0.1,
                        'managed-subaccount/deposit': 0.1,
                        'managed-subaccount/withdraw': 0.1,
                        'margin/borrow-repay': 20.001,
                        'margin/dust': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'margin/exchange-small-liability': 20.001,
                        'margin/isolated/account': 2.0001,  # Weight(UID): 300 => cost = 0.006667 * 300 = 2.0001
                        'margin/isolated/transfer': 4.0002,  # Weight(UID): 600 => cost = 0.006667 * 600 = 4.0002
                        'margin/loan': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                        'margin/max-leverage': 300,  # Weight(IP): 3000 => cost = 0.1 * 3000 = 300
                        'margin/order': 0.040002,  # Weight(UID): 6 => cost = 0.006667 * 6 = 0.040002
                        'margin/order/oco': 0.040002,
                        'margin/repay': 20.001,
                        'margin/transfer': 4.0002,
                        'sub-account/futures/enable': 0.1,
                        'sub-account/futures/internalTransfer': 0.1,
                        'sub-account/futures/transfer': 0.1,
                        'sub-account/margin/enable': 0.1,
                        'sub-account/margin/transfer': 4.0002,  # Weight(UID): 600 => cost =  0.006667 * 600 = 4.0002
                        'sub-account/options/enable': 0.1,
                        'sub-account/transfer/subToMaster': 0.1,
                        'sub-account/transfer/subToSub': 0.1,
                        'sub-account/universalTransfer': 0.1,
                        'sub-account/virtualSubAccount': 0.1,
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1,
                        # 'account/apiRestrictions/ipRestriction': 1, discontinued
                        # 'account/apiRestrictions/ipRestriction/ipList': 1, discontinued
                        # 'margin/isolated/create': 1, discontinued
                        # lending
                        'lending/customizedFixed/purchase': 0.1,
                        'lending/daily/purchase': 0.1,
                        'lending/daily/redeem': 0.1,
                        # liquid swap endpoints
                        'bswap/claimRewards': 6.667,  # Weight(UID): 1000 => cost = 0.006667 * 1000 = 6.667
                        'bswap/liquidityAdd': 60,  # Weight(UID): 1000 + (Additional: 1 request every 3 seconds =  0.333 requests per second) => cost = ( 1000 / rateLimit ) / 0.333 = 60.0000006
                        'bswap/liquidityRemove': 60,  # Weight(UID): 1000 + (Additional: 1 request every three seconds)
                        'bswap/swap': 60,  # Weight(UID): 1000 + (Additional: 1 request every three seconds)
                        # leveraged token endpoints
                        'blvt/redeem': 0.1,
                        'blvt/subscribe': 0.1,
                        # brokerage API TODO: NO MENTION OF RATELIMITS IN BROKERAGE DOCS
                        'apiReferral/customization': 1,
                        'apiReferral/kickback/historicalRecord': 1,
                        'apiReferral/rebate/historicalRecord': 1,
                        'apiReferral/userCustomization': 1,
                        'broker/rebate/historicalRecord': 1,
                        'broker/subAccount': 1,
                        'broker/subAccount/blvt': 1,
                        'broker/subAccount/bnbBurn/marginInterest': 1,
                        'broker/subAccount/bnbBurn/spot': 1,
                        'broker/subAccount/futures': 1,
                        'broker/subAccount/margin': 1,
                        'broker/subAccountApi': 1,
                        'broker/subAccountApi/commission': 1,
                        'broker/subAccountApi/commission/coinFutures': 1,
                        'broker/subAccountApi/commission/futures': 1,
                        'broker/subAccountApi/ipRestriction': 1,
                        'broker/subAccountApi/ipRestriction/ipList': 1,
                        'broker/subAccountApi/permission': 1,
                        'broker/subAccountApi/permission/universalTransfer': 1,
                        'broker/subAccountApi/permission/vanillaOptions': 1,
                        'broker/transfer': 1,
                        'broker/transfer/futures': 1,
                        'broker/universalTransfer': 1,
                        #
                        'algo/futures/newOrderTwap': 20.001,
                        'algo/futures/newOrderVp': 20.001,
                        'algo/spot/newOrderTwap': 20.001,
                        'giftcard/buyCode': 0.1,
                        'giftcard/createCode': 0.1,
                        'giftcard/redeemCode': 0.1,
                        # staking
                        'staking/purchase': 0.1,
                        'staking/redeem': 0.1,
                        'staking/setAutoStaking': 0.1,
                        # eth-staking
                        'eth-staking/eth/redeem': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/eth/stake': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'eth-staking/wbeth/wrap': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'sol-staking/sol/stake': 15,
                        'sol-staking/sol/redeem': 15,
                        # mining endpoints
                        'convert/acceptQuote': 3.3335,  # Weight(UID): 500 => cost = 0.006667 * 500 = 3.3335
                        'convert/getQuote': 1.3334,  # Weight(UID): 200 => cost = 0.006667 * 200 = 1.3334
                        'convert/limit/cancelOrder': 1.3334,  # Weight(UID): 200 => cost = 0.006667 * 200 = 1.3334
                        'convert/limit/placeOrder': 3.3335,  # Weight(UID): 500 => cost = 0.006667 * 500 = 3.3335
                        'lending/auto-invest/one-off': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/plan/add': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/plan/edit': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/plan/edit-status': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'lending/auto-invest/redeem': 0.1,  # Weight(IP): 1 => cost = 0.1 * 1 = 0.1
                        'loan/adjust/ltv': 40.002,
                        'loan/borrow': 40.002,
                        'loan/customize/margin_call': 40.002,
                        'loan/flexible/adjust/ltv': 40.002,  # TODO: Deprecating at 2024-04-24 03:00(UTC)
                        'loan/flexible/borrow': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'loan/flexible/repay': 40.002,  # TODO: Deprecating at 2024-04-24 03:00(UTC)
                        'loan/repay': 40.002,
                        'loan/vip/borrow': 40.002,
                        'loan/vip/renew': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'loan/vip/repay': 40.002,
                        'mining/hash-transfer/config': 0.5,  # Weight(IP): 5 => cost = 0.1 * 5 = 0.5
                        'mining/hash-transfer/config/cancel': 0.5,  # Weight(IP): 5 => cost = 0.1 * 5 = 0.5
                        'portfolio/asset-collection': 6,  # Weight(IP): 60 => cost = 0.1 * 60 = 6
                        'portfolio/auto-collection': 150,  # Weight(IP): 1500 => cost = 0.1 * 1500 = 150
                        'portfolio/bnb-transfer': 150,  # Weight(IP): 1500 => cost = 0.1 * 1500 = 150
                        'portfolio/mint': 20,
                        'portfolio/redeem': 20,
                        'portfolio/repay': 20.001,
                        'portfolio/repay-futures-negative-balance': 150,  # Weight(IP): 1500 => cost = 0.1 * 1500 = 150
                        'portfolio/repay-futures-switch': 150,  # Weight(IP): 1500 => cost = 0.1 * 1500 = 150
                        # simple earn
                        'simple-earn/flexible/redeem': 0.1,
                        'simple-earn/flexible/setAutoSubscribe': 15,
                        'simple-earn/flexible/subscribe': 0.1,
                        'simple-earn/locked/redeem': 0.1,
                        'simple-earn/locked/setAutoSubscribe': 15,
                        'simple-earn/locked/setRedeemOption': 5,
                        'simple-earn/locked/subscribe': 0.1,
                        # convert
                        'dci/product/auto_compound/edit': 0.1,
                        'dci/product/subscribe': 0.1,
                    },
                    'put': {
                        'userDataStream': 0.1,
                        'userDataStream/isolated': 0.1,
                    },
                },
                'sapiV2': {
                    'get': {
                        'eth-staking/account': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'loan/flexible/borrow/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/collateral/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/loanable/data': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/ltv/adjustment/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'loan/flexible/ongoing/orders': 30,  # Weight(IP): 300 => cost = 0.1 * 300 = 30
                        'loan/flexible/repay/history': 40,  # Weight(IP): 400 => cost = 0.1 * 400 = 40
                        'portfolio/account': 2,
                        'sub-account/futures/account': 0.1,
                        'sub-account/futures/accountSummary': 1,
                        'sub-account/futures/positionRisk': 0.1,
                    },
                    'post': {
                        'eth-staking/eth/stake': 15,  # Weight(IP): 150 => cost = 0.1 * 150 = 15
                        'loan/flexible/adjust/ltv': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'loan/flexible/borrow': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'loan/flexible/repay': 40.002,  # Weight(UID): 6000 => cost = 0.006667 * 6000 = 40.002
                        'sub-account/subAccountApi/ipRestriction': 20.001,  # Weight(UID): 3000 => cost = 0.006667 * 3000 = 20.001
                    },
                },
                'sapiV3': {
                    'get': {
                        'sub-account/assets': 0.40002,  # Weight(UID): 60 => cost =  0.006667 * 60 = 0.40002
                    },
                    'post': {
                        'asset/getUserAsset': 0.5,
                    },
                },
                'sapiV4': {
                    'get': {
                        'sub-account/assets': 0.40002,  # Weight(UID): 60 => cost = 0.006667 * 60 = 0.40002
                    },
                },
            },
            'certified': True,
            'commonCurrencies': {
                'BCC': 'BCC',  # kept for backward-compatibility https://github.com/ccxt/ccxt/issues/4848
                'YOYO': 'YOYOW',
            },
            'countries': ['JP', 'MT'],  # Japan, Malta
            'currencies': {
                'BNFCR': self.safe_currency_structure({'id': 'BNFCR', 'code': 'BNFCR', 'precision': self.parse_number('0.001')}),
            },
            'features': {
                'spot': {
                    'sandbox': True,
                    'createOrder': {
                        'marginMode': True,
                        'triggerPrice': True,
                        'triggerPriceType': None,
                        'triggerDirection': False,
                        'stopLossPrice': True,
                        'takeProfitPrice': True,
                        'attachedStopLossTakeProfit': None,  # not supported
                        'timeInForce': {
                            'IOC': True,
                            'FOK': True,
                            'PO': True,
                            'GTD': False,
                        },
                        'hedged': True,
                        'leverage': False,
                        'marketBuyRequiresPrice': False,
                        'marketBuyByCost': True,
                        # exchange-supported features
                        'selfTradePrevention': True,  # todo
                        'trailing': True,
                        'iceberg': True,  # todo implementation
                    },
                    'createOrders': None,
                    'fetchMyTrades': {
                        'marginMode': False,
                        'limit': 1000,
                        'daysBack': None,
                        'untilDays': 1,  # days between start-end
                    },
                    'fetchOrder': {
                        'marginMode': True,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOpenOrders': {
                        'marginMode': True,
                        'limit': None,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOrders': {
                        'marginMode': True,
                        'limit': 1000,
                        'daysBack': None,
                        'untilDays': 10000,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchClosedOrders': {
                        'marginMode': True,
                        'limit': 1000,
                        'daysBack': None,
                        'daysBackCanceled': None,
                        'untilDays': 10000,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOHLCV': {
                        'limit': 1000,
                    },
                },
                'default': {
                    'sandbox': True,
                    'createOrder': {
                        'marginMode': False,
                        'triggerPrice': True,
                        'triggerPriceType': {
                            'mark': True,
                            'last': True,
                            'index': False,
                        },
                        'stopLossPrice': True,
                        'takeProfitPrice': True,
                        'attachedStopLossTakeProfit': None,  # not supported
                        'timeInForce': {
                            'IOC': True,
                            'FOK': True,
                            'PO': True,
                            'GTD': True,
                            # 'GTX': True,
                        },
                        'hedged': True,
                        # exchange-supported features
                        'selfTradePrevention': True,  # todo
                        'trailing': True,
                        'iceberg': False,
                        'leverage': False,
                        'marketBuyRequiresPrice': False,
                        'marketBuyByCost': True,
                    },
                    'createOrders': {
                        'max': 5,
                    },
                    'fetchMyTrades': {
                        'marginMode': False,
                        'daysBack': None,
                        'limit': 1000,
                        'untilDays': 7,
                    },
                    'fetchOrder': {
                        'marginMode': False,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOpenOrders': {
                        'marginMode': True,
                        'limit': 500,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOrders': {
                        'marginMode': True,
                        'limit': 1000,
                        'daysBack': 90,
                        'untilDays': 7,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchClosedOrders': {
                        'marginMode': True,
                        'limit': 1000,
                        'daysBack': 90,
                        'daysBackCanceled': 3,
                        'untilDays': 7,
                        'trigger': False,
                        'trailing': False,
                    },
                    'fetchOHLCV': {
                        'limit': 1500,
                    },
                },
                'swap': {
                    'linear': {
                        'extends': 'default',
                    },
                    'inverse': {
                        'extends': 'default',
                    },
                },
                'future': {
                    'linear': {
                        'extends': 'default',
                    },
                    'inverse': {
                        'extends': 'default',
                    },
                },
            },
            'exceptions': {
                'broad': {
                    'has no operation privilege': PermissionDenied,
                    'MAX_POSITION': BadRequest,  # {"code":-2010,"msg":"Filter failure: MAX_POSITION"}
                },
                'exact': {
                    # error codes to cover ALL market types(however, specific market type might have override)
                    #
                    #        1xxx
                    #
                    '-1000': OperationFailed,  # {"code":-1000,"msg":"An unknown error occured while processing the request."}
                    '-1001': OperationFailed,  # {"code":-1001,"msg":"'Internal error; unable to process your request. Please try again.'"}
                    '-1002': AuthenticationError,  # {"code":-1002,"msg":"'You are not authorized to execute self request.'"}
                    '-1003': RateLimitExceeded,  # {"code":-1003,"msg":"Too much request weight used, current limit is 1200 request weight per 1 MINUTE. Please use the websocket for live updates to avoid polling the API."}
                    '-1004': OperationRejected,  # DUPLICATE_IP : This IP is already on the white list
                    '-1006': OperationFailed,  # {"code":-1006,"msg":"An unexpected response was received from the message bus. Execution status unknown."}
                    '-1007': RequestTimeout,  # {"code":-1007,"msg":"Timeout waiting for response from backend server. Send status unknown; execution status unknown."}
                    '-1010': OperationFailed,  # {"code":-1010,"msg":"ERROR_MSG_RECEIVED."}
                    '-1013': BadRequest,  # INVALID_MESSAGE
                    '-1014': InvalidOrder,  # {"code":-1014,"msg":"Unsupported order combination."}
                    '-1015': RateLimitExceeded,  # {"code":-1015,"msg":"'Too many new orders; current limit is %s orders per %s.'"}
                    '-1016': BadRequest,  # {"code":-1016,"msg":"'This service is no longer available.',"}
                    '-1020': BadRequest,  # {"code":-1020,"msg":"'This operation is not supported.'"}
                    '-1021': InvalidNonce,  # {"code":-1021,"msg":"'your time is ahead of server'"}
                    '-1022': AuthenticationError,  # {"code":-1022,"msg":"Signature for self request is not valid."}
                    '-1100': BadRequest,  # {"code":-1100,"msg":"createOrder(symbol, 1, asdf) -> 'Illegal characters found in parameter 'price'"}
                    '-1101': BadRequest,  # {"code":-1101,"msg":"Too many parameters; expected %s and received %s."}
                    '-1102': BadRequest,  # {"code":-1102,"msg":"Param %s or %s must be sent, but both were empty"}
                    '-1103': BadRequest,  # {"code":-1103,"msg":"An unknown parameter was sent."}
                    '-1104': BadRequest,  # {"code":-1104,"msg":"Not all sent parameters were read, read 8 parameters but was sent 9"}
                    '-1105': BadRequest,  # {"code":-1105,"msg":"Parameter %s was empty."}
                    '-1106': BadRequest,  # {"code":-1106,"msg":"Parameter %s sent when not required."}
                    '-1108': BadSymbol,  # {"code":-1108,"msg":"Invalid asset."}
                    '-1111': BadRequest,  # {"code":-1111,"msg":"Precision is over the maximum defined for self asset."}
                    '-1112': OperationFailed,  # {"code":-1112,"msg":"No orders on book for symbol."}
                    '-1114': BadRequest,  # {"code":-1114,"msg":"TimeInForce parameter sent when not required."}
                    '-1115': BadRequest,  # {"code":-1115,"msg":"Invalid timeInForce."}
                    '-1116': BadRequest,  # {"code":-1116,"msg":"Invalid orderType."}
                    '-1117': BadRequest,  # {"code":-1117,"msg":"Invalid side."}
                    '-1118': BadRequest,  # {"code":-1118,"msg":"New client order ID was empty."}
                    '-1119': BadRequest,  # {"code":-1119,"msg":"Original client order ID was empty."}
                    '-1120': BadRequest,  # {"code":-1120,"msg":"Invalid interval."}
                    '-1121': BadSymbol,  # {"code":-1121,"msg":"Invalid symbol."}
                    '-1125': AuthenticationError,  # {"code":-1125,"msg":"This listenKey does not exist."}
                    '-1127': BadRequest,  # {"code":-1127,"msg":"More than %s hours between startTime and endTime."}
                    '-1128': BadRequest,  # {"code":-1128,"msg":"Combination of optional parameters invalid."}
                    '-1130': BadRequest,  # {"code":-1130,"msg":"Data sent for paramter %s is not valid."}
                    #
                    #        2xxx
                    #
                    '-2010': InvalidOrder,  # NEW_ORDER_REJECTED
                    '-2011': OrderNotFound,  # {"code":-2011,"msg":"cancelOrder(1, 'BTC/USDT') -> 'UNKNOWN_ORDER'"}
                    '-2013': OrderNotFound,  # {"code":-2013,"msg":"fetchOrder(1, 'BTC/USDT') -> 'Order does not exist'"}
                    '-2014': AuthenticationError,  # {"code":-2014,"msg":"API-key format invalid."}
                    '-2015': AuthenticationError,  # {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
                    #
                    #        4xxx(common for linear, inverse, pm)
                    #
                    '-4000': InvalidOrder,  # INVALID_ORDER_STATUS
                    '-4001': BadRequest,  # PRICE_LESS_THAN_ZERO
                    '-4002': BadRequest,  # PRICE_GREATER_THAN_MAX_PRICE
                    '-4003': BadRequest,  # QTY_LESS_THAN_ZERO
                    '-4004': BadRequest,  # QTY_LESS_THAN_MIN_QTY
                    '-4005': BadRequest,  # QTY_GREATER_THAN_MAX_QTY
                    '-4006': BadRequest,  # STOP_PRICE_LESS_THAN_ZERO
                    '-4007': BadRequest,  # STOP_PRICE_GREATER_THAN_MAX_PRICE
                    '-4008': BadRequest,  # TICK SIZE LESS THAN ZERO
                    '-4009': BadRequest,  # MAX_PRICE_LESS_THAN_MIN_PRICE
                    '-4010': BadRequest,  # MAX_QTY_LESS_THAN_MIN_QTY
                    '-4011': BadRequest,  # STEP_SIZE_LESS_THAN_ZERO
                    '-4012': BadRequest,  # MAX_NUM_ORDERS_LESS_THAN_ZERO
                    '-4013': BadRequest,  # PRICE_LESS_THAN_MIN_PRICE
                    '-4014': BadRequest,  # PRICE NOT INCREASED BY TICK SIZE
                    '-4015': BadRequest,  # Client order id is not valid
                    '-4016': BadRequest,  # Price is higher than mark price multiplier cap.
                    '-4017': BadRequest,  # MULTIPLIER_UP_LESS_THAN_ZERO
                    '-4018': BadRequest,  # MULTIPLIER_DOWN_LESS_THAN_ZERO
                    '-4019': OperationRejected,  # COMPOSITE_SCALE_OVERFLOW
                    '-4020': BadRequest,  # TARGET_STRATEGY_INVALID
                    '-4021': BadRequest,  # INVALID_DEPTH_LIMIT
                    '-4022': BadRequest,  # WRONG_MARKET_STATUS
                    '-4023': BadRequest,  # QTY_NOT_INCREASED_BY_STEP_SIZE
                    '-4024': BadRequest,  # PRICE_LOWER_THAN_MULTIPLIER_DOWN
                    '-4025': BadRequest,  # MULTIPLIER_DECIMAL_LESS_THAN_ZERO
                    '-4026': BadRequest,  # COMMISSION_INVALID
                    '-4027': BadRequest,  # INVALID_ACCOUNT_TYPE
                    '-4028': BadRequest,  # INVALID_LEVERAGE
                    '-4029': BadRequest,  # INVALID_TICK SIZE_PRECISION
                    '-4030': BadRequest,  # INVALID_STEP_SIZE_PRECISION
                    '-4031': BadRequest,  # INVALID_WORKING_TYPE
                    '-4032': OperationRejected,  # EXCEED_MAX_CANCEL_ORDER_SIZE(or Invalid parameter working type: %s)
                    '-4033': BadRequest,  # INSURANCE_ACCOUNT_NOT_FOUND
                    '-4044': BadRequest,  # INVALID_BALANCE_TYPE
                    '-4045': OperationRejected,  # MAX_STOP_ORDER_EXCEEDED
                    '-4046': OperationRejected,  # NO_NEED_TO_CHANGE_MARGIN_TYPE
                    '-4047': OperationRejected,  # Margin type cannot be changed if there exists open orders.
                    '-4048': OperationRejected,  # Margin type cannot be changed if there exists position.
                    '-4049': BadRequest,  # Add margin only support for isolated position.
                    '-4050': InsufficientFunds,  # Cross balance insufficient
                    '-4051': InsufficientFunds,  # Isolated balance insufficient.
                    '-4052': OperationRejected,  # No need to change auto add margin.
                    '-4053': BadRequest,  # Auto add margin only support for isolated position.
                    '-4054': OperationRejected,  # Cannot add position margin: position is 0.
                    '-4055': BadRequest,  # Amount must be positive.
                    '-4056': AuthenticationError,  # INVALID_API_KEY_TYPE
                    '-4057': AuthenticationError,  # INVALID_RSA_PUBLIC_KEY: Invalid api public key
                    '-4058': BadRequest,  # MAX_PRICE_TOO_LARGE
                    '-4059': OperationRejected,  # NO_NEED_TO_CHANGE_POSITION_SIDE
                    '-4060': BadRequest,  # INVALID_POSITION_SIDE
                    '-4061': OperationRejected,  # POSITION_SIDE_NOT_MATCH: Order's position side does not match user's setting.
                    '-4062': BadRequest,  # REDUCE_ONLY_CONFLICT: Invalid or improper reduceOnly value.
                    '-4067': OperationRejected,  # Position side cannot be changed if there exists open orders.
                    '-4068': OperationRejected,  # Position side cannot be changed if there exists position.
                    '-4082': BadRequest,  # Invalid number of batch place orders.
                    '-4083': OperationRejected,  # PLACE_BATCH_ORDERS_FAIL : Fail to place batch orders.
                    '-4084': BadRequest,  # UPCOMING_METHOD : Method is not allowed currently. Upcoming soon.
                    '-4086': BadRequest,  # Invalid price spread threshold.
                    '-4104': BadRequest,  # INVALID_CONTRACT_TYPE
                    '-4135': BadRequest,  # Invalid activation price
                    '-4137': BadRequest,  # Quantity must be zero with closePosition equals True
                    '-4138': BadRequest,  # Reduce only must be True with closePosition equals True
                    '-4139': BadRequest,  # Order type can not be market if it's unable to cancel
                    '-4142': OrderImmediatelyFillable,  # REJECT: take profit or stop order will be triggered immediately
                    #
                    #        2xxxx
                    #
                    # 20xxx - spot & futures algo(TBD for OPTIONS & PORTFOLIO MARGIN)
                    '-20121': BadSymbol,  # Invalid symbol.
                    '-20124': BadRequest,  # Invalid algo id or it has been completed.
                    '-20130': BadRequest,  # Invalid data sent for a parameter
                    '-20132': BadRequest,  # The client algo id is duplicated
                    '-20194': BadRequest,  # Duration is too short to execute all required quantity.
                    '-20195': BadRequest,  # The total size is too small.
                    '-20196': BadRequest,  # The total size is too large.
                    '-20198': OperationRejected,  # Reach the max open orders allowed.
                    '-20204': BadRequest,  # The notional of USD is less or more than the limit.
                    #
                    # strings
                    #
                    'Account has insufficient balance for requested action.': InsufficientFunds,
                    'API key does not exist': AuthenticationError,
                    'Limit orders require GTC for self phase.': BadRequest,
                    'Market is closed.': MarketClosed,  # {"code":-1013,"msg":"Market is closed."}
                    'Order would immediately match and take.': OrderImmediatelyFillable,  # {"code":-2010,"msg":"Order would immediately match and take."}
                    'Order would trigger immediately.': OrderImmediatelyFillable,
                    'Rest API trading is not enabled.': PermissionDenied,
                    'Stop price would trigger immediately.': OrderImmediatelyFillable,  # {"code":-2010,"msg":"Stop price would trigger immediately."}
                    'System abnormality': OperationFailed,  # {"code":-1000,"msg":"System abnormality"}
                    'System is under maintenance.': OnMaintenance,  # {"code":1,"msg":"System is under maintenance."}
                    'This account may not place or cancel orders.': PermissionDenied,
                    'This action is disabled on self account.': AccountSuspended,  # {"code":-2011,"msg":"This action is disabled on self account."}
                    'This order type is not hasattr(self, possible) trading phase.': BadRequest,
                    'This symbol is not permitted for self account.': PermissionDenied,  # {"code":-2010,"msg":"This symbol is not permitted for self account."}
                    'This symbol is restricted for self account.': PermissionDenied,
                    'This type of sub-account exceeds the maximum number limit': OperationRejected,  # {"code":-9000,"msg":"This type of sub-account exceeds the maximum number limit"}
                    'Too many requests. Please try again later.': RateLimitExceeded,  # {"msg":"Too many requests. Please try again later.","success":false}
                    'You are not authorized to execute self request.': PermissionDenied,  # {"msg":"You are not authorized to execute self request."}
                    'You don\'t have permission.': PermissionDenied,  # {"msg":"You don't have permission.","success":false}
                },
                'inverse': {
                    'exact': {
                        #
                        #        1xxx
                        #
                        '-1005': PermissionDenied,  # {"code":-1005,"msg":"No such IP has been white listed"}
                        '-1011': PermissionDenied,  # {"code":-1011,"msg":"This IP cannot access self route."}
                        '-1023': BadRequest,  # {"code":-1023,"msg":"Start time is greater than end time."}
                        '-1109': AuthenticationError,  # {"code":-1109,"msg":"Invalid account."}
                        '-1110': BadSymbol,  # {"code":-1110,"msg":"Invalid symbolType."}
                        '-1113': BadRequest,  # {"code":-1113,"msg":"Withdrawal amount must be negative."}
                        '-1128': BadRequest,  # {"code":-1128,"msg":"Combination of optional parameters invalid."}
                        '-1136': BadRequest,  # {"code":-1136,"msg":"Invalid newOrderRespType"}
                        #
                        #        2xxx
                        #
                        '-2016': OperationRejected,  # {"code":-2016,"msg":"No trading window could be found for the symbol. Try ticker/24hrs instead."}
                        '-2018': InsufficientFunds,  # {"code":-2018,"msg":"Balance is insufficient"}
                        '-2019': InsufficientFunds,  # {"code":-2019,"msg":"Margin is insufficient."}
                        '-2020': OperationFailed,  # {"code":-2020,"msg":"Unable to fill."}
                        '-2021': OrderImmediatelyFillable,  # {"code":-2021,"msg":"Order would immediately trigger."}
                        '-2022': InvalidOrder,  # {"code":-2022,"msg":"ReduceOnly Order is rejected."}
                        '-2023': OperationFailed,  # {"code":-2023,"msg":"User in liquidation mode now."}
                        '-2024': BadRequest,  # {"code":-2024,"msg":"Position is not sufficient."}
                        '-2025': OperationRejected,  # {"code":-2025,"msg":"Reach max open order limit."}
                        '-2026': InvalidOrder,  # {"code":-2026,"msg":"This OrderType is not supported when reduceOnly."}
                        '-2027': OperationRejected,  # {"code":-2027,"msg":"Exceeded the maximum allowable position at current leverage."}
                        '-2028': OperationRejected,  # {"code":-2028,"msg":"Leverage is smaller than permitted: insufficient margin balance"}
                        #
                        #        4xxx
                        #
                        '-4086': BadRequest,  # Invalid price spread threshold.
                        '-4087': BadSymbol,  # Invalid pair
                        '-4088': BadRequest,  # Invalid time interval
                        '-4089': PermissionDenied,  # User can only place reduce only order.
                        '-4090': PermissionDenied,  # User can not place order currently.
                        '-4110': BadRequest,  # clientTranId is not valid
                        '-4111': BadRequest,  # clientTranId is duplicated.
                        '-4112': OperationRejected,  # ReduceOnly Order Failed. Please check your existing position and open orders.
                        '-4113': OperationRejected,  # The counterparty's best price does not meet the PERCENT_PRICE filter limit.
                        '-4150': OperationRejected,  # Leverage reduction is not supported in Isolated Margin Mode with open positions.
                        '-4151': BadRequest,  # Price is higher than stop price multiplier cap.
                        '-4152': BadRequest,  # Price is lower than stop price multiplier floor.
                        '-4154': BadRequest,  # Stop price is higher than price multiplier cap.
                        '-4155': BadRequest,  # Stop price is lower than price multiplier floor
                        '-4178': BadRequest,  # Order's notional must be no smaller than one(unless you choose reduce only)
                        '-4188': BadRequest,  # Timestamp for self request is outside of the ME recvWindow.
                        '-4192': PermissionDenied,  # Trade forbidden due to Cooling-off Period.
                        '-4194': PermissionDenied,  # Intermediate Personal Verification is required for adjusting leverage over 20x.
                        '-4195': PermissionDenied,  # More than 20x leverage is available one month after account registration.
                        '-4196': BadRequest,  # Only limit order is supported.
                        '-4197': OperationRejected,  # No need to modify the order.
                        '-4198': OperationRejected,  # Exceed maximum modify order limit.
                        '-4199': BadRequest,  # Symbol is not in trading status. Order amendment is not permitted.
                        '-4200': PermissionDenied,  # More than 20x leverage is available %s days after Futures account registration.
                        '-4201': PermissionDenied,  # Users in your location/country can only access a maximum leverage of %s
                        '-4202': OperationRejected,  # Current symbol leverage cannot exceed 20 when using position limit adjustment service.
                    },
                },
                'linear': {
                    'exact': {
                        #
                        #        1xxx
                        #
                        '-1005': PermissionDenied,  # {"code":-1005,"msg":"No such IP has been white listed"}
                        '-1008': OperationFailed,  # -1008 SERVER_BUSY: Server is currently overloaded with other requests. Please try again in a few minutes.
                        '-1011': PermissionDenied,  # {"code":-1011,"msg":"This IP cannot access self route."}
                        '-1023': BadRequest,  # {"code":-1023,"msg":"Start time is greater than end time."}
                        '-1099': AuthenticationError,  # {"code":-1099,"msg":"Not found, authenticated, or authorized"}
                        '-1109': PermissionDenied,  # {"code":-1109,"msg":"Invalid account."}
                        '-1110': BadRequest,  # {"code":-1110,"msg":"Invalid symbolType."}
                        '-1113': BadRequest,  # {"code":-1113,"msg":"Withdrawal amount must be negative."}
                        '-1122': BadRequest,  # INVALID_SYMBOL_STATUS
                        '-1126': BadSymbol,  # ASSET_NOT_SUPPORTED
                        '-1136': BadRequest,  # {"code":-1136,"msg":"Invalid newOrderRespType"}
                        #
                        #        2xxx
                        #
                        '-2012': OperationFailed,  # CANCEL_ALL_FAIL
                        '-2016': OperationRejected,  # {"code":-2016,"msg":"No trading window could be found for the symbol. Try ticker/24hrs instead."}
                        '-2017': PermissionDenied,  # API Keys are locked on self account.
                        '-2018': InsufficientFunds,  # {"code":-2018,"msg":"Balance is insufficient"}
                        '-2019': InsufficientFunds,  # {"code":-2019,"msg":"Margin is insufficient."}
                        '-2020': OperationFailed,  # {"code":-2020,"msg":"Unable to fill."}
                        '-2021': OrderImmediatelyFillable,  # {"code":-2021,"msg":"Order would immediately trigger."}
                        '-2022': InvalidOrder,  # {"code":-2022,"msg":"ReduceOnly Order is rejected."}
                        '-2023': OperationFailed,  # {"code":-2023,"msg":"User in liquidation mode now."}
                        '-2024': InsufficientFunds,  # {"code":-2024,"msg":"Position is not sufficient."}
                        '-2025': OperationRejected,  # {"code":-2025,"msg":"Reach max open order limit."}
                        '-2026': InvalidOrder,  # {"code":-2026,"msg":"This OrderType is not supported when reduceOnly."}
                        '-2027': OperationRejected,  # {"code":-2027,"msg":"Exceeded the maximum allowable position at current leverage."}
                        '-2028': OperationRejected,  # {"code":-2028,"msg":"Leverage is smaller than permitted: insufficient margin balance"}
                        #
                        #        4xxx
                        #
                        '-4063': BadRequest,  # INVALID_OPTIONS_REQUEST_TYPE
                        '-4064': BadRequest,  # INVALID_OPTIONS_TIME_FRAME
                        '-4065': BadRequest,  # INVALID_OPTIONS_AMOUNT
                        '-4066': BadRequest,  # INVALID_OPTIONS_EVENT_TYPE
                        '-4069': BadRequest,  # Position INVALID_OPTIONS_PREMIUM_FEE
                        '-4070': BadRequest,  # Client options id is not valid.
                        '-4071': BadRequest,  # Invalid options direction
                        '-4072': OperationRejected,  # premium fee is not updated, reject order
                        '-4073': BadRequest,  # OPTIONS_PREMIUM_INPUT_LESS_THAN_ZERO
                        '-4074': OperationRejected,  # Order amount is bigger than upper boundary or less than 0, reject order
                        '-4075': BadRequest,  # output premium fee is less than 0, reject order
                        '-4076': OperationRejected,  # original fee is too much higher than last fee
                        '-4077': OperationRejected,  # place order amount has reached to limit, reject order
                        '-4078': OperationFailed,  # options internal error
                        '-4079': BadRequest,  # invalid options id
                        '-4080': PermissionDenied,  # user not found with id: %s
                        '-4081': BadRequest,  # OPTIONS_NOT_FOUND
                        '-4085': BadRequest,  # Invalid notional limit coefficient
                        '-4087': PermissionDenied,  # User can only place reduce only order
                        '-4088': PermissionDenied,  # User can not place order currently
                        '-4114': BadRequest,  # INVALID_CLIENT_TRAN_ID_LEN
                        '-4115': BadRequest,  # DUPLICATED_CLIENT_TRAN_ID
                        '-4116': InvalidOrder,  # DUPLICATED_CLIENT_ORDER_ID
                        '-4117': OperationRejected,  # STOP_ORDER_TRIGGERING
                        '-4118': OperationRejected,  # REDUCE_ONLY_MARGIN_CHECK_FAILED
                        '-4131': OperationRejected,  # The counterparty's best price does not meet the PERCENT_PRICE filter limit
                        '-4140': BadRequest,  # Invalid symbol status for opening position
                        '-4141': OperationRejected,  # Symbol is closed
                        '-4144': BadSymbol,  # Invalid pair
                        '-4164': InvalidOrder,  # {"code":-4164,"msg":"Order's notional must be no smaller than 20(unless you choose reduce only)."},
                        '-4136': InvalidOrder,  # {"code":-4136,"msg":"Target strategy invalid for orderType TRAILING_STOP_MARKET,closePosition True"}
                        '-4165': BadRequest,  # Invalid time interval
                        '-4167': BadRequest,  # Unable to adjust to Multi-Assets mode with symbols of USD-M Futures under isolated-margin mode.
                        '-4168': BadRequest,  # Unable to adjust to isolated-margin mode under the Multi-Assets mode.
                        '-4169': OperationRejected,  # Unable to adjust Multi-Assets Mode with insufficient margin balance in USD-M Futures
                        '-4170': OperationRejected,  # Unable to adjust Multi-Assets Mode with open orders in USD-M Futures
                        '-4171': OperationRejected,  # Adjusted asset mode is currently set and does not need to be adjusted repeatedly
                        '-4172': OperationRejected,  # Unable to adjust Multi-Assets Mode with a negative wallet balance of margin available asset in USD-M Futures account.
                        '-4183': BadRequest,  # Price is higher than stop price multiplier cap.
                        '-4184': BadRequest,  # Price is lower than stop price multiplier floor.
                        '-4192': PermissionDenied,  # Trade forbidden due to Cooling-off Period.
                        '-4202': PermissionDenied,  # Intermediate Personal Verification is required for adjusting leverage over 20x
                        '-4203': PermissionDenied,  # More than 20x leverage is available one month after account registration.
                        '-4205': PermissionDenied,  # More than 20x leverage is available %s days after Futures account registration.
                        '-4206': PermissionDenied,  # hasattr(self, Users) country has limited adjust leverage.
                        '-4208': OperationRejected,  # Current symbol leverage cannot exceed 20 when using position limit adjustment service.
                        '-4209': OperationRejected,  # Leverage adjustment failed. Current symbol max leverage limit is %sx
                        '-4210': BadRequest,  # Stop price is higher than price multiplier cap
                        '-4211': BadRequest,  # Stop price is lower than price multiplier floor
                        '-4400': PermissionDenied,  # Futures Trading Quantitative Rules violated, only reduceOnly order is allowed, please try again later.
                        '-4401': PermissionDenied,  # Compliance restricted account permission: can only place reduceOnly order.
                        '-4402': PermissionDenied,  # Dear user, our Terms of Use and compliance with local regulations, self feature is currently not available in your region.
                        '-4403': PermissionDenied,  # Dear user, our Terms of Use and compliance with local regulations, the leverage can only up to %sx in your region
                        #
                        #        5xxx
                        #
                        '-5021': OrderNotFillable,  # Due to the order could not be filled immediately, the FOK order has been rejected.
                        '-5022': OrderNotFillable,  # Due to the order could not be executed, the Post Only order will be rejected.
                        '-5024': OperationRejected,  # Symbol is not in trading status. Order amendment is not permitted.
                        '-5025': OperationRejected,  # Only limit order is supported.
                        '-5026': OperationRejected,  # Exceed maximum modify order limit.
                        '-5027': OperationRejected,  # No need to modify the order.
                        '-5028': BadRequest,  # Timestamp for self request is outside of the ME recvWindow.
                        '-5037': BadRequest,  # Invalid price match
                        '-5038': BadRequest,  # Price match only supports order type: LIMIT, STOP AND TAKE_PROFIT
                        '-5039': BadRequest,  # Invalid self trade prevention mode
                        '-5040': BadRequest,  # The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
                        '-5041': OperationFailed,  # No depth matches self BBO order
                    },
                },
                'option': {
                    'exact': {
                        #
                        #        1xxx
                        #
                        '-1003': ExchangeError,  # override common
                        '-1004': ExchangeError,  # override common
                        '-1006': ExchangeError,  # override common
                        '-1007': ExchangeError,  # override common
                        '-1008': RateLimitExceeded,  # TOO_MANY_REQUEST
                        '-1010': ExchangeError,  # override common
                        '-1013': ExchangeError,  # override common
                        '-1108': ExchangeError,  # override common
                        '-1112': ExchangeError,  # override common
                        '-1114': ExchangeError,  # override common
                        '-1128': BadSymbol,  # BAD_CONTRACT
                        '-1129': BadSymbol,  # BAD_CURRENCY
                        '-1131': BadRequest,  # {"code":-1131,"msg":"recvWindow must be less than 60000"}
                        #
                        #        2xxx
                        #
                        '-2011': ExchangeError,  # override common
                        '-2018': InsufficientFunds,  # BALANCE_NOT_SUFFICIENT
                        '-2027': InsufficientFunds,  # OPTION_MARGIN_NOT_SUFFICIENT
                        #
                        #        3xxx
                        #
                        '-3029': OperationFailed,  # {"code":-3029,"msg":"Transfer failed."}
                        #
                        #        4xxx
                        #
                        # -4001 inherited
                        # -4002 inherited
                        # -4003 inherited
                        # -4004 inherited
                        # -4005 inherited
                        '-4006': ExchangeError,  # override commons
                        '-4007': ExchangeError,  # override commons
                        '-4008': ExchangeError,  # override commons
                        '-4009': ExchangeError,  # override commons
                        '-4010': ExchangeError,  # override commons
                        '-4011': ExchangeError,  # override commons
                        '-4012': ExchangeError,  # override commons
                        # -4013 inherited
                        '-4014': ExchangeError,  # override commons
                        '-4015': ExchangeError,  # override commons
                        '-4016': ExchangeError,  # override commons
                        '-4017': ExchangeError,  # override commons
                        '-4018': ExchangeError,  # override commons
                        '-4019': ExchangeError,  # override commons
                        '-4020': ExchangeError,  # override commons
                        '-4021': ExchangeError,  # override commons
                        '-4022': ExchangeError,  # override commons
                        '-4023': ExchangeError,  # override commons
                        '-4024': ExchangeError,  # override commons
                        '-4025': ExchangeError,  # override commons
                        '-4026': ExchangeError,  # override commons
                        '-4027': ExchangeError,  # override commons
                        '-4028': ExchangeError,  # override commons
                        # -4029 inherited
                        # -4030 inherited
                        '-4031': ExchangeError,  # override commons
                        '-4032': ExchangeError,  # override commons
                        '-4033': ExchangeError,  # override commons
                        '-4034': ExchangeError,  # override commons
                        '-4035': ExchangeError,  # override commons
                        '-4036': ExchangeError,  # override commons
                        '-4037': ExchangeError,  # override commons
                        '-4038': ExchangeError,  # override commons
                        '-4039': ExchangeError,  # override commons
                        '-4040': ExchangeError,  # override commons
                        '-4041': ExchangeError,  # override commons
                        '-4042': ExchangeError,  # override commons
                        '-4043': ExchangeError,  # override commons
                        '-4044': ExchangeError,  # override commons
                        '-4045': ExchangeError,  # override commons
                        '-4046': ExchangeError,  # override commons
                        '-4047': ExchangeError,  # override commons
                        '-4048': ExchangeError,  # override commons
                        '-4049': ExchangeError,  # override commons
                        '-4050': ExchangeError,  # override commons
                        '-4051': ExchangeError,  # override commons
                        '-4052': ExchangeError,  # override commons
                        '-4053': ExchangeError,  # override commons
                        '-4054': ExchangeError,  # override commons
                        # -4055 inherited
                        '-4056': ExchangeError,  # override commons
                        '-4057': ExchangeError,  # override commons
                        '-4058': ExchangeError,  # override commons
                        '-4059': ExchangeError,  # override commons
                        '-4060': ExchangeError,  # override commons
                        '-4061': ExchangeError,  # override commons
                        '-4062': ExchangeError,  # override commons
                        '-4063': ExchangeError,  # override commons
                        '-4064': ExchangeError,  # override commons
                        '-4065': ExchangeError,  # override commons
                        '-4066': ExchangeError,  # override commons
                        '-4067': ExchangeError,  # override commons
                        '-4068': ExchangeError,  # override commons
                        '-4069': ExchangeError,  # override commons
                        '-4070': ExchangeError,  # override commons
                        '-4071': ExchangeError,  # override commons
                        '-4072': ExchangeError,  # override commons
                        '-4073': ExchangeError,  # override commons
                        '-4074': ExchangeError,  # override commons
                        '-4075': ExchangeError,  # override commons
                        '-4076': ExchangeError,  # override commons
                        '-4077': ExchangeError,  # override commons
                        '-4078': ExchangeError,  # override commons
                        '-4079': ExchangeError,  # override commons
                        '-4080': ExchangeError,  # override commons
                        '-4081': ExchangeError,  # override commons
                        '-4082': ExchangeError,  # override commons
                        '-4083': ExchangeError,  # override commons
                        '-4084': ExchangeError,  # override commons
                        '-4085': ExchangeError,  # override commons
                        '-4086': ExchangeError,  # override commons
                        '-4087': ExchangeError,  # override commons
                        '-4088': ExchangeError,  # override commons
                        '-4089': ExchangeError,  # override commons
                        '-4091': ExchangeError,  # override commons
                        '-4092': ExchangeError,  # override commons
                        '-4093': ExchangeError,  # override commons
                        '-4094': ExchangeError,  # override commons
                        '-4095': ExchangeError,  # override commons
                        '-4096': ExchangeError,  # override commons
                        '-4097': ExchangeError,  # override commons
                        '-4098': ExchangeError,  # override commons
                        '-4099': ExchangeError,  # override commons
                        '-4101': ExchangeError,  # override commons
                        '-4102': ExchangeError,  # override commons
                        '-4103': ExchangeError,  # override commons
                        '-4104': ExchangeError,  # override commons
                        '-4105': ExchangeError,  # override commons
                        '-4106': ExchangeError,  # override commons
                        '-4107': ExchangeError,  # override commons
                        '-4108': ExchangeError,  # override commons
                        '-4109': ExchangeError,  # override commons
                        '-4110': ExchangeError,  # override commons
                        '-4112': ExchangeError,  # override commons
                        '-4113': ExchangeError,  # override commons
                        '-4114': ExchangeError,  # override commons
                        '-4115': ExchangeError,  # override commons
                        '-4116': ExchangeError,  # override commons
                        '-4117': ExchangeError,  # override commons
                        '-4118': ExchangeError,  # override commons
                        '-4119': ExchangeError,  # override commons
                        '-4120': ExchangeError,  # override commons
                        '-4121': ExchangeError,  # override commons
                        '-4122': ExchangeError,  # override commons
                        '-4123': ExchangeError,  # override commons
                        '-4124': ExchangeError,  # override commons
                        '-4125': ExchangeError,  # override commons
                        '-4126': ExchangeError,  # override commons
                        '-4127': ExchangeError,  # override commons
                        '-4128': ExchangeError,  # override commons
                        '-4129': ExchangeError,  # override commons
                        '-4130': ExchangeError,  # override commons
                        '-4131': ExchangeError,  # override commons
                        '-4132': ExchangeError,  # override commons
                        '-4133': ExchangeError,  # override commons
                        '-4134': ExchangeError,  # override commons
                        '-4135': ExchangeError,  # override commons
                        '-4136': ExchangeError,  # override commons
                        '-4137': ExchangeError,  # override commons
                        '-4138': ExchangeError,  # override commons
                        '-4139': ExchangeError,  # override commons
                        '-4141': ExchangeError,  # override commons
                        '-4142': ExchangeError,  # override commons
                        '-4143': ExchangeError,  # override commons
                        '-4144': ExchangeError,  # override commons
                        '-4145': ExchangeError,  # override commons
                        '-4146': ExchangeError,  # override commons
                        '-4147': ExchangeError,  # override commons
                        '-4148': ExchangeError,  # override commons
                        '-4149': ExchangeError,  # override commons
                        '-4150': ExchangeError,  # override commons
                        #
                        #        2xxxx
                        #
                        '-20121': ExchangeError,  # override commons
                        '-20124': ExchangeError,  # override commons
                        '-20130': ExchangeError,  # override commons
                        '-20132': ExchangeError,  # override commons
                        '-20194': ExchangeError,  # override commons
                        '-20195': ExchangeError,  # override commons
                        '-20196': ExchangeError,  # override commons
                        '-20198': ExchangeError,  # override commons
                        '-20204': ExchangeError,  # override commons
                    },
                },
                'portfolioMargin': {
                    'exact': {
                        #
                        #        10xx General Server or Network Issues
                        #
                        '-1000': OperationFailed,  # An unknown error occured while processing the request.
                        '-1001': ExchangeError,  # Internal error; unable to process your request. Please try again.
                        '-1002': PermissionDenied,  # You are not authorized to execute self request.
                        '-1003': RateLimitExceeded,  # Too many requests use the websocket for live updates to avoid polling the API.
                        '-1004': BadRequest,  # This IP is already on the white list.
                        '-1005': PermissionDenied,  # No such IP has been white listed.
                        '-1006': BadResponse,  # An unexpected response was received from the message bus. Execution status unknown.
                        '-1007': BadResponse,  # Timeout waiting for response from backend server. Send status unknown, execution status unknown.
                        '-1008': OperationFailed,  # WS Spot server is currently overloaded with other requests. Please try again in a few minutes.
                        '-1010': ExchangeError,  # ERROR_MSG_RECEIVED
                        '-1011': PermissionDenied,  # This IP cannot access self route.
                        '-1013': ExchangeError,  # INVALID_MESSAGE.
                        '-1014': InvalidOrder,  # Unsupported order combination.
                        '-1015': InvalidOrder,  # Too many new orders.
                        '-1016': NotSupported,  # This service is no longer available.
                        '-1020': NotSupported,  # This operation is not supported.
                        '-1021': BadRequest,  # Timestamp for self request is outside of the recvWindow 1000ms ahead of the servers time.
                        '-1022': BadRequest,  # Signature for self request is not valid.
                        '-1023': BadRequest,  # Start time is greater than end time
                        '-1099': OperationFailed,  # WS not found authenticated or authorized
                        #
                        #        11xx Request Issues
                        #
                        '-1100': BadRequest,  # Illegal characters found in a parameter.
                        '-1101': BadRequest,  # Too many parameters sent for self endpoint.
                        '-1102': BadRequest,  # A mandatory parameter was not sent, was empty/null, or malformed.
                        '-1103': BadRequest,  # An unknown parameter was sent.
                        '-1104': BadRequest,  # Not all sent parameters were read.
                        '-1105': BadRequest,  # A parameter was empty.
                        '-1106': BadRequest,  # A parameter was sent when not required.
                        '-1108': BadRequest,  # Invalid asset.
                        '-1109': BadRequest,  # Invalid account.
                        '-1110': BadSymbol,  # Invalid symbolType.
                        '-1111': BadRequest,  # Precision is over the maximum defined for self asset.
                        '-1112': BadRequest,  # No orders on book for symbol.
                        '-1113': BadRequest,  # Withdrawal amount must be negative.
                        '-1114': BadRequest,  # TimeInForce parameter sent when not required.
                        '-1115': BadRequest,  # Invalid timeInForce.
                        '-1116': BadRequest,  # Invalid orderType.
                        '-1117': BadRequest,  # Invalid side.
                        '-1118': BadRequest,  # New client order ID was empty.
                        '-1119': BadRequest,  # Original client order ID was empty.
                        '-1120': BadRequest,  # Invalid interval.
                        '-1121': BadSymbol,  # Invalid symbol.
                        '-1125': BadRequest,  # This listenKey does not exist.
                        '-1127': BadRequest,  # Lookup interval is too big.
                        '-1128': BadRequest,  # Combination of optional parameters invalid.
                        '-1130': BadRequest,  # Invalid data sent for a parameter.
                        '-1131': BadRequest,  # WS recvWindow must be less than 60000
                        '-1134': BadRequest,  # WS strategyType was less than 1000000.
                        '-1136': BadRequest,  # Invalid newOrderRespType.
                        '-1145': BadRequest,  # WS cancelRestrictions has to be either ONLY_NEW or ONLY_PARTIALLY_FILLED.
                        '-1151': BadRequest,  # WS Symbol is present multiple times in the list.
                        #
                        #        20xx Processing Issues
                        #
                        '-2010': InvalidOrder,  # NEW_ORDER_REJECTED
                        '-2011': OperationRejected,  # CANCEL_REJECTED
                        '-2013': OrderNotFound,  # Order does not exist.
                        '-2014': OperationRejected,  # API-key format invalid.
                        '-2015': OperationRejected,  # Invalid API-key, IP, or permissions for action.
                        '-2016': OperationFailed,  # No trading window could be found for the symbol. Try ticker/24hrs instead.
                        '-2018': OperationFailed,  # Balance is insufficient.
                        '-2019': OperationFailed,  # Margin is insufficient.
                        '-2020': OrderNotFillable,  # Unable to fill.
                        '-2021': OrderImmediatelyFillable,  # Order would immediately trigger.
                        '-2022': InvalidOrder,  # ReduceOnly Order is rejected.
                        '-2023': OperationFailed,  # User in liquidation mode now.
                        '-2024': OperationRejected,  # Position is not sufficient.
                        '-2025': OperationRejected,  # Reach max open order limit.
                        '-2026': InvalidOrder,  # This OrderType is not supported when reduceOnly.
                        '-2027': OperationRejected,  # Exceeded the maximum allowable position at current leverage.
                        '-2028': OperationRejected,  # Leverage is smaller than permitted: insufficient margin balance.
                        #
                        #        4xxx Filters and other issues
                        #
                        '-4000': BadRequest,  # Invalid order status.
                        '-4001': BadRequest,  # Price less than 0.
                        '-4002': BadRequest,  # Price greater than max price.
                        '-4003': BadRequest,  # Quantity less than zero.
                        '-4004': BadRequest,  # Quantity less than min quantity.
                        '-4005': BadRequest,  # Quantity greater than max quantity.
                        '-4006': BadRequest,  # Stop price less than zero.
                        '-4007': BadRequest,  # Stop price greater than max price.
                        '-4008': BadRequest,  # Tick size less than zero.
                        '-4009': BadRequest,  # Max price less than min price.
                        '-4010': BadRequest,  # Max qty less than min qty.
                        '-4011': BadRequest,  # Step size less than zero.
                        '-4012': BadRequest,  # Max mum orders less than zero.
                        '-4013': BadRequest,  # Price less than min price.
                        '-4014': BadRequest,  # Price not increased by tick size.
                        '-4015': BadRequest,  # Client order id is not valid.
                        '-4016': BadRequest,  # Price is higher than mark price multiplier cap.
                        '-4017': BadRequest,  # Multiplier up less than zero.
                        '-4018': BadRequest,  # Multiplier down less than zero.
                        '-4019': BadRequest,  # Composite scale too large.
                        '-4020': BadRequest,  # Target strategy invalid for orderType '%s',reduceOnly '%b'.
                        '-4021': BadRequest,  # Invalid depth limit.
                        '-4022': BadRequest,  # market status sent is not valid.
                        '-4023': BadRequest,  # Qty not increased by step size.
                        '-4024': BadRequest,  # Price is lower than mark price multiplier floor.
                        '-4025': BadRequest,  # Multiplier decimal less than zero.
                        '-4026': BadRequest,  # Commission invalid.
                        '-4027': BadRequest,  # Invalid account type.
                        '-4028': BadRequest,  # Invalid leverage
                        '-4029': BadRequest,  # Tick size precision is invalid.
                        '-4030': BadRequest,  # Step size precision is invalid.
                        '-4031': BadRequest,  # Invalid parameter working type
                        '-4032': BadRequest,  # Exceed maximum cancel order size.
                        '-4033': BadRequest,  # Insurance account not found.
                        '-4044': BadRequest,  # Balance Type is invalid.
                        '-4045': BadRequest,  # Reach max stop order limit.
                        '-4046': BadRequest,  # No need to change margin type.
                        '-4047': BadRequest,  # Margin type cannot be changed if there exists open orders.
                        '-4048': BadRequest,  # Margin type cannot be changed if there exists position.
                        '-4049': BadRequest,  # Add margin only support for isolated position.
                        '-4050': BadRequest,  # Cross balance insufficient.
                        '-4051': BadRequest,  # Isolated balance insufficient.
                        '-4052': BadRequest,  # No need to change auto add margin.
                        '-4053': BadRequest,  # Auto add margin only support for isolated position.
                        '-4054': BadRequest,  # Cannot add position margin: position is 0.
                        '-4055': BadRequest,  # Amount must be positive.
                        '-4056': PermissionDenied,  # Invalid api key type.
                        '-4057': PermissionDenied,  # Invalid api public key
                        '-4058': BadRequest,  # maxPrice and priceDecimal too large,please check.
                        '-4059': BadRequest,  # No need to change position side.
                        '-4060': BadRequest,  # Invalid position side.
                        '-4061': InvalidOrder,  # Order's position side does not match user's setting.
                        '-4062': BadRequest,  # Invalid or improper reduceOnly value.
                        '-4063': BadRequest,  # Invalid options request type
                        '-4064': BadRequest,  # Invalid options time frame
                        '-4065': BadRequest,  # Invalid options amount
                        '-4066': BadRequest,  # Invalid options event type
                        '-4067': BadRequest,  # Position side cannot be changed if there exists open orders.
                        '-4068': BadRequest,  # Position side cannot be changed if there exists position.
                        '-4069': BadRequest,  # Invalid options premium fee
                        '-4070': BadRequest,  # Client options id is not valid.
                        '-4071': BadRequest,  # Invalid options direction
                        '-4072': OperationRejected,  # premium fee is not updated, reject order
                        '-4073': BadRequest,  # input premium fee is less than 0, reject order
                        '-4074': BadRequest,  # Order amount is bigger than upper boundary or less than 0, reject order
                        '-4075': BadRequest,  # output premium fee is less than 0, reject order
                        '-4076': OperationRejected,  # original fee is too much higher than last fee
                        '-4077': OperationRejected,  # place order amount has reached to limit, reject order
                        '-4078': OperationFailed,  # options internal error
                        '-4079': BadRequest,  # invalid options id
                        '-4080': PermissionDenied,  # user not found
                        '-4081': BadRequest,  # options not found
                        '-4082': BadRequest,  # Invalid number of batch place orders.
                        '-4083': BadRequest,  # Fail to place batch orders.
                        '-4084': NotSupported,  # Method is not allowed currently. Upcoming soon.
                        '-4085': BadRequest,  # Invalid notional limit coefficient
                        '-4086': BadRequest,  # Invalid price spread threshold
                        '-4087': PermissionDenied,  # User can only place reduce only order
                        '-4088': PermissionDenied,  # User can not place order currently
                        '-4104': BadRequest,  # Invalid contract type
                        '-4114': BadRequest,  # clientTranId is not valid
                        '-4115': BadRequest,  # clientTranId is duplicated
                        '-4118': OperationRejected,  # ReduceOnly Order Failed. Please check your existing position and open orders
                        '-4131': OperationRejected,  # The counterparty's best price does not meet the PERCENT_PRICE filter limit
                        '-4135': BadRequest,  # Invalid activation price
                        '-4137': BadRequest,  # Quantity must be zero with closePosition equals True
                        '-4138': BadRequest,  # Reduce only must be True with closePosition equals True
                        '-4139': BadRequest,  # Order type can not be market if it's unable to cancel
                        '-4140': OrderImmediatelyFillable,  # Invalid symbol status for opening position
                        '-4141': BadRequest,  # Symbol is closed
                        '-4142': OrderImmediatelyFillable,  # REJECT: take profit or stop order will be triggered immediately
                        '-4144': BadSymbol,  # Invalid pair
                        '-4161': OperationRejected,  # Leverage reduction is not supported in Isolated Margin Mode with open positions
                        '-4164': InvalidOrder,  # Order's notional must be no smaller than 5.0(unless you choose reduce only)
                        '-4165': BadRequest,  # Invalid time interval
                        '-4183': InvalidOrder,  # Price is higher than stop price multiplier cap.
                        '-4184': InvalidOrder,  # Price is lower than stop price multiplier floor.
                        '-4408': InvalidOrder,  # This symbol is in reduce only mode due to regulation requirements. Please upgrade to Binance Credits Trading Mode.
                        #
                        #        5xxx Order Execution Issues
                        #
                        '-5021': OrderNotFillable,  # Due to the order could not be filled immediately, the FOK order has been rejected.
                        '-5022': OrderNotFillable,  # Due to the order could not be executed, the Post Only order will be rejected.
                        '-5028': OperationFailed,  # The requested timestamp is outside the recvWindow of the matching engine
                        '-5041': RateLimitExceeded,  # Time out for too many requests from self account queueing at the same time.
                    },
                },
                'spot': {
                    'exact': {
                        #
                        #        1xxx
                        #
                        '-1004': OperationFailed,  # {"code":-1004,"msg":"Server is busy, please wait and try again"}
                        '-1008': OperationFailed,  # undocumented, but mentioned: This is sent whenever the servers are overloaded with requests.
                        '-1099': AuthenticationError,  # {"code":-1099,"msg":"Not found, authenticated, or authorized"}
                        '-1108': BadRequest,  # undocumented, but mentioned: This error will occur if a value to a parameter being sent was too large, potentially causing overflow
                        '-1131': BadRequest,  # {"code":-1131,"msg":"recvWindow must be less than 60000"}
                        '-1134': BadRequest,  # strategyType was less than 1000000.
                        '-1135': BadRequest,  # undocumented, but mentioned: This error code will occur if a parameter requiring a JSON object is invalid.
                        '-1145': BadRequest,  # cancelRestrictions has to be either ONLY_NEW or ONLY_PARTIALLY_FILLED.
                        '-1151': BadSymbol,  # Symbol is present multiple times in the list.
                        #
                        #        2xxx
                        #
                        '-2008': AuthenticationError,  # undocumented, Invalid Api-Key ID
                        '-2016': OperationRejected,  # {"code":-2016,"msg":"No trading window could be found for the symbol. Try ticker/24hrs instead."}
                        '-2021': BadResponse,  # This code is sent when either the cancellation of the order failed or the new order placement failed but not both.
                        '-2022': BadResponse,  # This code is sent when both the cancellation of the order failed and the new order placement failed.
                        '-2026': InvalidOrder,  # Order was canceled or expired with no executed qty over 90 days ago and has been archived.
                        #
                        #        3xxx(these errors are available only for spot atm)
                        #
                        '-3000': OperationFailed,  # {"code":-3000,"msg":"Internal server error."}
                        '-3001': AuthenticationError,  # {"code":-3001,"msg":"Please enable 2FA first."}
                        '-3002': BadSymbol,  # {"code":-3002,"msg":"We don't have self asset."}
                        '-3003': BadRequest,  # {"code":-3003,"msg":"Margin account does not exist."}
                        '-3004': OperationRejected,  # {"code":-3004,"msg":"Trade not allowed."}
                        '-3005': BadRequest,  # {"code":-3005,"msg":"Transferring out not allowed. Transfer out amount exceeds max amount."}
                        '-3006': BadRequest,  # {"code":-3006,"msg":"Your borrow amount has exceed maximum borrow amount."}
                        '-3007': OperationFailed,  # {"code":-3007,"msg":"You have pending transaction, please try again later.."}
                        '-3008': BadRequest,  # {"code":-3008,"msg":"Borrow not allowed. Your borrow amount has exceed maximum borrow amount."}
                        '-3009': OperationRejected,  # {"code":-3009,"msg":"This asset are not allowed to transfer into margin account currently."}
                        '-3010': BadRequest,  # {"code":-3010,"msg":"Repay not allowed. Repay amount exceeds borrow amount."}
                        '-3011': BadRequest,  # {"code":-3011,"msg":"Your input date is invalid."}
                        '-3012': OperationRejected,  # {"code":-3012,"msg":"Borrow is banned for self asset."}
                        '-3013': BadRequest,  # {"code":-3013,"msg":"Borrow amount less than minimum borrow amount."}
                        '-3014': AccountSuspended,  # {"code":-3014,"msg":"Borrow is banned for self account."}
                        '-3015': BadRequest,  # {"code":-3015,"msg":"Repay amount exceeds borrow amount."}
                        '-3016': BadRequest,  # {"code":-3016,"msg":"Repay amount less than minimum repay amount."}
                        '-3017': OperationRejected,  # {"code":-3017,"msg":"This asset are not allowed to transfer into margin account currently."}
                        '-3018': AccountSuspended,  # {"code":-3018,"msg":"Transferring in has been banned for self account."}
                        '-3019': AccountSuspended,  # {"code":-3019,"msg":"Transferring out has been banned for self account."}
                        '-3020': BadRequest,  # {"code":-3020,"msg":"Transfer out amount exceeds max amount."}
                        '-3021': BadRequest,  # {"code":-3021,"msg":"Margin account are not allowed to trade self trading pair."}
                        '-3022': AccountSuspended,  # {"code":-3022,"msg":"You account's trading is banned."}
                        '-3023': OperationRejected,  # {"code":-3023,"msg":"You can't transfer out/place order under current margin level."}
                        '-3024': OperationRejected,  # {"code":-3024,"msg":"The unpaid debt is too small after self repayment."}
                        '-3025': BadRequest,  # {"code":-3025,"msg":"Your input date is invalid."}
                        '-3026': BadRequest,  # {"code":-3026,"msg":"Your input param is invalid."}
                        '-3027': BadSymbol,  # {"code":-3027,"msg":"Not a valid margin asset."}
                        '-3028': BadSymbol,  # {"code":-3028,"msg":"Not a valid margin pair."}
                        '-3029': OperationFailed,  # {"code":-3029,"msg":"Transfer failed."}
                        '-3036': AccountSuspended,  # {"code":-3036,"msg":"This account is not allowed to repay."}
                        '-3037': OperationFailed,  # {"code":-3037,"msg":"PNL is clearing. Wait a second."}
                        '-3038': BadRequest,  # {"code":-3038,"msg":"Listen key not found."}
                        '-3041': InsufficientFunds,  # {"code":-3041,"msg":"Balance is not enough"}
                        '-3042': BadRequest,  # {"code":-3042,"msg":"PriceIndex not available for self margin pair."}
                        '-3043': PermissionDenied,  # {"code":-3043,"msg":"Transferring in not allowed."}
                        '-3044': OperationFailed,  # {"code":-3044,"msg":"System busy."}
                        '-3045': OperationRejected,  # {"code":-3045,"msg":"The system doesn't have enough asset now."}
                        '-3999': PermissionDenied,  # {"code":-3999,"msg":"This function is only available for invited users."}
                        #
                        #        4xxx(different from contract markets)
                        #
                        '-4000': ExchangeError,  # override commons
                        '-4001': BadRequest,  # {"code":-4001 ,"msg":"Invalid operation."}
                        '-4002': BadRequest,  # {"code":-4002 ,"msg":"Invalid get."}
                        '-4003': BadRequest,  # {"code":-4003 ,"msg":"Your input email is invalid."}
                        '-4004': AuthenticationError,  # {"code":-4004,"msg":"You don't login or auth."}
                        '-4005': RateLimitExceeded,  # {"code":-4005 ,"msg":"Too many new requests."}
                        '-4006': BadRequest,  # {"code":-4006 ,"msg":"Support main account only."}
                        '-4007': PermissionDenied,  # {"code":-4007 ,"msg":"Address validation is not passed."}
                        '-4008': PermissionDenied,  # {"code":-4008 ,"msg":"Address tag validation is not passed."}
                        '-4009': ExchangeError,  # undocumented
                        '-4010': PermissionDenied,  # {"code":-4010 ,"msg":"White list mail has been confirmed."}  # [TODO] possible bug: it should probably be "has not been confirmed"
                        '-4011': BadRequest,  # {"code":-4011 ,"msg":"White list mail is invalid."}
                        '-4012': PermissionDenied,  # {"code":-4012 ,"msg":"White list is not opened."}
                        '-4013': AuthenticationError,  # {"code":-4013 ,"msg":"2FA is not opened."}
                        '-4014': OperationRejected,  # {"code":-4014 ,"msg":"Withdraw is not allowed within 2 min login."}
                        '-4015': PermissionDenied,  # {"code":-4015 ,"msg":"Withdraw is limited."}
                        '-4016': PermissionDenied,  # {"code":-4016 ,"msg":"Within 24 hours after password modification, withdrawal is prohibited."}
                        '-4017': PermissionDenied,  # {"code":-4017 ,"msg":"Within 24 hours after the release of 2FA, withdrawal is prohibited."}
                        '-4018': BadSymbol,  # {"code":-4018,"msg":"We don't have self asset."}
                        '-4019': BadRequest,  # {"code":-4019,"msg":"Current asset is not open for withdrawal."}
                        '-4020': ExchangeError,  # override commons
                        '-4021': BadRequest,  # {"code":-4021,"msg":"Asset withdrawal must be an %s multiple of %s."}
                        '-4022': BadRequest,  # {"code":-4022,"msg":"Not less than the minimum pick-up quantity %s."}
                        '-4023': OperationRejected,  # {"code":-4023,"msg":"Within 24 hours, the withdrawal exceeds the maximum amount."}
                        '-4024': InsufficientFunds,  # {"code":-4024,"msg":"You don't have self asset."}
                        '-4025': InsufficientFunds,  # {"code":-4025,"msg":"The number of hold asset is less than zero."}
                        '-4026': InsufficientFunds,  # {"code":-4026,"msg":"You have insufficient balance."}
                        '-4027': OperationFailed,  # {"code":-4027,"msg":"Failed to obtain tranId."}
                        '-4028': BadRequest,  # {"code":-4028,"msg":"The amount of withdrawal must be greater than the Commission."}
                        '-4029': BadRequest,  # {"code":-4029,"msg":"The withdrawal record does not exist."}
                        '-4030': BadResponse,  # {"code":-4030,"msg":"Confirmation of successful asset withdrawal. [TODO] possible bug in docs"}
                        '-4031': OperationFailed,  # {"code":-4031,"msg":"Cancellation failed."}
                        '-4032': OperationRejected,  # {"code":-4032,"msg":"Withdraw verification exception."}
                        '-4033': BadRequest,  # {"code":-4033,"msg":"Illegal address."}
                        '-4034': OperationRejected,  # {"code":-4034,"msg":"The address is suspected of fake."}
                        '-4035': PermissionDenied,  # {"code":-4035,"msg":"This address is not on the whitelist. Please join and try again."}
                        '-4036': PermissionDenied,  # {"code":-4036,"msg":"The new address needs to be withdrawn in {0} hours."}
                        '-4037': OperationFailed,  # {"code":-4037,"msg":"Re-sending Mail failed."}
                        '-4038': OperationFailed,  # {"code":-4038,"msg":"Please try again in 5 minutes."}
                        '-4039': PermissionDenied,  # {"code":-4039,"msg":"The user does not exist."}
                        '-4040': OperationRejected,  # {"code":-4040,"msg":"This address not charged."}
                        '-4041': OperationFailed,  # {"code":-4041,"msg":"Please try again in one minute."}
                        '-4042': OperationRejected,  # {"code":-4042,"msg":"This asset cannot get deposit address again."}
                        '-4043': OperationRejected,  # {"code":-4043,"msg":"More than 100 recharge addresses were used in 24 hours."}
                        '-4044': PermissionDenied,  # {"code":-4044,"msg":"This is a blacklist country."}
                        '-4045': OperationFailed,  # {"code":-4045,"msg":"Failure to acquire assets."}
                        '-4046': AuthenticationError,  # {"code":-4046,"msg":"Agreement not confirmed."}
                        '-4047': BadRequest,  # {"code":-4047,"msg":"Time interval must be within 0-90 days"}
                        '-4048': ExchangeError,  # override commons
                        '-4049': ExchangeError,  # override commons
                        '-4050': ExchangeError,  # override commons
                        '-4051': ExchangeError,  # override commons
                        '-4052': ExchangeError,  # override commons
                        '-4053': ExchangeError,  # override commons
                        '-4054': ExchangeError,  # override commons
                        '-4055': ExchangeError,  # override commons
                        '-4056': ExchangeError,  # override commons
                        '-4057': ExchangeError,  # override commons
                        '-4058': ExchangeError,  # override commons
                        '-4059': ExchangeError,  # override commons
                        '-4060': OperationFailed,  # As your deposit has not reached the required block confirmations, we have temporarily locked {0} asset
                        '-4061': ExchangeError,  # override commons
                        '-4062': ExchangeError,  # override commons
                        '-4063': ExchangeError,  # override commons
                        '-4064': ExchangeError,  # override commons
                        '-4065': ExchangeError,  # override commons
                        '-4066': ExchangeError,  # override commons
                        '-4067': ExchangeError,  # override commons
                        '-4068': ExchangeError,  # override commons
                        '-4069': ExchangeError,  # override commons
                        '-4070': ExchangeError,  # override commons
                        '-4071': ExchangeError,  # override commons
                        '-4072': ExchangeError,  # override commons
                        '-4073': ExchangeError,  # override commons
                        '-4074': ExchangeError,  # override commons
                        '-4075': ExchangeError,  # override commons
                        '-4076': ExchangeError,  # override commons
                        '-4077': ExchangeError,  # override commons
                        '-4078': ExchangeError,  # override commons
                        '-4079': ExchangeError,  # override commons
                        '-4080': ExchangeError,  # override commons
                        '-4081': ExchangeError,  # override commons
                        '-4082': ExchangeError,  # override commons
                        '-4083': ExchangeError,  # override commons
                        '-4084': ExchangeError,  # override commons
                        '-4085': ExchangeError,  # override commons
                        '-4086': ExchangeError,  # override commons
                        '-4087': ExchangeError,  # override commons
                        '-4088': ExchangeError,  # override commons
                        '-4089': ExchangeError,  # override commons
                        '-4091': ExchangeError,  # override commons
                        '-4092': ExchangeError,  # override commons
                        '-4093': ExchangeError,  # override commons
                        '-4094': ExchangeError,  # override commons
                        '-4095': ExchangeError,  # override commons
                        '-4096': ExchangeError,  # override commons
                        '-4097': ExchangeError,  # override commons
                        '-4098': ExchangeError,  # override commons
                        '-4099': ExchangeError,  # override commons
                        '-4101': ExchangeError,  # override commons
                        '-4102': ExchangeError,  # override commons
                        '-4103': ExchangeError,  # override commons
                        '-4104': ExchangeError,  # override commons
                        '-4105': ExchangeError,  # override commons
                        '-4106': ExchangeError,  # override commons
                        '-4107': ExchangeError,  # override commons
                        '-4108': ExchangeError,  # override commons
                        '-4109': ExchangeError,  # override commons
                        '-4110': ExchangeError,  # override commons
                        '-4112': ExchangeError,  # override commons
                        '-4113': ExchangeError,  # override commons
                        '-4114': ExchangeError,  # override commons
                        '-4115': ExchangeError,  # override commons
                        '-4116': ExchangeError,  # override commons
                        '-4117': ExchangeError,  # override commons
                        '-4118': ExchangeError,  # override commons
                        '-4119': ExchangeError,  # override commons
                        '-4120': ExchangeError,  # override commons
                        '-4121': ExchangeError,  # override commons
                        '-4122': ExchangeError,  # override commons
                        '-4123': ExchangeError,  # override commons
                        '-4124': ExchangeError,  # override commons
                        '-4125': ExchangeError,  # override commons
                        '-4126': ExchangeError,  # override commons
                        '-4127': ExchangeError,  # override commons
                        '-4128': ExchangeError,  # override commons
                        '-4129': ExchangeError,  # override commons
                        '-4130': ExchangeError,  # override commons
                        '-4131': ExchangeError,  # override commons
                        '-4132': ExchangeError,  # override commons
                        '-4133': ExchangeError,  # override commons
                        '-4134': ExchangeError,  # override commons
                        '-4135': ExchangeError,  # override commons
                        '-4136': ExchangeError,  # override commons
                        '-4137': ExchangeError,  # override commons
                        '-4138': ExchangeError,  # override commons
                        '-4139': ExchangeError,  # override commons
                        '-4141': ExchangeError,  # override commons
                        '-4142': ExchangeError,  # override commons
                        '-4143': ExchangeError,  # override commons
                        '-4144': ExchangeError,  # override commons
                        '-4145': ExchangeError,  # override commons
                        '-4146': ExchangeError,  # override commons
                        '-4147': ExchangeError,  # override commons
                        '-4148': ExchangeError,  # override commons
                        '-4149': ExchangeError,  # override commons
                        '-4150': ExchangeError,  # override commons
                        #
                        #        5xxx
                        #
                        '-5001': BadRequest,  # Don't allow transfer to micro assets.
                        '-5002': InsufficientFunds,  # You have insufficient balance.
                        '-5003': InsufficientFunds,  # You don't have self asset.
                        '-5004': OperationRejected,  # The residual balances of %s have exceeded 0.001BTC, Please re-choose.
                        '-5005': OperationRejected,  # The residual balances of %s is too low, Please re-choose.
                        '-5006': OperationRejected,  # Only transfer once in 24 hours.
                        '-5007': BadRequest,  # Quantity must be greater than zero.
                        '-5008': OperationRejected,  # Insufficient amount of returnable assets.
                        '-5009': BadSymbol,  # Product does not exist.
                        '-5010': OperationFailed,  # Asset transfer fail.
                        '-5011': BadRequest,  # future account not exists.
                        '-5012': OperationFailed,  # Asset transfer is in pending.
                        '-5013': InsufficientFunds,  # {"code":-5013,"msg":"Asset transfer failed: insufficient balance""}  # undocumented
                        '-5021': BadRequest,  # This parent sub have no relation
                        '-5022': BadRequest,  # future account or sub relation not exists.
                        #
                        #        6xxx
                        #
                        '-6001': BadSymbol,  # Daily product not exists.
                        '-6003': PermissionDenied,  # Product not exist or you don't have permission
                        '-6004': BadRequest,  # Product not in purchase status
                        '-6005': BadRequest,  # Smaller than min purchase limit
                        '-6006': BadRequest,  # Redeem amount error
                        '-6007': OperationRejected,  # Not in redeem time
                        '-6008': OperationRejected,  # Product not in redeem status
                        '-6009': RateLimitExceeded,  # Request frequency too high
                        '-6011': OperationRejected,  # Exceeding the maximum num allowed to purchase per user
                        '-6012': InsufficientFunds,  # Balance not enough
                        '-6013': BadResponse,  # Purchasing failed
                        '-6014': OperationRejected,  # Exceed up-limit allowed to purchased
                        '-6015': BadRequest,  # Empty request body
                        '-6016': BadRequest,  # Parameter err
                        '-6017': PermissionDenied,  # Not in whitelist
                        '-6018': InsufficientFunds,  # Asset not enough
                        '-6019': OperationRejected,  # Need confirm
                        '-6020': BadRequest,  # Project not exists
                        #
                        #        7xxx
                        #
                        '-7001': BadRequest,  # Date range is not supported.
                        '-7002': BadRequest,  # Data request type is not supported.
                        #
                        #        1xxxx
                        #
                        '-10001': OperationFailed,  # The system is under maintenance, please try again later.
                        '-10002': BadRequest,  # Invalid input parameters.
                        '-10005': BadResponse,  # No records found.
                        '-10007': BadRequest,  # This coin is not loanable
                        '-10008': BadRequest,  # This coin is not loanable
                        '-10009': BadRequest,  # This coin can not be used.
                        '-10010': BadRequest,  # This coin can not be used.
                        '-10011': InsufficientFunds,  # Insufficient spot assets.
                        '-10012': BadRequest,  # Invalid repayment amount.
                        '-10013': InsufficientFunds,  # Insufficient collateral amount.
                        '-10015': OperationFailed,  # Collateral deduction failed.
                        '-10016': OperationFailed,  # Failed to provide loan.
                        '-10017': OperationRejected,  # {"code":-10017,"msg":"Repay amount should not be larger than liability."}
                        '-10018': BadRequest,  # Invalid repayment amount.
                        '-10019': BadRequest,  # Configuration does not exists.
                        '-10020': BadRequest,  # User ID does not exist.
                        '-10021': InvalidOrder,  # Order does not exist.
                        '-10022': BadRequest,  # Invalid adjustment amount.
                        '-10023': OperationFailed,  # Failed to adjust LTV.
                        '-10024': BadRequest,  # LTV adjustment not supported.
                        '-10025': OperationFailed,  # Repayment failed.
                        '-10026': BadRequest,  # Invalid parameter.
                        '-10028': BadRequest,  # Invalid parameter.
                        '-10029': OperationRejected,  # Loan amount is too small.
                        '-10030': OperationRejected,  # Loan amount is too much.
                        '-10031': OperationRejected,  # Individual loan quota reached.
                        '-10032': OperationFailed,  # Repayment is temporarily unavailable.
                        '-10034': OperationRejected,  # Repay with collateral is not available currently, please try to repay with borrowed coin.
                        '-10039': OperationRejected,  # Repayment amount is too small.
                        '-10040': OperationRejected,  # Repayment amount is too large.
                        '-10041': OperationFailed,  # Due to high demand, there are currently insufficient loanable assets for {0}. Please adjust your borrow amount or try again tomorrow.
                        '-10042': BadSymbol,  # asset %s is not supported
                        '-10043': OperationRejected,  # {0} borrowing is currently not supported.
                        '-10044': OperationRejected,  # Collateral amount has reached the limit. Please reduce your collateral amount or try with other collaterals.
                        '-10045': OperationRejected,  # The loan coin does not support collateral repayment. Please try again later.
                        '-10046': OperationRejected,  # Collateral Adjustment exceeds the maximum limit. Please try again.
                        '-10047': PermissionDenied,  # This coin is currently not supported in your location due to local regulations.
                        '-11008': OperationRejected,  # undocumented: Exceeding the accounts maximum borrowable limit
                        '-12014': RateLimitExceeded,  # More than 1 request in 2 seconds
                        # BLVT
                        '-13000': OperationRejected,  # Redeption of the token is forbiden now
                        '-13001': OperationRejected,  # Exceeds individual 24h redemption limit of the token
                        '-13002': OperationRejected,  # Exceeds total 24h redemption limit of the token
                        '-13003': PermissionDenied,  # Subscription of the token is forbiden now
                        '-13004': OperationRejected,  # Exceeds individual 24h subscription limit of the token
                        '-13005': OperationRejected,  # Exceeds total 24h subscription limit of the token
                        '-13006': OperationRejected,  # Subscription amount is too small
                        '-13007': PermissionDenied,  # The Agreement is not signed
                        # 18xxx - BINANCE CODE
                        '-18002': OperationRejected,  # The total amount of codes you created has exceeded the 24-hour limit, please try again after UTC 0
                        '-18003': OperationRejected,  # Too many codes created in 24 hours, please try again after UTC 0
                        '-18004': OperationRejected,  # Too many invalid redeem attempts in 24 hours, please try again after UTC 0
                        '-18005': PermissionDenied,  # Too many invalid verify attempts, please try later
                        '-18006': OperationRejected,  # The amount is too small, please re-enter
                        '-18007': OperationRejected,  # This token is not currently supported, please re-enter
                        #
                        #        2xxxx
                        #
                        #   21xxx - PORTFOLIO MARGIN(documented in spot docs)
                        '-21001': BadRequest,  # Request ID is not a Portfolio Margin Account.
                        '-21002': BadRequest,  # Portfolio Margin Account doesn't support transfer from margin to futures.
                        '-21003': BadResponse,  # Fail to retrieve margin assets.
                        '-21004': OperationRejected,  # User doesnt have portfolio margin bankruptcy loan
                        '-21005': InsufficientFunds,  # Users spot wallet doesnt have enough BUSD to repay portfolio margin bankruptcy loan
                        '-21006': OperationFailed,  # User had portfolio margin bankruptcy loan repayment in process
                        '-21007': OperationFailed,  # User failed to repay portfolio margin bankruptcy loan since liquidation was in process
                        #
                        #        misc
                        #
                        '-32603': BadRequest,  # undocumented, Filter failure: LOT_SIZE & precision
                        '100001003': AuthenticationError,  # undocumented, {"code":100001003,"msg":"Verification failed"}
                        '200003903': AuthenticationError,  # undocumented, {"code":200003903,"msg":"Your identity verification has been rejected. Please complete identity verification again."}
                        '400002': BadRequest,  # undocumented, {status: FAIL, code: 400002, errorMessage: Signature for self request is not valid.}
                    },
                },
            },
            'fees': {
                'inverse': {
                    'trading': {
                        'feeSide': 'base',
                        'maker': self.parse_number('0.000100'),
                        'percentage': True,
                        'taker': self.parse_number('0.000500'),
                        'tierBased': True,
                        'tiers': {
                            'maker': [
                                [self.parse_number('0'), self.parse_number('0.000100')],
                                [self.parse_number('250'), self.parse_number('0.000080')],
                                [self.parse_number('2500'), self.parse_number('0.000050')],
                                [self.parse_number('7500'), self.parse_number('0.0000030')],
                                [self.parse_number('22500'), self.parse_number('0')],
                                [self.parse_number('50000'), self.parse_number('-0.000050')],
                                [self.parse_number('100000'), self.parse_number('-0.000060')],
                                [self.parse_number('200000'), self.parse_number('-0.000070')],
                                [self.parse_number('400000'), self.parse_number('-0.000080')],
                                [self.parse_number('750000'), self.parse_number('-0.000090')],
                            ],
                            'taker': [
                                [self.parse_number('0'), self.parse_number('0.000500')],
                                [self.parse_number('250'), self.parse_number('0.000450')],
                                [self.parse_number('2500'), self.parse_number('0.000400')],
                                [self.parse_number('7500'), self.parse_number('0.000300')],
                                [self.parse_number('22500'), self.parse_number('0.000250')],
                                [self.parse_number('50000'), self.parse_number('0.000240')],
                                [self.parse_number('100000'), self.parse_number('0.000240')],
                                [self.parse_number('200000'), self.parse_number('0.000240')],
                                [self.parse_number('400000'), self.parse_number('0.000240')],
                                [self.parse_number('750000'), self.parse_number('0.000240')],
                            ],
                        },
                    },
                },
                'linear': {
                    'trading': {
                        'feeSide': 'quote',
                        'maker': self.parse_number('0.000200'),
                        'percentage': True,
                        'taker': self.parse_number('0.000500'),
                        'tierBased': True,
                        'tiers': {
                            'maker': [
                                [self.parse_number('0'), self.parse_number('0.000200')],
                                [self.parse_number('250'), self.parse_number('0.000160')],
                                [self.parse_number('2500'), self.parse_number('0.000140')],
                                [self.parse_number('7500'), self.parse_number('0.000120')],
                                [self.parse_number('22500'), self.parse_number('0.000100')],
                                [self.parse_number('50000'), self.parse_number('0.000080')],
                                [self.parse_number('100000'), self.parse_number('0.000060')],
                                [self.parse_number('200000'), self.parse_number('0.000040')],
                                [self.parse_number('400000'), self.parse_number('0.000020')],
                                [self.parse_number('750000'), self.parse_number('0')],
                            ],
                            'taker': [
                                [self.parse_number('0'), self.parse_number('0.000400')],
                                [self.parse_number('250'), self.parse_number('0.000400')],
                                [self.parse_number('2500'), self.parse_number('0.000350')],
                                [self.parse_number('7500'), self.parse_number('0.000320')],
                                [self.parse_number('22500'), self.parse_number('0.000300')],
                                [self.parse_number('50000'), self.parse_number('0.000270')],
                                [self.parse_number('100000'), self.parse_number('0.000250')],
                                [self.parse_number('200000'), self.parse_number('0.000220')],
                                [self.parse_number('400000'), self.parse_number('0.000200')],
                                [self.parse_number('750000'), self.parse_number('0.000170')],
                            ],
                        },
                    },
                },
                'option': {},
                'trading': {
                    'feeSide': 'get',
                    'maker': self.parse_number('0.001'),
                    'percentage': True,
                    'taker': self.parse_number('0.001'),
                    'tierBased': False,
                },
            },
            # new metainfo2 interface
            'has': {
                'CORS': None,
                'spot': True,
                'margin': True,
                'swap': True,
                'future': True,
                'option': True,
                'addMargin': True,
                'borrowCrossMargin': True,
                'borrowIsolatedMargin': True,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelOrders': True,  # contract only
                'closeAllPositions': False,
                'closePosition': False,  # exchange specific closePosition parameter for binance createOrder is not synonymous with how CCXT uses closePositions
                'createConvertTrade': True,
                'createDepositAddress': False,
                'createLimitBuyOrder': True,
                'createLimitSellOrder': True,
                'createMarketBuyOrder': True,
                'createMarketBuyOrderWithCost': True,
                'createMarketOrderWithCost': True,
                'createMarketSellOrder': True,
                'createMarketSellOrderWithCost': True,
                'createOrder': True,
                'createOrders': True,
                'createOrderWithTakeProfitAndStopLoss': False,
                'createPostOnlyOrder': True,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': True,
                'createStopLossOrder': True,
                'createStopMarketOrder': False,
                'createStopOrder': True,
                'createTakeProfitOrder': True,
                'createTrailingPercentOrder': True,
                'createTriggerOrder': True,
                'editOrder': True,
                'fetchAccounts': None,
                'fetchBalance': True,
                'fetchBidsAsks': True,
                'fetchBorrowInterest': True,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': True,
                'fetchCanceledAndClosedOrders': 'emulated',
                'fetchCanceledOrders': 'emulated',
                'fetchClosedOrder': False,
                'fetchClosedOrders': 'emulated',
                'fetchConvertCurrencies': True,
                'fetchConvertQuote': True,
                'fetchConvertTrade': True,
                'fetchConvertTradeHistory': True,
                'fetchCrossBorrowRate': True,
                'fetchCrossBorrowRates': False,
                'fetchCurrencies': True,
                'fetchDeposit': False,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': True,
                'fetchDepositsWithdrawals': False,
                'fetchDepositWithdrawFee': 'emulated',
                'fetchDepositWithdrawFees': True,
                'fetchFundingHistory': True,
                'fetchFundingInterval': 'emulated',
                'fetchFundingIntervals': True,
                'fetchFundingRate': True,
                'fetchFundingRateHistory': True,
                'fetchFundingRates': True,
                'fetchGreeks': True,
                'fetchIndexOHLCV': True,
                'fetchIsolatedBorrowRate': 'emulated',
                'fetchIsolatedBorrowRates': True,
                'fetchL3OrderBook': False,
                'fetchLastPrices': True,
                'fetchLedger': True,
                'fetchLedgerEntry': True,
                'fetchLeverage': 'emulated',
                'fetchLeverages': True,
                'fetchLeverageTiers': True,
                'fetchLiquidations': False,
                'fetchLongShortRatio': False,
                'fetchLongShortRatioHistory': True,
                'fetchMarginAdjustmentHistory': True,
                'fetchMarginMode': True,
                'fetchMarginModes': True,
                'fetchMarketLeverageTiers': 'emulated',
                'fetchMarkets': True,
                'fetchMarkOHLCV': True,
                'fetchMarkPrice': True,
                'fetchMarkPrices': True,
                'fetchMyLiquidations': True,
                'fetchMySettlementHistory': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterest': True,
                'fetchOpenInterestHistory': True,
                'fetchOpenOrder': True,
                'fetchOpenOrders': True,
                'fetchOption': True,
                'fetchOptionChain': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': True,
                'fetchPositionHistory': False,
                'fetchPositionMode': True,
                'fetchPositions': True,
                'fetchPositionsHistory': False,
                'fetchPositionsRisk': True,
                'fetchPremiumIndexOHLCV': True,
                'fetchSettlementHistory': True,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': True,
                'fetchTradingFees': True,
                'fetchTradingLimits': None,
                'fetchTransactionFee': 'emulated',
                'fetchTransactionFees': True,
                'fetchTransactions': False,
                'fetchTransfer': False,
                'fetchTransfers': True,
                'fetchUnderlyingAssets': False,
                'fetchVolatilityHistory': False,
                'fetchWithdrawAddresses': False,
                'fetchWithdrawal': False,
                'fetchWithdrawals': True,
                'fetchWithdrawalWhitelist': False,
                'reduceMargin': True,
                'repayCrossMargin': True,
                'repayIsolatedMargin': True,
                'sandbox': True,
                'setLeverage': True,
                'setMargin': False,
                'setMarginMode': True,
                'setPositionMode': True,
                'signIn': False,
                'transfer': True,
                'withdraw': True,
            },
            'id': 'binance',
            'name': 'Binance',
            # exchange-specific options
            'options': {
                'accountsById': {
                    'CMFUTURE': 'inverse',
                    'FUNDING': 'funding',
                    'MAIN': 'spot',
                    'MARGIN': 'margin',
                    'OPTION': 'option',
                    'UMFUTURE': 'linear',
                },
                'accountsByType': {
                    'cross': 'MARGIN',
                    'delivery': 'CMFUTURE',  # backwards compatbility
                    'funding': 'FUNDING',
                    'future': 'UMFUTURE',  # backwards compatibility
                    'inverse': 'CMFUTURE',
                    'linear': 'UMFUTURE',
                    'main': 'MAIN',
                    'margin': 'MARGIN',
                    'option': 'OPTION',
                    'spot': 'MAIN',
                    'swap': 'UMFUTURE',
                },
                'adjustForTimeDifference': False,  # controls the adjustment logic upon instantiation
                'broker': {
                    'delivery': 'x-xcKtGhcu',
                    'future': 'x-xcKtGhcu',
                    'margin': 'x-R4BD3S82',
                    'option': 'x-xcKtGhcu',
                    'spot': 'x-R4BD3S82',
                    'swap': 'x-xcKtGhcu',
                },
                'defaultSubType': None,  # 'linear', 'inverse'
                'defaultTimeInForce': 'GTC',  # 'GTC' = Good To Cancel(default), 'IOC' = Immediate Or Cancel
                'defaultType': 'spot',  # 'spot', 'future', 'margin', 'delivery', 'option'
                'fetchCurrencies': True,  # self is a private call and it requires API keys
                'fetchMargins': True,
                'fetchMarkets': [
                    'inverse',  # allows CORS in browsers
                    'linear',  # allows CORS in browsers
                    'spot',  # allows CORS in browsers
                    # 'option',  # does not allow CORS, enable outside of the browser only
                ],
                'fetchOHLCV': {
                    'defaultLimit': 500,
                    'maxLimit': 1500,
                },
                'fetchPositions': 'positionRisk',  # or 'account' or 'option'
                # 'fetchTradesMethod': 'publicGetAggTrades',  # publicGetTrades, publicGetHistoricalTrades, eapiPublicGetTrades
                # not an error
                # https://github.com/ccxt/ccxt/issues/11268
                # https://github.com/ccxt/ccxt/pull/11624
                # POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
                # binanceusdm
                'hasAlreadyAuthenticatedSuccessfully': False,
                'impliedNetworks': {
                    'ETH': {'ERC20': 'ETH'},
                    'TRX': {'TRC20': 'TRX'},
                },
                'legalMoney': {
                    'AED': True,
                    'ARS': True,
                    'AUD': True,
                    'BRL': True,
                    'CAD': True,
                    'CHF': True,
                    'CZK': True,
                    'DKK': True,
                    'EUR': True,
                    'GBP': True,
                    'GHS': True,
                    'HKD': True,
                    'HUF': True,
                    'INR': True,
                    'JPY': True,
                    'KES': True,
                    'KZT': True,
                    'MXN': True,
                    'NGN': True,
                    'NOK': True,
                    'NZD': True,
                    'PEN': True,
                    'PHP': True,
                    'PLN': True,
                    'RUB': True,
                    'SEK': True,
                    'TRY': True,
                    'UAH': True,
                    'UGX': True,
                    'USD': True,
                    'VND': True,
                    'ZAR': True,
                },
                'legalMoneyCurrenciesById': {
                    'BUSD': 'USD',
                },
                'networks': {
                    'BEP2': 'BNB',
                    'BEP20': 'BSC',
                    'EOS': 'EOS',
                    'ERC20': 'ETH',
                    'OMNI': 'OMNI',
                    'SPL': 'SOL',
                    'TRC20': 'TRX',
                },
                'networksById': {
                    'algoexplorer.io': 'ALGO',
                    'atomscan.com': 'ATOM',
                    'bithomp.com': 'XRP',
                    'block.gxb.io': 'GXS',
                    'blockchair.com/bitcoin': 'BTC',
                    'blockchair.com/bitcoin-cash': 'BCH',
                    'blockchair.com/ecash': 'XEC',
                    'blockscout.com': 'ETC',
                    'bloks.io': 'EOS',
                    'bscscan.com': 'BSC',
                    'btgexplorer.com': 'BTG',
                    'bts.ai': 'BTS',
                    'cardanoscan.io': 'ADA',
                    'cerebro.cortexlabs.ai': 'CTXC',
                    'chain.nem.ninja': 'XEM',
                    'chainz.cryptoid.info': 'VIA',
                    'dashboard.internetcomputer.org': 'ICP',
                    'digiexplorer.info': 'DGB',
                    'dock.subscan.io': 'DOCK',
                    'dogechain.info': 'DOGE',
                    'etherscan.io': 'ERC20',
                    'explore-fetchhub.fetch.ai': 'FET',
                    'explore.vechain.org': 'VET',
                    'explorer.ambrosus.com': 'AMB',
                    'explorer.ark.io': 'ARK',
                    'explorer.avax.network': 'AVAX',
                    'explorer.binance.org': 'BEP2',
                    'explorer.bitcoindiamond.org': 'BCD',
                    'explorer.celo.org': 'CELO',
                    'explorer.chiliz.com': 'CHZ',
                    'explorer.dcrdata.org': 'DCR',
                    'explorer.elrond.com': 'EGLD',
                    'explorer.firo.org': 'FIRO',
                    'explorer.gochain.io': 'GO',
                    'explorer.harmony.one': 'ONE',
                    'explorer.helium.com': 'HNT',
                    'explorer.iota.org': 'IOTA',
                    'explorer.litecoin.net': 'LTC',
                    'explorer.lto.network': 'LTO',
                    'explorer.nbs.plus': 'NBS',
                    'explorer.nebl.io': 'NEBL',
                    'explorer.nebulas.io': 'NAS',
                    'explorer.nervos.org': 'CKB',
                    'explorer.ont.io': 'ONT',
                    'explorer.poa.network': 'POA',
                    'explorer.rsk.co': 'RSK',
                    'explorer.skycoin.com': 'SKY',
                    'explorer.stacks.co': 'STX',
                    'explorer.vite.net': 'VITE',
                    'explorer.yoyow.org': 'YOYOW',
                    'explorer.zcha.in': 'ZEC',
                    'explorer.zensystem.io': 'ZEN',
                    'filfox.info': 'FIL',
                    'fio.bloks.io': 'FIO',
                    'ftmscan.com': 'FTM',
                    'hash-hash.info': 'HBAR',
                    'iotexscan.io': 'IOTX',
                    'irishub.iobscan.io': 'IRIS',
                    'kava.mintscan.io': 'KAVA',
                    'kmdexplorer.io': 'KMD',
                    'kusama.subscan.io': 'KSM',
                    'mainnet.theoan.com': 'AION',
                    'minaexplorer.com': 'MINA',
                    'nanolooker.com': 'NANO',
                    'neoscan.io': 'NEO',
                    'nulscan.io': 'NULS',
                    'nxscan.com': 'NXS',
                    'polkadot.subscan.io': 'DOT',
                    'polygonscan.com': 'POLYGON',
                    'qtum.info': 'QTUM',
                    'ravencoin.network': 'RVN',
                    'sc.tokenview.com': 'SC',
                    'scan.tomochain.com': 'TOMO',
                    'scope.klaytn.com': 'KLAY',
                    'secretnodes.com': 'SCRT',
                    'solscan.io': 'SOL',
                    'steemscan.com': 'STEEM',
                    'stellar.expert': 'XLM',
                    'tracker.icon.foundation': 'ICX',
                    'tronscan.org': 'TRC20',
                    'verge-blockchain.info': 'XVG',
                    'viewblock.io/arweave': 'AR',
                    'viewblock.io/zilliqa': 'ZIL',
                    'waltonchain.pro': 'WTC',
                    'wavesexplorer.com': 'WAVES',
                    'wax.eosx.io': 'WAXP',
                    'www.hiveblockexplorer.com': 'HIVE',
                    'www.iostabc.com': 'IOST',
                    'www.mintscan.io': 'CTK',
                    'www.oasisscan.com': 'ROSE',
                    'www.thetascan.io': 'THETA',
                    'www.wanscan.org': 'WAN',
                },
                'newOrderRespType': {
                    'market': 'FULL',  # 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
                    'limit': 'FULL',  # we change it from 'ACK' by default to 'FULL'(returns immediately if limit is not hit)
                },
                'quoteOrderQty': True,  # whether market orders support amounts in quote currency
                'recvWindow': 10 * 1000,  # 10 sec
                # 'repayCrossMarginMethod': 'papiPostRepayLoan',  # papiPostMarginRepayDebt
                # keeping self object for backward-compatibility
                'reverseNetworks': {
                    'algoexplorer.io': 'ALGO',
                    'atomscan.com': 'ATOM',
                    'bithomp.com': 'XRP',
                    'block.gxb.io': 'GXS',
                    'blockchair.com/bitcoin': 'BTC',
                    'blockchair.com/bitcoin-cash': 'BCH',
                    'blockchair.com/ecash': 'XEC',
                    'blockscout.com': 'ETC',
                    'bloks.io': 'EOS',
                    'bscscan.com': 'BSC',
                    'btgexplorer.com': 'BTG',
                    'bts.ai': 'BTS',
                    'cardanoscan.io': 'ADA',
                    'cerebro.cortexlabs.ai': 'CTXC',
                    'chain.nem.ninja': 'XEM',
                    'chainz.cryptoid.info': 'VIA',
                    'dashboard.internetcomputer.org': 'ICP',
                    'digiexplorer.info': 'DGB',
                    'dock.subscan.io': 'DOCK',
                    'dogechain.info': 'DOGE',
                    'etherscan.io': 'ERC20',
                    'explore-fetchhub.fetch.ai': 'FET',
                    'explore.vechain.org': 'VET',
                    'explorer.ambrosus.com': 'AMB',
                    'explorer.ark.io': 'ARK',
                    'explorer.avax.network': 'AVAX',
                    'explorer.binance.org': 'BEP2',
                    'explorer.bitcoindiamond.org': 'BCD',
                    'explorer.celo.org': 'CELO',
                    'explorer.chiliz.com': 'CHZ',
                    'explorer.dcrdata.org': 'DCR',
                    'explorer.elrond.com': 'EGLD',
                    'explorer.firo.org': 'FIRO',
                    'explorer.gochain.io': 'GO',
                    'explorer.harmony.one': 'ONE',
                    'explorer.helium.com': 'HNT',
                    'explorer.iota.org': 'IOTA',
                    'explorer.litecoin.net': 'LTC',
                    'explorer.lto.network': 'LTO',
                    'explorer.nbs.plus': 'NBS',
                    'explorer.nebl.io': 'NEBL',
                    'explorer.nebulas.io': 'NAS',
                    'explorer.nervos.org': 'CKB',
                    'explorer.ont.io': 'ONT',
                    'explorer.poa.network': 'POA',
                    'explorer.rsk.co': 'RSK',
                    'explorer.skycoin.com': 'SKY',
                    'explorer.stacks.co': 'STX',
                    'explorer.vite.net': 'VITE',
                    'explorer.yoyow.org': 'YOYOW',
                    'explorer.zcha.in': 'ZEC',
                    'explorer.zensystem.io': 'ZEN',
                    'filfox.info': 'FIL',
                    'fio.bloks.io': 'FIO',
                    'ftmscan.com': 'FTM',
                    'hash-hash.info': 'HBAR',
                    'iotexscan.io': 'IOTX',
                    'irishub.iobscan.io': 'IRIS',
                    'kava.mintscan.io': 'KAVA',
                    'kmdexplorer.io': 'KMD',
                    'kusama.subscan.io': 'KSM',
                    'mainnet.theoan.com': 'AION',
                    'minaexplorer.com': 'MINA',
                    'nanolooker.com': 'NANO',
                    'neoscan.io': 'NEO',
                    'nulscan.io': 'NULS',
                    'nxscan.com': 'NXS',
                    'polkadot.subscan.io': 'DOT',
                    'polygonscan.com': 'POLYGON',
                    'qtum.info': 'QTUM',
                    'ravencoin.network': 'RVN',
                    'sc.tokenview.com': 'SC',
                    'scan.tomochain.com': 'TOMO',
                    'scope.klaytn.com': 'KLAY',
                    'secretnodes.com': 'SCRT',
                    'solscan.io': 'SOL',
                    'steemscan.com': 'STEEM',
                    'stellar.expert': 'XLM',
                    'tracker.icon.foundation': 'ICX',
                    'tronscan.org': 'TRC20',
                    'verge-blockchain.info': 'XVG',
                    'viewblock.io/arweave': 'AR',
                    'viewblock.io/zilliqa': 'ZIL',
                    'waltonchain.pro': 'WTC',
                    'wavesexplorer.com': 'WAVES',
                    'wax.eosx.io': 'WAXP',
                    'www.hiveblockexplorer.com': 'HIVE',
                    'www.iostabc.com': 'IOST',
                    'www.mintscan.io': 'CTK',
                    'www.oasisscan.com': 'ROSE',
                    'www.thetascan.io': 'THETA',
                    'www.wanscan.org': 'WAN',
                },
                'sandboxMode': False,
                'throwMarginModeAlreadySet': False,
                'timeDifference': 0,  # the difference between system clock and Binance clock
                'warnOnFetchOpenOrdersWithoutSymbol': True,
            },
            'precisionMode': TICK_SIZE,
            'pro': True,
            'rateLimit': 50,
            'timeframes': {
                '1s': '1s',  # spot only for now
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'api': {
                    'dapiData': 'https://dapi.binance.com/futures/data',
                    'dapiPrivate': 'https://dapi.binance.com/dapi/v1',
                    'dapiPrivateV2': 'https://dapi.binance.com/dapi/v2',
                    'dapiPublic': 'https://dapi.binance.com/dapi/v1',
                    'eapiPrivate': 'https://eapi.binance.com/eapi/v1',
                    'eapiPublic': 'https://eapi.binance.com/eapi/v1',
                    'fapiData': 'https://fapi.binance.com/futures/data',
                    'fapiPrivate': 'https://fapi.binance.com/fapi/v1',
                    'fapiPrivateV2': 'https://fapi.binance.com/fapi/v2',
                    'fapiPrivateV3': 'https://fapi.binance.com/fapi/v3',
                    'fapiPublic': 'https://fapi.binance.com/fapi/v1',
                    'fapiPublicV2': 'https://fapi.binance.com/fapi/v2',
                    'fapiPublicV3': 'https://fapi.binance.com/fapi/v3',
                    'papi': 'https://papi.binance.com/papi/v1',
                    'papiV2': 'https://papi.binance.com/papi/v2',
                    'private': 'https://api.binance.com/api/v3',
                    'public': 'https://api.binance.com/api/v3',
                    'sapi': 'https://api.binance.com/sapi/v1',
                    'sapiV2': 'https://api.binance.com/sapi/v2',
                    'sapiV3': 'https://api.binance.com/sapi/v3',
                    'sapiV4': 'https://api.binance.com/sapi/v4',
                    'v1': 'https://api.binance.com/api/v1',
                },
                'api_management': 'https://www.binance.com/en/usercenter/settings/api-management',
                'doc': [
                    'https://developers.binance.com/en',
                ],
                'fees': 'https://www.binance.com/en/fee/schedule',
                'logo': 'https://github.com/user-attachments/assets/e9419b93-ccb0-46aa-9bff-c883f096274b',
                'referral': {
                    'discount': 0.1,
                    'url': 'https://accounts.binance.com/en/register?ref=D7YA7CLY',
                },
                'test': {
                    'dapiPrivate': 'https://testnet.binancefuture.com/dapi/v1',
                    'dapiPrivateV2': 'https://testnet.binancefuture.com/dapi/v2',
                    'dapiPublic': 'https://testnet.binancefuture.com/dapi/v1',
                    'fapiPrivate': 'https://testnet.binancefuture.com/fapi/v1',
                    'fapiPrivateV2': 'https://testnet.binancefuture.com/fapi/v2',
                    'fapiPrivateV3': 'https://testnet.binancefuture.com/fapi/v3',
                    'fapiPublic': 'https://testnet.binancefuture.com/fapi/v1',
                    'fapiPublicV2': 'https://testnet.binancefuture.com/fapi/v2',
                    'fapiPublicV3': 'https://testnet.binancefuture.com/fapi/v3',
                    'private': 'https://testnet.binance.vision/api/v3',
                    'public': 'https://testnet.binance.vision/api/v3',
                    'v1': 'https://testnet.binance.vision/api/v1',
                },
                'www': 'https://www.binance.com',
            },
        })

    def is_inverse(self, type: str, subType: Str = None) -> bool:
        if subType is None:
            return(type == 'delivery')
        else:
            return subType == 'inverse'

    def is_linear(self, type: str, subType: Str = None) -> bool:
        if subType is None:
            return(type == 'future') or (type == 'swap')
        else:
            return subType == 'linear'

    def set_sandbox_mode(self, enable: bool):
        super(binance, self).set_sandbox_mode(enable)
        self.options['sandboxMode'] = enable

    def create_expired_option_market(self, symbol: str):
        # support expired option contracts
        settle = 'USDT'
        optionParts = symbol.split('-')
        symbolBase = symbol.split('/')
        base = None
        if symbol.find('/') > -1:
            base = self.safe_string(symbolBase, 0)
        else:
            base = self.safe_string(optionParts, 0)
        expiry = self.safe_string(optionParts, 1)
        strike = self.safe_integer(optionParts, 2)
        strikeAsString = self.safe_string(optionParts, 2)
        optionType = self.safe_string(optionParts, 3)
        datetime = self.convert_expire_date(expiry)
        timestamp = self.parse8601(datetime)
        return {
            'active': None,
            'base': base,
            'baseId': base,
            'contract': True,
            'contractSize': None,
            'expiry': timestamp,
            'expiryDatetime': datetime,
            'future': False,
            'id': base + '-' + expiry + '-' + strikeAsString + '-' + optionType,
            'info': None,
            'inverse': None,
            'limits': {
                'amount': {
                    'max': None,
                    'min': None,
                },
                'cost': {
                    'max': None,
                    'min': None,
                },
                'price': {
                    'max': None,
                    'min': None,
                },
            },
            'linear': None,
            'margin': False,
            'option': True,
            'optionType': 'call' if (optionType == 'C') else 'put',
            'precision': {
                'amount': None,
                'price': None,
            },
            'quote': settle,
            'quoteId': settle,
            'settle': settle,
            'settleId': settle,
            'spot': False,
            'strike': strike,
            'swap': False,
            'symbol': base + '/' + settle + ':' + settle + '-' + expiry + '-' + strikeAsString + '-' + optionType,
            'type': 'option',
        }

    def market(self, symbol: str) -> MarketInterface:
        if self.markets is None:
            raise ExchangeError(self.id + ' markets not loaded')
        # defaultType has legacy support on binance
        defaultType = self.safe_string(self.options, 'defaultType')
        defaultSubType = self.safe_string(self.options, 'defaultSubType')
        isLegacyLinear = defaultType == 'future'
        isLegacyInverse = defaultType == 'delivery'
        isLegacy = isLegacyLinear or isLegacyInverse
        if isinstance(symbol, str):
            if symbol in self.markets:
                market = self.markets[symbol]
                # begin diff
                if isLegacy and market['spot']:
                    settle = market['quote'] if isLegacyLinear else market['base']
                    futuresSymbol = symbol + ':' + settle
                    if futuresSymbol in self.markets:
                        return self.markets[futuresSymbol]
                else:
                    return market
                # end diff
            elif symbol in self.markets_by_id:
                markets = self.markets_by_id[symbol]
                # begin diff
                if isLegacyLinear:
                    defaultType = 'linear'
                elif isLegacyInverse:
                    defaultType = 'inverse'
                elif defaultType is None:
                    defaultType = defaultSubType
                # end diff
                for i in range(0, len(markets)):
                    market = markets[i]
                    if market[defaultType]:
                        return market
                return markets[0]
            elif (symbol.find('/') > -1) and (symbol.find(':') < 0):
                # support legacy symbols
                base, quote = symbol.split('/')
                settle = base if (quote == 'USD') else quote
                futuresSymbol = symbol + ':' + settle
                if futuresSymbol in self.markets:
                    return self.markets[futuresSymbol]
            elif (symbol.find('-C') > -1) or (symbol.find('-P') > -1):  # both exchange-id and unified symbols are supported self way regardless of the defaultType
                return self.create_expired_option_market(symbol)
        raise BadSymbol(self.id + ' does not have market symbol ' + symbol)

    def safe_market(self, marketId: Str = None, market: Market = None, delimiter: Str = None, marketType: Str = None) -> MarketInterface:
        isOption = (marketId is not None) and ((marketId.find('-C') > -1) or (marketId.find('-P') > -1))
        if isOption and not (marketId in self.markets_by_id):
            # handle expired option contracts
            return self.create_expired_option_market(marketId)
        return super(binance, self).safe_market(marketId, market, delimiter, marketType)

    def cost_to_precision(self, symbol, cost):
        return self.decimal_to_precision(cost, TRUNCATE, self.markets[symbol]['precision']['quote'], self.precisionMode, self.paddingMode)

    def currency_to_precision(self, code, fee, networkCode=None):
        # info is available in currencies only if the user has configured his api keys
        if self.safe_value(self.currencies[code], 'precision') is not None:
            return self.decimal_to_precision(fee, TRUNCATE, self.currencies[code]['precision'], self.precisionMode, self.paddingMode)
        else:
            return self.number_to_string(fee)

    def nonce(self):
        return self.milliseconds() - self.options['timeDifference']

    def fetch_time(self, params={}):
        """
        fetches the current integer timestamp in milliseconds from the exchange server

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#check-server-time                            # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time    # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Check-Server-time             # future

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns int: the current integer timestamp in milliseconds from the exchange server
        """
        defaultType = self.safe_string_2(self.options, 'fetchTime', 'defaultType', 'spot')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchTime', None, params)
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetTime(query)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetTime(query)
        else:
            response = self.publicGetTime(query)
        return self.safe_integer(response, 'serverTime')

    def fetch_currencies(self, params={}) -> Currencies:
        """
        fetches all available currencies on an exchange

        https://developers.binance.com/docs/wallet/capital/all-coins-info
        https://developers.binance.com/docs/margin_trading/market-data/Get-All-Margin-Assets

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an associative dictionary of currencies
        """
        fetchCurrenciesEnabled = self.safe_bool(self.options, 'fetchCurrencies')
        if not fetchCurrenciesEnabled:
            return None
        # self endpoint requires authentication
        # while fetchCurrencies is a public API method by design
        # therefore we check the keys here
        # and fallback to generating the currencies from the markets
        if not self.check_required_credentials(False):
            return None
        # sandbox/testnet does not support sapi endpoints
        apiBackup = self.safe_value(self.urls, 'apiBackup')
        if apiBackup is not None:
            return None
        promises = [self.sapiGetCapitalConfigGetall(params)]
        fetchMargins = self.safe_bool(self.options, 'fetchMargins', False)
        if fetchMargins:
            promises.append(self.sapiGetMarginAllPairs(params))
        results = promises
        responseCurrencies = results[0]
        marginablesById = None
        if fetchMargins:
            responseMarginables = results[1]
            marginablesById = self.index_by(responseMarginables, 'assetName')
        result: dict = {}
        for i in range(0, len(responseCurrencies)):
            #
            #    {
            #        "coin": "LINK",
            #        "depositAllEnable": True,
            #        "free": "0",
            #        "freeze": "0",
            #        "ipoable": "0",
            #        "ipoing": "0",
            #        "isLegalMoney": False,
            #        "locked": "0",
            #        "name": "ChainLink",
            #        "networkList": [
            #            {
            #                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            #                "addressRule": "",
            #                "busy": False,
            #                "coin": "LINK",
            #                "country": "AE,BINANCE_BAHRAIN_BSC",
            #                "depositDesc": "",
            #                "depositEnable": True,
            #                "estimatedArrivalTime": "5",
            #                "isDefault": False,
            #                "memoRegex": "",
            #                "minConfirm": "15",
            #                "name": "BNB Smart Chain(BEP20)",
            #                "network": "BSC",
            #                "resetAddressStatus": False,
            #                "sameAddress": False,
            #                "specialTips": "",
            #                "specialWithdrawTips": "The network you have selected is BSC. Please ensure that the withdrawal address supports the Binance Smart Chain network. You will lose your assets if the chosen platform does not support retrievals.",
            #                "unLockConfirm": "0",
            #                "withdrawDesc": "",
            #                "withdrawEnable": True,
            #                "withdrawFee": "0.012",
            #                "withdrawIntegerMultiple": "0.00000001",
            #                "withdrawMax": "9999999999.99999999",
            #                "withdrawMin": "0.024",
            #            },
            #            {
            #                "addressRegex": "^(bnb1)[0-9a-z]{38}$",
            #                "addressRule": "",
            #                "busy": False,
            #                "coin": "LINK",
            #                "country": "AE,BINANCE_BAHRAIN_BSC",
            #                "depositDesc": "",
            #                "depositEnable": True,
            #                "estimatedArrivalTime": "5",
            #                "isDefault": False,
            #                "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
            #                "minConfirm": "1",
            #                "name": "BNB Beacon Chain(BEP2)",
            #                "network": "BNB",
            #                "resetAddressStatus": False,
            #                "sameAddress": True,
            #                "specialTips": "Both a MEMO and an Address are required to successfully deposit your LINK BEP2 tokens to Binance.",
            #                "specialWithdrawTips": "",
            #                "unLockConfirm": "0",
            #                "withdrawDesc": "",
            #                "withdrawEnable": True,
            #                "withdrawFee": "0.002",
            #                "withdrawIntegerMultiple": "0.00000001",
            #                "withdrawMax": "10000000000",
            #                "withdrawMin": "0.01",
            #            },
            #            {
            #                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            #                "addressRule": "",
            #                "busy": False,
            #                "coin": "LINK",
            #                "country": "AE,BINANCE_BAHRAIN_BSC",
            #                "depositDesc": "",
            #                "depositEnable": True,
            #                "estimatedArrivalTime": "5",
            #                "isDefault": True,
            #                "memoRegex": "",
            #                "minConfirm": "12",
            #                "name": "Ethereum(ERC20)",
            #                "network": "ETH",
            #                "resetAddressStatus": False,
            #                "sameAddress": False,
            #                "unLockConfirm": "0",
            #                "withdrawDesc": "",
            #                "withdrawEnable": True,
            #                "withdrawFee": "0.55",
            #                "withdrawIntegerMultiple": "0.00000001",
            #                "withdrawMax": "10000000000",
            #                "withdrawMin": "1.1",
            #            }
            #        ],
            #        "storage": "0",
            #        "trading": True,
            #        "withdrawAllEnable": True,
            #        "withdrawing": "0",
            #    }
            #
            entry = responseCurrencies[i]
            id = self.safe_string(entry, 'coin')
            name = self.safe_string(entry, 'name')
            code = self.safe_currency_code(id)
            minPrecision = None
            isWithdrawEnabled = True
            isDepositEnabled = True
            networkList = self.safe_list(entry, 'networkList', [])
            fees: dict = {}
            fee = None
            networks: dict = {}
            for j in range(0, len(networkList)):
                networkItem = networkList[j]
                network = self.safe_string(networkItem, 'network')
                networkCode = self.network_id_to_code(network)
                # name = self.safe_string(networkItem, 'name')
                withdrawFee = self.safe_number(networkItem, 'withdrawFee')
                depositEnable = self.safe_bool(networkItem, 'depositEnable')
                withdrawEnable = self.safe_bool(networkItem, 'withdrawEnable')
                isDepositEnabled = isDepositEnabled or depositEnable
                isWithdrawEnabled = isWithdrawEnabled or withdrawEnable
                fees[network] = withdrawFee
                isDefault = self.safe_bool(networkItem, 'isDefault')
                if isDefault or (fee is None):
                    fee = withdrawFee
                precisionTick = self.safe_string(networkItem, 'withdrawIntegerMultiple')
                # avoid zero values, which are mostly from fiat or leveraged tokens : https://github.com/ccxt/ccxt/pull/14902#issuecomment-1271636731
                # so, when there is zero instead of i.e. 0.001, then we skip those cases, because we don't know the precision - it might be because of network is suspended or other reasons
                if not Precise.string_eq(precisionTick, '0'):
                    minPrecision = precisionTick if (minPrecision is None) else Precise.string_min(minPrecision, precisionTick)
                networks[networkCode] = {
                    'info': networkItem,
                    'id': network,
                    'network': networkCode,
                    'active': depositEnable and withdrawEnable,
                    'deposit': depositEnable,
                    'withdraw': withdrawEnable,
                    'fee': withdrawFee,
                    'precision': self.parse_number(precisionTick),
                    'limits': {
                        'withdraw': {
                            'min': self.safe_number(networkItem, 'withdrawMin'),
                            'max': self.safe_number(networkItem, 'withdrawMax'),
                        },
                        'deposit': {
                            'min': self.safe_number(networkItem, 'depositDust'),
                            'max': None,
                        },
                    },
                }
            trading = self.safe_bool(entry, 'trading')
            active = (isWithdrawEnabled and isDepositEnabled and trading)
            marginEntry = self.safe_dict(marginablesById, id, {})
            #
            #     {
            #         assetName: "BTC",
            #         assetFullName: "Bitcoin",
            #         isBorrowable: True,
            #         isMortgageable: True,
            #         userMinBorrow: "0",
            #         userMinRepay: "0",
            #     }
            #
            result[code] = {
                'active': active,
                'code': code,
                'deposit': isDepositEnabled,
                'fee': fee,
                'fees': fees,
                'id': id,
                'info': entry,
                'limits': self.limits,
                'name': name,
                'networks': networks,
                'margin': self.safe_bool(marginEntry, 'isBorrowable'),
                'precision': self.parse_number(minPrecision),
                'withdraw': isWithdrawEnabled,
            }
        return result

    def fetch_markets(self, params={}) -> List[Market]:
        """
        retrieves data on all markets for binance

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#exchange-information                             # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information     # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Exchange-Information              # future
        https://developers.binance.com/docs/derivatives/option/market-data/Exchange-Information                             # option
        https://developers.binance.com/docs/margin_trading/market-data/Get-All-Cross-Margin-Pairs                             # cross margin
        https://developers.binance.com/docs/margin_trading/market-data/Get-All-Isolated-Margin-Symbol                             # isolated margin

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: an array of objects representing market data
        """
        promisesRaw = []
        rawFetchMarkets = self.safe_list(self.options, 'fetchMarkets', ['spot', 'linear', 'inverse'])
        sandboxMode = self.safe_bool(self.options, 'sandboxMode', False)
        fetchMarkets = []
        for i in range(0, len(rawFetchMarkets)):
            type = rawFetchMarkets[i]
            if type == 'option' and sandboxMode:
                continue
            fetchMarkets.append(type)
        fetchMargins = self.safe_bool(self.options, 'fetchMargins', False)
        for i in range(0, len(fetchMarkets)):
            marketType = fetchMarkets[i]
            if marketType == 'spot':
                promisesRaw.append(self.publicGetExchangeInfo(params))
                if fetchMargins and self.check_required_credentials(False) and not sandboxMode:
                    promisesRaw.append(self.sapiGetMarginAllPairs(params))
                    promisesRaw.append(self.sapiGetMarginIsolatedAllPairs(params))
            elif marketType == 'linear':
                promisesRaw.append(self.fapiPublicGetExchangeInfo(params))
            elif marketType == 'inverse':
                promisesRaw.append(self.dapiPublicGetExchangeInfo(params))
            elif marketType == 'option':
                promisesRaw.append(self.eapiPublicGetExchangeInfo(params))
            else:
                raise ExchangeError(self.id + ' fetchMarkets() self.options fetchMarkets "' + marketType + '" is not a supported market type')
        results = promisesRaw
        markets = []
        self.options['crossMarginPairsData'] = []
        self.options['isolatedMarginPairsData'] = []
        for i in range(0, len(results)):
            res = self.safe_value(results, i)
            if fetchMargins and isinstance(res, list):
                keysList = list(self.index_by(res, 'symbol').keys())
                length = len(self.options['crossMarginPairsData'])
                # first one is the cross-margin promise
                if length == 0:
                    self.options['crossMarginPairsData'] = keysList
                else:
                    self.options['isolatedMarginPairsData'] = keysList
            else:
                resultMarkets = self.safe_list_2(res, 'symbols', 'optionSymbols', [])
                markets = self.array_concat(markets, resultMarkets)
        #
        # spot / margin
        #
        #     {
        #         "exchangeFilters":[],
        #         "rateLimits":[
        #             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        #             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":100},
        #             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":200000}
        #         ],
        #         "serverTime":1575416692969,
        #         "symbols":[
        #             {
        #                 "allowTrailingStop":false,
        #                 "baseAsset":"ETH",
        #                 "baseAssetPrecision":8,
        #                 "baseCommissionPrecision":8,
        #                 "filters":[
        #                     {"filterType":"PRICE_FILTER","minPrice":"0.00000100","maxPrice":"100000.00000000","tickSize":"0.00000100"},
        #                     {"filterType":"PERCENT_PRICE","multiplierUp":"5","multiplierDown":"0.2","avgPriceMins":5},
        #                     {"filterType":"LOT_SIZE","minQty":"0.00100000","maxQty":"100000.00000000","stepSize":"0.00100000"},
        #                     {"filterType":"MIN_NOTIONAL","minNotional":"0.00010000","applyToMarket":true,"avgPriceMins":5},
        #                     {"filterType":"ICEBERG_PARTS","limit":10},
        #                     {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"63100.00000000","stepSize":"0.00000000"},
        #                     {"filterType":"MAX_NUM_ORDERS","maxNumOrders":200},
        #                     {"filterType":"MAX_NUM_ALGO_ORDERS","maxNumAlgoOrders":5}
        #                 ],
        #                 "icebergAllowed":true,
        #                 "isMarginTradingAllowed":true,
        #                 "isSpotTradingAllowed":true,
        #                 "ocoAllowed":true,
        #                 "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
        #                 "permissions":["SPOT","MARGIN"]}
        #                 "quoteAsset":"BTC",
        #                 "quoteCommissionPrecision":8,
        #                 "quoteOrderQtyMarketAllowed":true,
        #                 "quotePrecision":8,
        #                 "status":"TRADING",
        #                 "symbol":"ETHBTC",
        #             },
        #         ],
        #         "timezone":"UTC",
        #     }
        #
        # cross & isolated pairs response:
        #
        #     [
        #         {
        #           base: "BTC",
        #           id: "376870555451677893",  # doesn't exist in isolated
        #           isBuyAllowed: True,
        #           isMarginTrade: True,
        #           isSellAllowed: True,
        #           quote: "USDT",
        #           symbol: "BTCUSDT",
        #         },
        #     ]
        #
        # futures/usdt-margined(fapi)
        #
        #     {
        #         "exchangeFilters":[],
        #         "rateLimits":[
        #             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        #             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":1200}
        #         ],
        #         "serverTime":1575417244353,
        #         "symbols":[
        #             {
        #                 "baseAsset":"BTC",
        #                 "baseAssetPrecision":8,
        #                 "filters":[
        #                     {"minPrice":"0.01","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.01"},
        #                     {"stepSize":"0.001","filterType":"LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        #                     {"stepSize":"0.001","filterType":"MARKET_LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        #                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        #                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        #                 ],
        #                 "maintMarginPercent":"2.5000",
        #                 "orderTypes":["LIMIT","MARKET","STOP"],
        #                 "pricePrecision":2,
        #                 "quantityPrecision":3,
        #                 "quoteAsset":"USDT",
        #                 "quotePrecision":8,
        #                 "requiredMarginPercent":"5.0000",
        #                 "status":"TRADING",
        #                 "symbol":"BTCUSDT",
        #                 "timeInForce":["GTC","IOC","FOK","GTX"]
        #             }
        #         ],
        #         "timezone":"UTC",
        #     }
        #
        # delivery/coin-margined(dapi)
        #
        #     {
        #         "exchangeFilters": [],
        #         "serverTime": 1597667052958,
        #         "timezone": "UTC",
        #         "rateLimits": [
        #             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000},
        #             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":6000}
        #         ],
        #         "symbols": [
        #             {
        #                 "baseAsset": "BTC",
        #                 "baseAssetPrecision": 8,
        #                 "contractSize": 100,
        #                 "contractStatus": "TRADING",
        #                 "contractType": "CURRENT_QUARTER",
        #                 "deliveryDate": 1601020800000,
        #                 "equalQtyPrecision": 4,
        #                 "filters": [
        #                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        #                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        #                     {"stepSize":"0","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        #                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        #                     {"multiplierDown":"0.9500","multiplierUp":"1.0500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        #                 ],
        #                 "maintMarginPercent": "2.5000",
        #                 "marginAsset": "BTC",
        #                 "onboardDate": 1590739200000,
        #                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        #                 "pair": "BTCUSD",
        #                 "pricePrecision": 1,
        #                 "quantityPrecision": 0,
        #                 "quoteAsset": "USD",
        #                 "quotePrecision": 8,
        #                 "requiredMarginPercent": "5.0000",
        #                 "symbol": "BTCUSD_200925",
        #                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        #             },
        #             {
        #                 "baseAsset": "BTC",
        #                 "baseAssetPrecision": 8,
        #                 "contractSize": 100,
        #                 "contractStatus": "TRADING",
        #                 "contractType": "PERPETUAL",
        #                 "deliveryDate": 4133404800000,
        #                 "equalQtyPrecision": 4,
        #                 "filters": [
        #                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        #                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        #                     {"stepSize":"1","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        #                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        #                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        #                 ],
        #                 "maintMarginPercent": "2.5000",
        #                 "marginAsset": "BTC",
        #                 "onboardDate": 1596006000000,
        #                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        #                 "pair": "BTCUSD",
        #                 "pricePrecision": 1,
        #                 "quantityPrecision": 0,
        #                 "quoteAsset": "USD",
        #                 "quotePrecision": 8,
        #                 "requiredMarginPercent": "5.0000",
        #                 "symbol": "BTCUSD_PERP",
        #                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        #             }
        #         ]
        #     }
        #
        # options(eapi)
        #
        #     {
        #         "rateLimits": [
        #             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":400},
        #             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":100},
        #             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":30}
        #         ],
        #         "optionAssets": [
        #             {"id":1,"name":"USDT"}
        #         ],
        #         "optionContracts": [
        #             {
        #                 "baseAsset": "SOL",
        #                 "id": 1,
        #                 "quoteAsset": "USDT",
        #                 "settleAsset": "USDT",
        #                 "underlying": "SOLUSDT",
        #             },
        #             ...
        #         ],
        #         "optionSymbols": [
        #             {
        #                 "contractId": 3,
        #                 "expiryDate": 1677225600000,
        #                 "filters": [
        #                     {"filterType":"PRICE_FILTER","minPrice":"724.6","maxPrice":"919.2","tickSize":"0.1"},
        #                     {"filterType":"LOT_SIZE","minQty":"0.01","maxQty":"1000","stepSize":"0.01"}
        #                 ],
        #                 "id": 2474,
        #                 "initialMargin": "0.15000000",
        #                 "maintenanceMargin": "0.07500000",
        #                 "makerFeeRate": "0.00020000",
        #                 "maxQty": "1000",
        #                 "minInitialMargin": "0.10000000",
        #                 "minMaintenanceMargin": "0.05000000",
        #                 "minQty": "0.01",
        #                 "priceScale": 1,
        #                 "quantityScale": 2,
        #                 "quoteAsset": "USDT",
        #                 "side": "CALL",
        #                 "strikePrice": "800.00000000",
        #                 "symbol": "ETH-230224-800-C",
        #                 "takerFeeRate": "0.00020000",
        #                 "underlying": "ETHUSDT",
        #                 "unit": 1,
        #             },
        #             ...
        #         ],
        #         "timezone": "UTC",
        #         "serverTime": 1675912490405,
        #     }
        #
        if self.options['adjustForTimeDifference']:
            self.load_time_difference()
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market: dict) -> Market:
        swap = False
        future = False
        option = False
        underlying = self.safe_string(market, 'underlying')
        id = self.safe_string(market, 'symbol')
        optionParts = id.split('-')
        optionBase = self.safe_string(optionParts, 0)
        lowercaseId = self.safe_string_lower(market, 'symbol')
        baseId = self.safe_string(market, 'baseAsset', optionBase)
        quoteId = self.safe_string(market, 'quoteAsset')
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        contractType = self.safe_string(market, 'contractType')
        contract = ('contractType' in market)
        expiry = self.safe_integer_2(market, 'deliveryDate', 'expiryDate')
        settleId = self.safe_string(market, 'marginAsset')
        if (contractType == 'PERPETUAL') or (expiry == 4133404800000):  # some swap markets do not have contract type, eg: BTCST
            expiry = None
            swap = True
        elif underlying is not None:
            contract = True
            option = True
            settleId = 'USDT' if (settleId is None) else settleId
        elif expiry is not None:
            future = True
        settle = self.safe_currency_code(settleId)
        spot = not contract
        filters = self.safe_list(market, 'filters', [])
        filtersByType = self.index_by(filters, 'filterType')
        status = self.safe_string_2(market, 'status', 'contractStatus')
        contractSize = None
        fees = self.fees
        linear = None
        inverse = None
        symbol = base + '/' + quote
        strike = None
        if contract:
            if swap:
                symbol = symbol + ':' + settle
            elif future:
                symbol = symbol + ':' + settle + '-' + self.yymmdd(expiry)
            elif option:
                strike = self.number_to_string(self.parse_to_numeric(self.safe_string(market, 'strikePrice')))
                symbol = symbol + ':' + settle + '-' + self.yymmdd(expiry) + '-' + strike + '-' + self.safe_string(optionParts, 3)
            contractSize = self.safe_number_2(market, 'contractSize', 'unit', self.parse_number('1'))
            linear = settle == quote
            inverse = settle == base
            feesType = 'linear' if linear else 'inverse'
            fees = self.safe_dict(self.fees, feesType, {})
        active = (status == 'TRADING')
        if spot:
            permissions = self.safe_list(market, 'permissions', [])
            for j in range(0, len(permissions)):
                if permissions[j] == 'TRD_GRP_003':
                    active = False
                    break
        isMarginTradingAllowed = self.safe_bool(market, 'isMarginTradingAllowed', False)
        marginModes = None
        if spot:
            hasCrossMargin = self.in_array(id, self.options['crossMarginPairsData'])
            hasIsolatedMargin = self.in_array(id, self.options['isolatedMarginPairsData'])
            marginModes = {
                'cross': hasCrossMargin,
                'isolated': hasIsolatedMargin,
            }
        elif linear or inverse:
            marginModes = {
                'cross': True,
                'isolated': True,
            }
        unifiedType = None
        if spot:
            unifiedType = 'spot'
        elif swap:
            unifiedType = 'swap'
        elif future:
            unifiedType = 'future'
        elif option:
            unifiedType = 'option'
            active = None
        parsedStrike = None
        if strike is not None:
            parsedStrike = self.parse_to_numeric(strike)
        entry = {
            'active': active,
            'base': base,
            'baseId': baseId,
            'contract': contract,
            'contractSize': contractSize,
            'created': self.safe_integer(market, 'onboardDate'),
            'expiry': expiry,
            'expiryDatetime': self.iso8601(expiry),
            'future': future,
            'id': id,
            'info': market,
            'inverse': inverse,
            'limits': {
                'amount': {
                    'max': self.safe_number(market, 'maxQty'),
                    'min': self.safe_number(market, 'minQty'),
                },
                'cost': {
                    'max': None,
                    'min': None,
                },
                'leverage': {
                    'max': None,
                    'min': None,
                },
                'price': {
                    'max': None,
                    'min': None,
                },
            },
            'linear': linear,
            'lowercaseId': lowercaseId,
            'maker': fees['trading']['maker'],
            'margin': spot and isMarginTradingAllowed,
            'marginModes': marginModes,
            'option': option,
            'optionType': self.safe_string_lower(market, 'side'),
            'precision': {
                'amount': self.parse_number(self.parse_precision(self.safe_string_2(market, 'quantityPrecision', 'quantityScale'))),
                'base': self.parse_number(self.parse_precision(self.safe_string(market, 'baseAssetPrecision'))),
                'price': self.parse_number(self.parse_precision(self.safe_string_2(market, 'pricePrecision', 'priceScale'))),
                'quote': self.parse_number(self.parse_precision(self.safe_string(market, 'quotePrecision'))),
            },
            'quote': quote,
            'quoteId': quoteId,
            'settle': settle,
            'settleId': settleId,
            'spot': spot,
            'strike': parsedStrike,
            'swap': swap,
            'symbol': symbol,
            'taker': fees['trading']['taker'],
            'type': unifiedType,  # present in inverse & linear apis
        }
        if 'PRICE_FILTER' in filtersByType:
            filter = self.safe_dict(filtersByType, 'PRICE_FILTER', {})
            # PRICE_FILTER reports zero values for maxPrice
            # since they updated filter types in November 2018
            # https://github.com/ccxt/ccxt/issues/4286
            # therefore limits['price']['max'] doesn't have any meaningful value except None
            entry['limits']['price'] = {
                'min': self.safe_number(filter, 'minPrice'),
                'max': self.safe_number(filter, 'maxPrice'),
            }
            entry['precision']['price'] = self.safe_number(filter, 'tickSize')
        if 'LOT_SIZE' in filtersByType:
            filter = self.safe_dict(filtersByType, 'LOT_SIZE', {})
            entry['precision']['amount'] = self.safe_number(filter, 'stepSize')
            entry['limits']['amount'] = {
                'min': self.safe_number(filter, 'minQty'),
                'max': self.safe_number(filter, 'maxQty'),
            }
        if 'MARKET_LOT_SIZE' in filtersByType:
            filter = self.safe_dict(filtersByType, 'MARKET_LOT_SIZE', {})
            entry['limits']['market'] = {
                'min': self.safe_number(filter, 'minQty'),
                'max': self.safe_number(filter, 'maxQty'),
            }
        if ('MIN_NOTIONAL' in filtersByType) or ('NOTIONAL' in filtersByType):  # notional added in 12/04/23 to spot testnet
            filter = self.safe_dict_2(filtersByType, 'MIN_NOTIONAL', 'NOTIONAL', {})
            entry['limits']['cost']['min'] = self.safe_number_2(filter, 'minNotional', 'notional')
            entry['limits']['cost']['max'] = self.safe_number(filter, 'maxNotional')
        return entry

    def parse_balance_helper(self, entry):
        account = self.account()
        account['used'] = self.safe_string(entry, 'locked')
        account['free'] = self.safe_string(entry, 'free')
        interest = self.safe_string(entry, 'interest')
        debt = self.safe_string(entry, 'borrowed')
        account['debt'] = Precise.string_add(debt, interest)
        return account

    def parse_balance_custom(self, response, type=None, marginMode=None, isPortfolioMargin=False) -> Balances:
        result = {
            'info': response,
        }
        timestamp = None
        isolated = marginMode == 'isolated'
        cross = (type == 'margin') or (marginMode == 'cross')
        if isPortfolioMargin:
            for i in range(0, len(response)):
                entry = response[i]
                account = self.account()
                currencyId = self.safe_string(entry, 'asset')
                code = self.safe_currency_code(currencyId)
                if type == 'linear':
                    account['free'] = self.safe_string(entry, 'umWalletBalance')
                    account['used'] = self.safe_string(entry, 'umUnrealizedPNL')
                elif type == 'inverse':
                    account['free'] = self.safe_string(entry, 'cmWalletBalance')
                    account['used'] = self.safe_string(entry, 'cmUnrealizedPNL')
                elif cross:
                    borrowed = self.safe_string(entry, 'crossMarginBorrowed')
                    interest = self.safe_string(entry, 'crossMarginInterest')
                    account['debt'] = Precise.string_add(borrowed, interest)
                    account['free'] = self.safe_string(entry, 'crossMarginFree')
                    account['used'] = self.safe_string(entry, 'crossMarginLocked')
                    account['total'] = self.safe_string(entry, 'crossMarginAsset')
                else:
                    usedLinear = self.safe_string(entry, 'umUnrealizedPNL')
                    usedInverse = self.safe_string(entry, 'cmUnrealizedPNL')
                    totalUsed = Precise.string_add(usedLinear, usedInverse)
                    totalWalletBalance = self.safe_string(entry, 'totalWalletBalance')
                    account['total'] = Precise.string_add(totalUsed, totalWalletBalance)
                result[code] = account
        elif not isolated and ((type == 'spot') or cross):
            timestamp = self.safe_integer(response, 'updateTime')
            balances = self.safe_list_2(response, 'balances', 'userAssets', [])
            for i in range(0, len(balances)):
                balance = balances[i]
                currencyId = self.safe_string(balance, 'asset')
                code = self.safe_currency_code(currencyId)
                account = self.account()
                account['free'] = self.safe_string(balance, 'free')
                account['used'] = self.safe_string(balance, 'locked')
                if cross:
                    debt = self.safe_string(balance, 'borrowed')
                    interest = self.safe_string(balance, 'interest')
                    account['debt'] = Precise.string_add(debt, interest)
                result[code] = account
        elif isolated:
            assets = self.safe_list(response, 'assets')
            for i in range(0, len(assets)):
                asset = assets[i]
                marketId = self.safe_string(asset, 'symbol')
                symbol = self.safe_symbol(marketId, None, None, 'spot')
                base = self.safe_dict(asset, 'baseAsset', {})
                quote = self.safe_dict(asset, 'quoteAsset', {})
                baseCode = self.safe_currency_code(self.safe_string(base, 'asset'))
                quoteCode = self.safe_currency_code(self.safe_string(quote, 'asset'))
                subResult: dict = {}
                subResult[baseCode] = self.parse_balance_helper(base)
                subResult[quoteCode] = self.parse_balance_helper(quote)
                result[symbol] = self.safe_balance(subResult)
        elif type == 'savings':
            positionAmountVos = self.safe_list(response, 'positionAmountVos', [])
            for i in range(0, len(positionAmountVos)):
                entry = positionAmountVos[i]
                currencyId = self.safe_string(entry, 'asset')
                code = self.safe_currency_code(currencyId)
                account = self.account()
                usedAndTotal = self.safe_string(entry, 'amount')
                account['total'] = usedAndTotal
                account['used'] = usedAndTotal
                result[code] = account
        elif type == 'funding':
            for i in range(0, len(response)):
                entry = response[i]
                account = self.account()
                currencyId = self.safe_string(entry, 'asset')
                code = self.safe_currency_code(currencyId)
                account['free'] = self.safe_string(entry, 'free')
                frozen = self.safe_string(entry, 'freeze')
                withdrawing = self.safe_string(entry, 'withdrawing')
                locked = self.safe_string(entry, 'locked')
                account['used'] = Precise.string_add(frozen, Precise.string_add(locked, withdrawing))
                result[code] = account
        else:
            balances = response
            if not isinstance(response, list):
                balances = self.safe_list(response, 'assets', [])
            for i in range(0, len(balances)):
                balance = balances[i]
                currencyId = self.safe_string(balance, 'asset')
                code = self.safe_currency_code(currencyId)
                account = self.account()
                account['free'] = self.safe_string(balance, 'availableBalance')
                account['used'] = self.safe_string(balance, 'initialMargin')
                account['total'] = self.safe_string_2(balance, 'marginBalance', 'balance')
                result[code] = account
        result['timestamp'] = timestamp
        result['datetime'] = self.iso8601(timestamp)
        return result if isolated else self.safe_balance(result)

    def fetch_balance(self, params={}) -> Balances:
        """
        query for balance and get the amount of funds available for trading or funds locked in orders

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#account-information-user_data                    # spot
        https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Account-Details                       # cross margin
        https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Account-Info                       # isolated margin
        https://developers.binance.com/docs/wallet/asset/funding-wallet                                                     # funding
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Futures-Account-Balance-V2   # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Futures-Account-Balance               # future
        https://developers.binance.com/docs/derivatives/option/account/Option-Account-Information                           # option
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Account-Balance                            # portfolio margin

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'future', 'delivery', 'savings', 'funding', or 'spot' or 'papi'
        :param str [params.marginMode]: 'cross' or 'isolated', for margin trading, uses self.options.defaultMarginMode if not passed, defaults to None/None/None
        :param str[]|None [params.symbols]: unified market symbols, only used in isolated margin mode
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch the balance for a portfolio margin account
        :param str [params.subType]: 'linear' or 'inverse'
        :param boolean [params.useV2]: set to True if you want to use obsolete endpoint, where some more additional fields were provided
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        self.load_markets()
        defaultType = self.safe_string_2(self.options, 'fetchBalance', 'defaultType', 'spot')
        type = self.safe_string(params, 'type', defaultType)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchBalance', None, params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchBalance', 'papi', 'portfolioMargin', False)
        marginMode = None
        query = None
        marginMode, query = self.handle_margin_mode_and_params('fetchBalance', params)
        query = self.omit(query, 'type')
        response = None
        request: dict = {}
        if isPortfolioMargin or (type == 'papi'):
            if self.is_linear(type, subType):
                type = 'linear'
            elif self.is_inverse(type, subType):
                type = 'inverse'
            isPortfolioMargin = True
            response = self.papiGetBalance(self.extend(request, query))
        elif self.is_linear(type, subType):
            type = 'linear'
            useV2 = None
            defaultUseV2 = self.safe_bool(self.options, 'useFapiPrivateV2', False)
            useV2, params = self.handle_option_and_params(params, 'fetchBalance', 'useV2', defaultUseV2)
            params = self.extend(request, query)
            if not useV2:
                response = self.fapiPrivateV3GetAccount(params)
            else:
                response = self.fapiPrivateV2GetAccount(params)
        elif self.is_inverse(type, subType):
            type = 'inverse'
            response = self.dapiPrivateGetAccount(self.extend(request, query))
        elif marginMode == 'isolated':
            paramSymbols = self.safe_list(params, 'symbols')
            query = self.omit(query, 'symbols')
            if paramSymbols is not None:
                symbols = ''
                if isinstance(paramSymbols, list):
                    symbols = self.market_id(paramSymbols[0])
                    for i in range(1, len(paramSymbols)):
                        symbol = paramSymbols[i]
                        id = self.market_id(symbol)
                        symbols += ',' + id
                else:
                    symbols = paramSymbols
                request['symbols'] = symbols
            response = self.sapiGetMarginIsolatedAccount(self.extend(request, query))
        elif (type == 'margin') or (marginMode == 'cross'):
            response = self.sapiGetMarginAccount(self.extend(request, query))
        elif type == 'savings':
            response = self.sapiGetLendingUnionAccount(self.extend(request, query))
        elif type == 'funding':
            response = self.sapiPostAssetGetFundingAsset(self.extend(request, query))
        else:
            response = self.privateGetAccount(self.extend(request, query))
        #
        # spot
        #
        #     {
        #         "accountType": "MARGIN",
        #         "balances": [
        #             {asset: "BTC", free: "0.00219821", locked: "0.00000000"  },
        #         ],
        #         "buyerCommission": 0,
        #         "canDeposit": True,
        #         "canTrade": True,
        #         "canWithdraw": True,
        #         "makerCommission": 10,
        #         "sellerCommission": 0,
        #         "takerCommission": 10,
        #         "updateTime": 1575357359602,
        #     }
        #
        # margin(cross)
        #
        #     {
        #         "borrowEnabled":true,
        #         "marginLevel":"999.00000000",
        #         "totalAssetOfBtc":"0.00000000",
        #         "totalLiabilityOfBtc":"0.00000000",
        #         "totalNetAssetOfBtc":"0.00000000",
        #         "tradeEnabled":true,
        #         "transferEnabled":true,
        #         "userAssets":[
        #             {"asset":"MATIC","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        #             {"asset":"VET","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        #             {"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}
        #         ],
        #     }
        #
        # margin(isolated)
        #
        #    {
        #        "info": {
        #            "assets": [
        #                {
        #                    "baseAsset": {
        #                        "asset": "1INCH",
        #                        "borrowed": "0",
        #                        "borrowEnabled": True,
        #                        "free": "0",
        #                        "interest": "0",
        #                        "locked": "0",
        #                        "netAsset": "0",
        #                        "netAssetOfBtc": "0",
        #                        "repayEnabled": True,
        #                        "totalAsset": "0"
        #                    },
        #                    "enabled": True,
        #                    "indexPrice": "0.59184331",
        #                    "isolatedCreated": True,
        #                    "liquidatePrice": "0",
        #                    "liquidateRate": "0",
        #                    "marginLevel": "999",
        #                    "marginLevelStatus": "EXCESSIVE",
        #                    "marginRatio": "5",
        #                    "quoteAsset": {
        #                        "asset": "USDT",
        #                        "borrowed": "0",
        #                        "borrowEnabled": True,
        #                        "free": "11",
        #                        "interest": "0",
        #                        "locked": "0",
        #                        "netAsset": "11",
        #                        "netAssetOfBtc": "0.00054615",
        #                        "repayEnabled": True,
        #                        "totalAsset": "11"
        #                    },
        #                    "symbol": "1INCHUSDT",
        #                    "tradeEnabled": True,
        #                },
        #            ]
        #        }
        #    }
        #
        # futures(fapi)
        #
        #     fapiPrivateV3GetAccount
        #
        #     {
        #         "assets":[
        #             {
        #                 "asset":"BNB",
        #                 "availableBalance":"0.01000000",
        #                 "crossUnPnl":"0.00000000",
        #                 "crossWalletBalance":"0.01000000",
        #                 "initialMargin":"0.00000000",
        #                 "maintMargin":"0.00000000",
        #                 "marginBalance":"0.01000000",
        #                 "maxWithdrawAmount":"0.01000000",
        #                 "openOrderInitialMargin":"0.00000000",
        #                 "positionInitialMargin":"0.00000000",
        #                 "unrealizedProfit":"0.00000000",
        #                 "walletBalance":"0.01000000",
        #             }
        #         ],
        #         "availableBalance":"0.00000000",
        #         "canDeposit":true,
        #         "canTrade":true,
        #         "canWithdraw":true,
        #         "feeTier":0,
        #         "maxWithdrawAmount":"0.00000000",
        #         "positions":[
        #             {
        #                 "entryPrice":"0.00000",
        #                 "initialMargin":"0",
        #                 "isolated":false,
        #                 "leverage":"21",
        #                 "maintMargin":"0",
        #                 "maxNotional":"5000000",
        #                 "openOrderInitialMargin":"0",
        #                 "positionInitialMargin":"0",
        #                 "positionSide":"BOTH",
        #                 "symbol":"BTCUSDT",
        #                 "unrealizedProfit":"0.00000000",
        #             },
        #         ],
        #         "totalCrossUnPnl":"0.00000000",
        #         "totalCrossWalletBalance":"0.00000000",
        #         "totalInitialMargin":"0.00000000",
        #         "totalMaintMargin":"0.00000000",
        #         "totalMarginBalance":"0.00000000",
        #         "totalOpenOrderInitialMargin":"0.00000000",
        #         "totalPositionInitialMargin":"0.00000000",
        #         "totalUnrealizedProfit":"0.00000000",
        #         "totalWalletBalance":"0.00000000",
        #         "updateTime":0,
        #     }
        #
        #     fapiPrivateV2GetBalance
        #
        #     [
        #         {
        #             "accountAlias":"FzFzXquXXqoC",
        #             "asset":"BNB",
        #             "availableBalance":"0.01000000",
        #             "balance":"0.01000000",
        #             "crossUnPnl":"0.00000000",
        #             "crossWalletBalance":"0.01000000",
        #             "maxWithdrawAmount":"0.01000000"
        #         }
        #     ]
        #
        # savings
        #
        #     {
        #       "positionAmountVos": [
        #         {
        #           "amount": "10000",
        #           "amountInBTC": "0.3172",
        #           "amountInUSDT": "10000",
        #           "asset": "USDT",
        #         },
        #         {
        #           "amount": "0",
        #           "amountInBTC": "0",
        #           "amountInUSDT": "0",
        #           "asset": "BUSD",
        #         }
        #       ],
        #       "totalAmountInBTC": "0.3172",
        #       "totalAmountInUSDT": "10000",
        #       "totalFixedAmountInBTC": "0.3172",
        #       "totalFixedAmountInUSDT": "10000",
        #       "totalFlexibleInBTC": "0",
        #       "totalFlexibleInUSDT": "0",
        #     }
        #
        # binance pay
        #
        #     [
        #       {
        #         "asset": "BUSD",
        #         "free": "1129.83",
        #         "freeze": "0",
        #         "locked": "0",
        #         "withdrawing": "0",
        #       }
        #     ]
        #
        # portfolio margin
        #
        #     [
        #         {
        #             "asset": "USDT",
        #             "cmUnrealizedPNL": "0.0",
        #             "cmWalletBalance": "0.0",
        #             "crossMarginAsset": "35.9697141",
        #             "crossMarginBorrowed": "0.0",
        #             "crossMarginFree": "35.9697141",
        #             "crossMarginInterest": "0.0",
        #             "crossMarginLocked": "0.0",
        #             "negativeBalance": "0.0",
        #             "totalWalletBalance": "66.9923261",
        #             "umUnrealizedPNL": "0.0",
        #             "umWalletBalance": "31.022612",
        #             "updateTime": 0,
        #         },
        #     ]
        #
        return self.parse_balance_custom(response, type, marginMode, isPortfolioMargin)

    def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#order-book                           # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book   # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Order-Book            # future
        https://developers.binance.com/docs/derivatives/option/market-data/Order-Book                           # option

        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit  # default 100, max 5000, see https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#order-book
        response = None
        if market['option']:
            response = self.eapiPublicGetDepth(self.extend(request, params))
        elif market['linear']:
            response = self.fapiPublicGetDepth(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPublicGetDepth(self.extend(request, params))
        else:
            response = self.publicGetDepth(self.extend(request, params))
        #
        # future
        #
        #     {
        #         "asks":[
        #             ["2493.57","0.877"],
        #             ["2493.62","0.063"],
        #             ["2493.71","12.054"],
        #         ],
        #         "bids":[
        #             ["2493.56","20.189"],
        #             ["2493.54","1.000"],
        #             ["2493.51","0.005"]
        #         ],
        #         "E":1618631511986,
        #         "lastUpdateId":333598053905,
        #         "T":1618631511964,
        #     }
        #
        # options(eapi)
        #
        #     {
        #         "asks": [
        #             ["111.4","19.52"],
        #             ["119.9","17.6"],
        #             ["141.2","31"]
        #         ],
        #         "bids": [
        #             ["108.7","16.08"],
        #             ["106","21.29"],
        #             ["82.4","0.02"]
        #         ],
        #         "T": 1676771382078,
        #         "u": 1015939
        #     }
        #
        timestamp = self.safe_integer(response, 'T')
        orderbook = self.parse_order_book(response, symbol, timestamp)
        orderbook['nonce'] = self.safe_integer_2(response, 'lastUpdateId', 'u')
        return orderbook

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        # markPrices
        #
        #     {
        #         "symbol": "BTCUSDT",
        #         "markPrice": "11793.63104562",  # mark price
        #         "indexPrice": "11781.80495970",  # index price
        #         "estimatedSettlePrice": "11781.16138815",  # Estimated Settle Price, only useful in the last hour before the settlement starts.
        #         "lastFundingRate": "0.00038246",  # This is the lastest estimated funding rate
        #         "nextFundingTime": 1597392000000,
        #         "interestRate": "0.00010000",
        #         "time": 1597370495002
        #     }
        #
        #     {
        #         "askPrice": "0.03379000",
        #         "askQty": "24.00000000",
        #         "bidPrice": "0.03378900",
        #         "bidQty": "7.16800000",
        #         "closeTime": 1601556386932,
        #         "count": 87544,
        #         "firstId": 196098772,
        #         "highPrice": "0.03388900",
        #         "lastId": 196186315,
        #         "lastPrice": "0.03378900",
        #         "lastQty": "0.07700000",
        #         "lowPrice": "0.03306900",
        #         "openPrice": "0.03310200",
        #         "openTime": 1601469986932,
        #         "prevClosePrice": "0.03310300",
        #         "priceChange": "0.00068700",
        #         "priceChangePercent": "2.075",
        #         "quoteVolume": "6868.48826294",
        #         "symbol": "ETHBTC",
        #         "volume": "205478.41000000",
        #         "weightedAvgPrice": "0.03342681",
        #     }
        #
        # coinm
        #
        #     {
        #         "baseVolume": "214549.95171161",
        #         "closeTime": "1621965286847",
        #         "count": "1283779",
        #         "firstId": "152560106",
        #         "highPrice": "39938.3",
        #         "lastId": "153843955",
        #         "lastPrice": "37993.4",
        #         "lastQty": "1",
        #         "lowPrice": "36457.2",
        #         "openPrice": "37783.4",
        #         "openTime": "1621878840000",
        #         "pair": "BTCUSD",
        #         "priceChange": "210.0",
        #         "priceChangePercent": "0.556",
        #         "symbol": "BTCUSD_PERP",
        #         "volume": "81990451",
        #         "weightedAvgPrice": "38215.08713747",
        #     }
        #
        # eapi: fetchTicker, fetchTickers
        #
        #     {
        #         "amount": "201.44",
        #         "askPrice": "22.4",
        #         "bidPrice": "21.9",
        #         "closeTime": 1683695017784,
        #         "exercisePrice": "1845.95341176",
        #         "firstTradeId": 12,
        #         "high": "34.1",
        #         "lastPrice": "22.4",
        #         "lastQty": "0",
        #         "low": "22.4",
        #         "open": "27.5",
        #         "openTime": 1683614771898,
        #         "priceChange": "-5.1",
        #         "priceChangePercent": "-0.1854",
        #         "strikePrice": "1825",
        #         "symbol": "ETH-230510-1825-C",
        #         "tradeCount": 22,
        #         "volume": "6.83",
        #     }
        #
        # spot bidsAsks
        #
        #     {
        #         "askPrice":"0.07466900",
        #         "askQty":"10.93540000",
        #         "bidPrice":"0.07466800",
        #         "bidQty":"5.31990000",
        #         "symbol":"ETHBTC",
        #     }
        #
        # usdm bidsAsks
        #
        #     {
        #         "askPrice":"21322.00",
        #         "askQty":"1.427",
        #         "bidPrice":"21321.90",
        #         "bidQty":"33.592",
        #         "symbol":"BTCUSDT",
        #         "time":"1673899207538"
        #     }
        #
        # coinm bidsAsks
        #
        #     {
        #         "askPrice":"21301.3",
        #         "askQty":"10302",
        #         "bidPrice":"21301.2",
        #         "bidQty":"188",
        #         "pair":"BTCUSD",
        #         "symbol":"BTCUSD_PERP",
        #         "time":"1673899278514"
        #     }
        #
        timestamp = self.safe_integer_2(ticker, 'closeTime', 'time')
        marketType = None
        if ('time' in ticker):
            marketType = 'contract'
        if marketType is None:
            marketType = 'spot' if ('bidQty' in ticker) else 'contract'
        marketId = self.safe_string(ticker, 'symbol')
        symbol = self.safe_symbol(marketId, market, None, marketType)
        last = self.safe_string(ticker, 'lastPrice')
        wAvg = self.safe_string(ticker, 'weightedAvgPrice')
        isCoinm = ('baseVolume' in ticker)
        baseVolume = None
        quoteVolume = None
        if isCoinm:
            baseVolume = self.safe_string(ticker, 'baseVolume')
            # 'volume' field in inverse markets is not quoteVolume, but traded amount(per contracts)
            quoteVolume = Precise.string_mul(baseVolume, wAvg)
        else:
            baseVolume = self.safe_string(ticker, 'volume')
            quoteVolume = self.safe_string_2(ticker, 'quoteVolume', 'amount')
        return self.safe_ticker({
            'ask': self.safe_string(ticker, 'askPrice'),
            'askVolume': self.safe_string(ticker, 'askQty'),
            'average': None,
            'baseVolume': baseVolume,
            'bid': self.safe_string(ticker, 'bidPrice'),
            'bidVolume': self.safe_string(ticker, 'bidQty'),
            'change': self.safe_string(ticker, 'priceChange'),
            'close': last,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string_2(ticker, 'highPrice', 'high'),
            'indexPrice': self.safe_string(ticker, 'indexPrice'),
            'info': ticker,
            'last': last,
            'low': self.safe_string_2(ticker, 'lowPrice', 'low'),
            'markPrice': self.safe_string(ticker, 'markPrice'),
            'open': self.safe_string_2(ticker, 'openPrice', 'open'),
            'percentage': self.safe_string(ticker, 'priceChangePercent'),
            'previousClose': self.safe_string(ticker, 'prevClosePrice'),  # previous day close
            'quoteVolume': quoteVolume,
            'symbol': symbol,
            'timestamp': timestamp,
            'vwap': wAvg,
        }, market)

    def fetch_status(self, params={}):
        """
        the latest known information on the availability of the exchange API

        https://developers.binance.com/docs/wallet/others/system-status

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `status structure <https://docs.ccxt.com/#/?id=exchange-status-structure>`
        """
        response = self.sapiGetSystemStatus(params)
        #
        #     {
        #         "msg": "normal",          # "normal", "system_maintenance"
        #         "status": 0,              # 0: normal1system maintenance
        #     }
        #
        statusRaw = self.safe_string(response, 'status')
        return {
            'status': self.safe_string({'0': 'ok', '1': 'maintenance'}, statusRaw, statusRaw),
            'updated': None,
            'eta': None,
            'url': None,
            'info': response,
        }

    def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#24hr-ticker-price-change-statistics                           # spot
        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#rolling-window-price-change-statistics                        # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics   # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/24hr-Ticker-Price-Change-Statistics            # future
        https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics                           # option

        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.rolling]:(spot only) default False, if True, uses the rolling 24 hour ticker endpoint /api/v3/ticker
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        response = None
        if market['option']:
            response = self.eapiPublicGetTicker(self.extend(request, params))
        elif market['linear']:
            response = self.fapiPublicGetTicker24hr(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPublicGetTicker24hr(self.extend(request, params))
        else:
            rolling = self.safe_bool(params, 'rolling', False)
            params = self.omit(params, 'rolling')
            if rolling:
                response = self.publicGetTicker(self.extend(request, params))
            else:
                response = self.publicGetTicker24hr(self.extend(request, params))
        if isinstance(response, list):
            firstTicker = self.safe_dict(response, 0, {})
            return self.parse_ticker(firstTicker, market)
        return self.parse_ticker(response, market)

    def fetch_bids_asks(self, symbols: Strings = None, params={}):
        """
        fetches the bid and ask price and volume for multiple markets

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#symbol-order-book-ticker                         # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker  # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Symbol-Order-Book-Ticker          # future

        :param str[]|None symbols: unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols, None, True, True, True)
        market = self.get_market_from_symbols(symbols)
        type = None
        type, params = self.handle_market_type_and_params('fetchBidsAsks', market, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchBidsAsks', market, params)
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetTickerBookTicker(params)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetTickerBookTicker(params)
        elif type == 'spot':
            request: dict = {}
            if symbols is not None:
                request['symbols'] = self.json(self.market_ids(symbols))
            response = self.publicGetTickerBookTicker(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchBidsAsks() does not support ' + type + ' markets yet')
        return self.parse_tickers(response, symbols)

    def fetch_last_prices(self, symbols: Strings = None, params={}):
        """
        fetches the last price for multiple markets

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#symbol-price-ticker                          # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker  # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Symbol-Price-Ticker           # future

        :param str[]|None symbols: unified symbols of the markets to fetch the last prices
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of lastprices structures
        """
        self.load_markets()
        symbols = self.market_symbols(symbols, None, True, True, True)
        market = self.get_market_from_symbols(symbols)
        type = None
        type, params = self.handle_market_type_and_params('fetchLastPrices', market, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchLastPrices', market, params)
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicV2GetTickerPrice(params)
            #
            #     [
            #         {
            #             "price": "4.00000200"
            #             "symbol": "LTCBTC",
            #             "time": 1589437530011,
            #         },
            #         ...
            #     ]
            #
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetTickerPrice(params)
            #
            #     [
            #         {
            #             "price": "9647.8",
            #             "ps": "9647.8",
            #             "symbol": "BTCUSD_200626",
            #             "time": 1591257246176,
            #         }
            #     ]
            #
        elif type == 'spot':
            response = self.publicGetTickerPrice(params)
            #
            #     [
            #         {
            #             "price": "4.00000200",
            #             "symbol": "LTCBTC",
            #         },
            #         ...
            #     ]
            #
        else:
            raise NotSupported(self.id + ' fetchLastPrices() does not support ' + type + ' markets yet')
        return self.parse_last_prices(response, symbols)

    def parse_last_price(self, entry, market: Market = None):
        #
        # spot
        #
        #     {
        #         "price": "4.00000200",
        #         "symbol": "LTCBTC",
        #     }
        #
        # usdm(swap/future)
        #
        #     {
        #         "price": "6000.01",
        #         "symbol": "BTCUSDT",
        #         "time": 1589437530011   # Transaction time
        #     }
        #
        #
        # coinm(swap/future)
        #
        #     {
        #         "price": "9647.8",
        #         "ps": "BTCUSD",  # pair
        #         "symbol": "BTCUSD_200626",  # symbol("BTCUSD_200626", "BTCUSD_PERP", etc..)
        #         "time": 1591257246176
        #     }
        #
        timestamp = self.safe_integer(entry, 'time')
        type = 'spot' if (timestamp is None) else 'swap'
        marketId = self.safe_string(entry, 'symbol')
        market = self.safe_market(marketId, market, None, type)
        price = self.safe_number(entry, 'price')
        return {
            'datetime': self.iso8601(timestamp),
            'info': entry,
            'price': price,
            'side': None,
            'symbol': market['symbol'],
            'timestamp': timestamp,
        }

    def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#24hr-ticker-price-change-statistics                          # spot
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics  # swap
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/24hr-Ticker-Price-Change-Statistics           # future
        https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics                          # option

        :param str[] [symbols]: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :param str [params.type]: 'spot', 'option', use params["subType"] for swap and future markets
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols, None, True, True, True)
        market = self.get_market_from_symbols(symbols)
        type = None
        type, params = self.handle_market_type_and_params('fetchTickers', market, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchTickers', market, params)
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetTicker24hr(params)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetTicker24hr(params)
        elif type == 'spot':
            request: dict = {}
            if symbols is not None:
                request['symbols'] = self.json(self.market_ids(symbols))
            response = self.publicGetTicker24hr(self.extend(request, params))
        elif type == 'option':
            response = self.eapiPublicGetTicker(params)
        else:
            raise NotSupported(self.id + ' fetchTickers() does not support ' + type + ' markets yet')
        return self.parse_tickers(response, symbols)

    def fetch_mark_price(self, symbol: str, params={}) -> Ticker:
        """
        fetches mark price for the market

        https://binance-docs.github.io/apidocs/futures/en/#mark-price
        https://binance-docs.github.io/apidocs/delivery/en/#index-price-and-mark-price

        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        type = None
        type, params = self.handle_market_type_and_params('fetchMarkPrice', market, params, 'swap')
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchMarkPrice', market, params, 'linear')
        request = {
            'symbol': market['id'],
        }
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetPremiumIndex(self.extend(request, params))
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetPremiumIndex(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchMarkPrice() does not support ' + type + ' markets yet')
        if isinstance(response, list):
            return self.parse_ticker(self.safe_dict(response, 0, {}), market)
        return self.parse_ticker(response, market)

    def fetch_mark_prices(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches mark prices for multiple markets

        https://binance-docs.github.io/apidocs/futures/en/#mark-price
        https://binance-docs.github.io/apidocs/delivery/en/#index-price-and-mark-price

        :param str[] [symbols]: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols, None, True, True, True)
        market = self.get_market_from_symbols(symbols)
        type = None
        type, params = self.handle_market_type_and_params('fetchMarkPrices', market, params, 'swap')
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchMarkPrices', market, params, 'linear')
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetPremiumIndex(params)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetPremiumIndex(params)
        else:
            raise NotSupported(self.id + ' fetchMarkPrices() does not support ' + type + ' markets yet')
        return self.parse_tickers(response, symbols)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        # when api method = publicGetKlines or fapiPublicGetKlines or dapiPublicGetKlines
        #     [
        #         1591478520000,  # open time
        #         "0.02501300",  # open
        #         "0.02501800",  # high
        #         "0.02500000",  # low
        #         "0.02500000",  # close
        #         "22.19000000",  # volume
        #         1591478579999,  # close time
        #         "0.55490906",  # quote asset volume, base asset volume for dapi
        #         40,            # number of trades
        #         "10.92900000",  # taker buy base asset volume
        #         "0.27336462",  # taker buy quote asset volume
        #         "0"            # ignore
        #     ]
        #
        #  when api method = fapiPublicGetMarkPriceKlines or fapiPublicGetIndexPriceKlines
        #     [
        #         [
        #         1591256460000,          # Open time
        #         "9653.29201333",        # Open
        #         "9654.56401333",        # High
        #         "9653.07367333",        # Low
        #         "9653.07367333",        # Close(or latest price)
        #         "0",                    # Ignore
        #         1591256519999,          # Close time
        #         "0",                    # Ignore
        #         60,                     # Number of bisic data
        #         "0",                    # Ignore
        #         "0",                    # Ignore
        #         "0",                    # Ignore
        #         ]
        #     ]
        #
        # options
        #
        #     {
        #         "amount": "0",
        #         "close": "32.2",
        #         "closeTime": 1677097200000,
        #         "high": "32.2",
        #         "interval": "5m",
        #         "low": "32.2",
        #         "open": "32.2",
        #         "openTime": 1677096900000,
        #         "takerAmount": "0",
        #         "takerVolume": "0",
        #         "tradeCount": 0,
        #         "volume": "0",
        #     }
        #
        inverse = self.safe_bool(market, 'inverse')
        volumeIndex = 7 if inverse else 5
        return [
            self.safe_integer_2(ohlcv, 0, 'openTime'),
            self.safe_number_2(ohlcv, 1, 'open'),
            self.safe_number_2(ohlcv, 2, 'high'),
            self.safe_number_2(ohlcv, 3, 'low'),
            self.safe_number_2(ohlcv, 4, 'close'),
            self.safe_number_2(ohlcv, volumeIndex, 'volume'),
        ]

    def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#klinecandlestick-data
        https://developers.binance.com/docs/derivatives/option/market-data/Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-Index-Kline-Data
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Index-Price-Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Mark-Price-Kline-Candlestick-Data
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Premium-Index-Kline-Data

        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.price]: "mark" or "index" for mark price and index price candles
        :param int [params.until]: timestamp in ms of the latest candle to fetch
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchOHLCV', 'paginate', False)
        if paginate:
            return self.fetch_paginated_call_deterministic('fetchOHLCV', symbol, since, limit, timeframe, params, 1000)
        market = self.market(symbol)
        # binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
        # the reality is that the time range wider than 500 candles won't work right
        defaultLimit: Num
        defaultLimit, params = self.handle_option_and_params(params, 'fetchOHLCV', 'defaultLimit', 500)
        maxLimit: Num
        maxLimit, params = self.handle_option_and_params(params, 'fetchOHLCV', 'maxLimit', 1500)
        price = self.safe_string(params, 'price')
        until = self.safe_integer(params, 'until')
        params = self.omit(params, ['price', 'until'])
        if since is not None and until is not None and limit is None:
            limit = maxLimit
        limit = defaultLimit if (limit is None) else min(limit, maxLimit)
        request: dict = {
            'interval': self.safe_string(self.timeframes, timeframe, timeframe),
            'limit': limit,
        }
        marketId = market['id']
        if price == 'index':
            parts = marketId.split('_')
            pair = self.safe_string(parts, 0)
            request['pair'] = pair   # Index price takes self argument instead of symbol
        else:
            request['symbol'] = marketId
        # duration = self.parse_timeframe(timeframe)
        if since is not None:
            request['startTime'] = since
            #
            # It didn't work before without the endTime
            # https://github.com/ccxt/ccxt/issues/8454
            #
            if market['inverse']:
                if since > 0:
                    duration = self.parse_timeframe(timeframe)
                    endTime = self.sum(since, limit * duration * 1000 - 1)
                    now = self.milliseconds()
                    request['endTime'] = min(now, endTime)
        if until is not None:
            request['endTime'] = until
        response = None
        if market['option']:
            response = self.eapiPublicGetKlines(self.extend(request, params))
        elif price == 'mark':
            if market['inverse']:
                response = self.dapiPublicGetMarkPriceKlines(self.extend(request, params))
            else:
                response = self.fapiPublicGetMarkPriceKlines(self.extend(request, params))
        elif price == 'index':
            if market['inverse']:
                response = self.dapiPublicGetIndexPriceKlines(self.extend(request, params))
            else:
                response = self.fapiPublicGetIndexPriceKlines(self.extend(request, params))
        elif price == 'premiumIndex':
            if market['inverse']:
                response = self.dapiPublicGetPremiumIndexKlines(self.extend(request, params))
            else:
                response = self.fapiPublicGetPremiumIndexKlines(self.extend(request, params))
        elif market['linear']:
            response = self.fapiPublicGetKlines(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPublicGetKlines(self.extend(request, params))
        else:
            response = self.publicGetKlines(self.extend(request, params))
        #
        #     [
        #         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
        #         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
        #         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
        #     ]
        #
        # options(eapi)
        #
        #     [
        #         {
        #             "amount": "0",
        #             "close": "32.2",
        #             "closeTime": 1677097200000,
        #             "high": "32.2",
        #             "interval": "5m",
        #             "low": "32.2",
        #             "open": "32.2",
        #             "openTime": 1677096900000,
        #             "takerAmount": "0",
        #             "takerVolume": "0",
        #             "tradeCount": 0,
        #             "volume": "0",
        #         }
        #     ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        if 'isDustTrade' in trade:
            return self.parse_dust_trade(trade, market)
        #
        # aggregate trades
        # https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
        #
        #     {
        #         "a": 26129,         # Aggregate tradeId
        #         "f": 27781,         # First tradeId
        #         "l": 27781,         # Last tradeId
        #         "m": True,          # Was the buyer the maker?
        #         "M": True,          # Was the trade the best price match?
        #         "p": "0.01633102",  # Price
        #         "q": "4.70443515",  # Quantity
        #         "T": 1498793709153,  # Timestamp
        #     }
        #
        # REST: aggregate trades for swap & future(both linear and inverse)
        #
        #     {
        #         "a": "269772814",
        #         "f": "662149354",
        #         "l": "662149355",
        #         "m": False,
        #         "p": "25864.1",
        #         "q": "3",
        #         "T": "1694209776022",
        #     }
        #
        # recent public trades and old public trades
        # https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
        # https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
        #
        #     {
        #         "id": 28457,
        #         "isBestMatch": True,
        #         "isBuyerMaker": True,
        #         "price": "4.00000100",
        #         "qty": "12.00000000",
        #         "time": 1499865549590,
        #     }
        #
        # private trades
        # https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
        #
        #     {
        #         "commission": "10.10000000",
        #         "commissionAsset": "BNB",
        #         "id": 28457,
        #         "isBestMatch": True,
        #         "isBuyer": True,
        #         "isMaker": False,
        #         "orderId": 100234,
        #         "price": "4.00000100",
        #         "qty": "12.00000000",
        #         "symbol": "BNBBTC",
        #         "time": 1499865549590,
        #     }
        #
        # futures trades
        #
        #     {
        #       "accountId": 20,
        #       "buyer": False,
        #       "commission": "-0.07819010",
        #       "commissionAsset": "USDT",
        #       "counterPartyId": 653,
        #       "id": 698759,
        #       "maker": False,
        #       "orderId": 25851813,
        #       "price": "7819.01",
        #       "qty": "0.002",
        #       "quoteQty": "0.01563",
        #       "realizedPnl": "-0.91539999",
        #       "side": "SELL",
        #       "symbol": "BTCUSDT",
        #       "time": 1569514978020,
        #     }
        #     {
        #       "buyer": False,
        #       "commission": "-0.00076959",
        #       "commissionAsset": "USDT",
        #       "id": 477128891,
        #       "maker": True,
        #       "marginAsset": "USDT",
        #       "orderId": 13809777875,
        #       "positionSide": "BOTH",
        #       "price": "38479.55",
        #       "qty": "0.001",
        #       "quoteQty": "38.47955",
        #       "realizedPnl": "-0.00009534",
        #       "side": "SELL",
        #       "symbol": "BTCUSDT",
        #       "time": 1612733566708,
        #     }
        #
        # {respType: FULL}
        #
        #     {
        #       "commission": "4.00000000",
        #       "commissionAsset": "USDT",
        #       "price": "4000.00000000",
        #       "qty": "1.00000000",
        #       "tradeId": "1234",
        #     }
        #
        # options: fetchMyTrades
        #
        #     {
        #         "fee": "0.17305890",
        #         "id": 1125899906844226012,
        #         "liquidity": "MAKER",
        #         "optionSide": "CALL",
        #         "orderId": 4638761100843040768,
        #         "price": "18.70000000",
        #         "priceScale": 1,
        #         "quantity": "-0.57000000",
        #         "quantityScale": 2,
        #         "quoteAsset": "USDT",
        #         "realizedProfit": "-3.53400000",
        #         "side": "SELL",
        #         "symbol": "ETH-230211-1500-C",
        #         "time": 1676085216845,
        #         "tradeId": 73,
        #         "type": "LIMIT",
        #         "volatility": "0.30000000",
        #     }
        #
        # options: fetchTrades
        #
        #     {
        #         "id": 1,
        #         "price": "35.5",
        #         "qty": "0.03",
        #         "quoteQty": "1.065",
        #         "side": 1,
        #         "symbol": "ETH-230216-1500-C",
        #         "time": 1676366446072,
        #     }
        #
        # fetchMyTrades: linear portfolio margin
        #
        #     {
        #         "buyer": False,
        #         "commission": "0.18905360",
        #         "commissionAsset": "USDT",
        #         "id": 4575108247,
        #         "maker": False,
        #         "marginAsset": "USDT",
        #         "orderId": 261942655610,
        #         "positionSide": "LONG",
        #         "price": "47263.40",
        #         "qty": "0.010",
        #         "quoteQty": "472.63",
        #         "realizedPnl": "27.38400000",
        #         "side": "SELL",
        #         "symbol": "BTCUSDT",
        #         "time": 1707530039409,
        #     }
        #
        # fetchMyTrades: inverse portfolio margin
        #
        #     {
        #         "baseQty": "0.00400296",
        #         "buyer": False,
        #         "commission": "0.00000160",
        #         "commissionAsset": "ETH",
        #         "id": 701907838,
        #         "maker": False,
        #         "marginAsset": "ETH",
        #         "orderId": 71548909034,
        #         "pair": "ETHUSD",
        #         "positionSide": "LONG",
        #         "price": "2498.15",
        #         "qty": "1",
        #         "realizedPnl": "0.00012517",
        #         "side": "SELL",
        #         "symbol": "ETHUSD_PERP",
        #         "time": 1707530317519,
        #     }
        #
        # fetchMyTrades: spot margin portfolio margin
        #
        #     {
        #         "commission": "0.00538800",
        #         "commissionAsset": "USDT",
        #         "id": 470227543,
        #         "isBestMatch": True,
        #         "isBuyer": False,
        #         "isMaker": False,
        #         "orderId": 4421170947,
        #         "price": "0.53880000",
        #         "qty": "10.00000000",
        #         "quoteQty": "5.38800000",
        #         "symbol": "ADAUSDT",
        #         "time": 1707545780522,
        #     }
        #
        timestamp = self.safe_integer_2(trade, 'T', 'time')
        amount = self.safe_string_2(trade, 'q', 'qty')
        amount = self.safe_string(trade, 'quantity', amount)
        marketId = self.safe_string(trade, 'symbol')
        isSpotTrade = ('isIsolated' in trade) or ('M' in trade) or ('orderListId' in trade) or ('isMaker' in trade)
        marketType = 'spot' if isSpotTrade else 'contract'
        market = self.safe_market(marketId, market, None, marketType)
        symbol = market['symbol']
        side = None
        buyerMaker = self.safe_bool_2(trade, 'm', 'isBuyerMaker')
        takerOrMaker = None
        if buyerMaker is not None:
            side = 'sell' if buyerMaker else 'buy'  # self is reversed intentionally
        elif 'side' in trade:
            side = self.safe_string_lower(trade, 'side')
        else:
            if 'isBuyer' in trade:
                side = 'buy' if trade['isBuyer'] else 'sell'  # self is a True side
        fee = None
        if 'commission' in trade:
            fee = {
                'cost': self.safe_string(trade, 'commission'),
                'currency': self.safe_currency_code(self.safe_string(trade, 'commissionAsset')),
            }
        if 'isMaker' in trade:
            takerOrMaker = 'maker' if trade['isMaker'] else 'taker'
        if 'maker' in trade:
            takerOrMaker = 'maker' if trade['maker'] else 'taker'
        if ('optionSide' in trade) or market['option']:
            settle = self.safe_currency_code(self.safe_string(trade, 'quoteAsset', 'USDT'))
            takerOrMaker = self.safe_string_lower(trade, 'liquidity')
            if 'fee' in trade:
                fee = {
                    'cost': self.safe_string(trade, 'fee'),
                    'currency': settle,
                }
            if (side != 'buy') and (side != 'sell'):
                side = 'buy' if (side == '1') else 'sell'
            if 'optionSide' in trade:
                if side != 'buy':
                    amount = Precise.string_mul('-1', amount)
        return self.safe_trade({
            'amount': amount,
            'cost': self.safe_string_2(trade, 'quoteQty', 'baseQty'),
            'datetime': self.iso8601(timestamp),
            'fee': fee,
            'id': self.safe_string_n(trade, ['t', 'a', 'tradeId', 'id']),
            'info': trade,
            'order': self.safe_string(trade, 'orderId'),
            'price': self.safe_string_2(trade, 'p', 'price'),
            'side': side,
            'symbol': symbol,
            'takerOrMaker': takerOrMaker,
            'timestamp': timestamp,
            'type': self.safe_string_lower(trade, 'type'),
        }, market)

    def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol
 Default fetchTradesMethod

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#compressedaggregate-trades-list                          # publicGetAggTrades(spot)
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List  # fapiPublicGetAggTrades(swap)
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Compressed-Aggregate-Trades-List          # dapiPublicGetAggTrades(future)
        https://developers.binance.com/docs/derivatives/option/market-data/Recent-Trades-List                                       # eapiPublicGetTrades(option)

 Other fetchTradesMethod

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#recent-trades-list                                       # publicGetTrades(spot)
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List               # fapiPublicGetTrades(swap)
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Recent-Trades-List                        # dapiPublicGetTrades(future)
        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#old-trade-lookup                                         # publicGetHistoricalTrades(spot)
        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup                # fapiPublicGetHistoricalTrades(swap)
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Old-Trades-Lookup                         # dapiPublicGetHistoricalTrades(future)
        https://developers.binance.com/docs/derivatives/option/market-data/Old-Trades-Lookup                                        # eapiPublicGetHistoricalTrades(option)

        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
        :param int [limit]: default 500, max 1000
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
        :param int [params.fetchTradesMethod]: 'publicGetAggTrades'(spot default), 'fapiPublicGetAggTrades'(swap default), 'dapiPublicGetAggTrades'(future default), 'eapiPublicGetTrades'(option default), 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', 'publicGetHistoricalTrades', 'fapiPublicGetHistoricalTrades', 'dapiPublicGetHistoricalTrades', 'eapiPublicGetHistoricalTrades'
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)

 EXCHANGE SPECIFIC PARAMETERS
        :param int [params.fromId]: trade id to fetch from, default gets most recent trades, not used when fetchTradesMethod is 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', or 'eapiPublicGetTrades'
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchTrades', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchTrades', symbol, since, limit, params)
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
            # 'fromId': 123,    # ID to get aggregate trades from INCLUSIVE.
            # 'startTime': 456,  # Timestamp in ms to get aggregate trades from INCLUSIVE.
            # 'endTime': 789,   # Timestamp in ms to get aggregate trades until INCLUSIVE.
            # 'limit': 500,     # default = 500, maximum = 1000
        }
        if not market['option']:
            if since is not None:
                request['startTime'] = since
                # https://github.com/ccxt/ccxt/issues/6400
                # https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
                request['endTime'] = self.sum(since, 3600000)
            until = self.safe_integer(params, 'until')
            if until is not None:
                request['endTime'] = until
        if limit is not None:
            isFutureOrSwap = (market['swap'] or market['future'])
            request['limit'] = min(limit, 1000) if isFutureOrSwap else limit  # default = 500, maximum = 1000
        method = self.safe_string(self.options, 'fetchTradesMethod')
        method = self.safe_string_2(params, 'fetchTradesMethod', 'method', method)
        params = self.omit(params, ['until', 'fetchTradesMethod'])
        response = None
        if market['option'] or method == 'eapiPublicGetTrades':
            response = self.eapiPublicGetTrades(self.extend(request, params))
        elif market['linear'] or method == 'fapiPublicGetAggTrades':
            response = self.fapiPublicGetAggTrades(self.extend(request, params))
        elif market['inverse'] or method == 'dapiPublicGetAggTrades':
            response = self.dapiPublicGetAggTrades(self.extend(request, params))
        else:
            response = self.publicGetAggTrades(self.extend(request, params))
        #
        # Caveats:
        # - default limit(500) applies only if no other parameters set, trades up
        #   to the maximum limit may be returned to satisfy other parameters
        # - if both limit and time window is set and time window contains more
        #   trades than the limit then the last trades from the window are returned
        # - "tradeId" accepted and returned by self method is "aggregate" trade id
        #   which is different from actual trade id
        # - setting both fromId and time window results in error
        #
        # aggregate trades
        #
        #     [
        #         {
        #             "a": 26129,         # Aggregate tradeId
        #             "f": 27781,         # First tradeId
        #             "l": 27781,         # Last tradeId
        #             "M": True,           # Was the trade the best price match?
        #             "m": True,          # Was the buyer the maker?
        #             "p": "0.01633102",  # Price
        #             "q": "4.70443515",  # Quantity
        #             "T": 1498793709153,  # Timestamp
        #         }
        #     ]
        #
        # inverse(swap & future)
        #
        #     [
        #      {
        #         "a": "269772814",
        #         "f": "662149354",
        #         "l": "662149355",
        #         "m": False,
        #         "p": "25864.1",
        #         "q": "3",
        #         "T": "1694209776022",
        #      },
        #     ]
        #
        # recent public trades and historical public trades
        #
        #     [
        #         {
        #             "id": 28457,
        #             "isBestMatch": True,
        #             "isBuyerMaker": True,
        #             "price": "4.00000100",
        #             "qty": "12.00000000",
        #             "time": 1499865549590,
        #         }
        #     ]
        #
        # options(eapi)
        #
        #     [
        #         {
        #             "id": 1,
        #             "price": "35.5",
        #             "qty": "0.03",
        #             "quoteQty": "1.065",
        #             "side": 1,
        #             "symbol": "ETH-230216-1500-C",
        #             "time": 1676366446072,
        #         },
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def edit_spot_order(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
 @ignore
        edit a trade order

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#cancel-an-existing-order-and-send-a-new-order-trade

        :param str id: cancel order id
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if not market['spot']:
            raise NotSupported(self.id + ' editSpotOrder() does not support ' + market['type'] + ' orders')
        payload = self.edit_spot_order_request(id, symbol, type, side, amount, price, params)
        response = self.privatePostOrderCancelReplace(payload)
        #
        # spot
        #
        #     {
        #         "cancelResponse": {
        #             "clientOrderId": "Azt6foVTTgHPNhqBf41TTt",
        #             "cummulativeQuoteQty": "0.00000000",
        #             "executedQty": "0.00000000",
        #             "orderId": 16383156620,
        #             "orderListId": -1,
        #             "origClientOrderId": "web_3f6286480b194b079870ac75fb6978b7",
        #             "origQty": "0.00110000",
        #             "price": "14000.00000000",
        #             "side": "BUY",
        #             "status": "CANCELED",
        #             "symbol": "BTCUSDT",
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #         },
        #         "cancelResult": "SUCCESS",
        #         "newOrderResponse": {
        #             "clientOrderId": "x-R4BD3S8222ecb58eb9074fb1be018c",
        #             "cummulativeQuoteQty": "0.00000000",
        #             "executedQty": "0.00000000",
        #             "fills": [],
        #             "orderId": 16383176297,
        #             "orderListId": -1,
        #             "origQty": "0.00085000",
        #             "price": "13500.00000000",
        #             "side": "BUY",
        #             "status": "NEW",
        #             "symbol": "BTCUSDT",
        #             "timeInForce": "GTC",
        #             "transactTime": 1670891847932,
        #             "type": "LIMIT",
        #         },
        #         "newOrderResult": "SUCCESS",
        #     }
        #
        data = self.safe_dict(response, 'newOrderResponse')
        return self.parse_order(data, market)

    def edit_spot_order_request(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
 @ignore
        helper function to build request for editSpotOrder
        :param str id: order id to be edited
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :returns dict: request to be sent to the exchange
        """
        market = self.market(symbol)
        clientOrderId = self.safe_string_n(params, ['newClientOrderId', 'clientOrderId', 'origClientOrderId'])
        request: dict = {
            'symbol': market['id'],
            'side': side.upper(),
        }
        initialUppercaseType = type.upper()
        uppercaseType = initialUppercaseType
        postOnly = self.is_post_only(initialUppercaseType == 'MARKET', initialUppercaseType == 'LIMIT_MAKER', params)
        if postOnly:
            uppercaseType = 'LIMIT_MAKER'
        request['type'] = uppercaseType
        triggerPrice = self.safe_number_2(params, 'stopPrice', 'triggerPrice')
        if triggerPrice is not None:
            if uppercaseType == 'MARKET':
                uppercaseType = 'STOP_LOSS'
            elif uppercaseType == 'LIMIT':
                uppercaseType = 'STOP_LOSS_LIMIT'
        validOrderTypes = self.safe_list(market['info'], 'orderTypes')
        if not self.in_array(uppercaseType, validOrderTypes):
            if initialUppercaseType != uppercaseType:
                raise InvalidOrder(self.id + ' triggerPrice parameter is not allowed for ' + symbol + ' ' + type + ' orders')
            else:
                raise InvalidOrder(self.id + ' ' + type + ' is not a valid order type for the ' + symbol + ' market')
        if clientOrderId is None:
            broker = self.safe_dict(self.options, 'broker')
            if broker is not None:
                brokerId = self.safe_string(broker, 'spot')
                if brokerId is not None:
                    request['newClientOrderId'] = brokerId + self.uuid22()
        else:
            request['newClientOrderId'] = clientOrderId
        request['newOrderRespType'] = self.safe_value(self.options['newOrderRespType'], type, 'RESULT')  # 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        timeInForceIsRequired = False
        priceIsRequired = False
        triggerPriceIsRequired = False
        quantityIsRequired = False
        if uppercaseType == 'MARKET':
            quoteOrderQty = self.safe_bool(self.options, 'quoteOrderQty', True)
            if quoteOrderQty:
                quoteOrderQtyNew = self.safe_value_2(params, 'quoteOrderQty', 'cost')
                precision = market['precision']['price']
                if quoteOrderQtyNew is not None:
                    request['quoteOrderQty'] = self.decimal_to_precision(quoteOrderQtyNew, TRUNCATE, precision, self.precisionMode)
                elif price is not None:
                    amountString = self.number_to_string(amount)
                    priceString = self.number_to_string(price)
                    quoteOrderQuantity = Precise.string_mul(amountString, priceString)
                    request['quoteOrderQty'] = self.decimal_to_precision(quoteOrderQuantity, TRUNCATE, precision, self.precisionMode)
                else:
                    quantityIsRequired = True
            else:
                quantityIsRequired = True
        elif uppercaseType == 'LIMIT':
            priceIsRequired = True
            timeInForceIsRequired = True
            quantityIsRequired = True
        elif (uppercaseType == 'STOP_LOSS') or (uppercaseType == 'TAKE_PROFIT'):
            triggerPriceIsRequired = True
            quantityIsRequired = True
        elif (uppercaseType == 'STOP_LOSS_LIMIT') or (uppercaseType == 'TAKE_PROFIT_LIMIT'):
            quantityIsRequired = True
            triggerPriceIsRequired = True
            priceIsRequired = True
            timeInForceIsRequired = True
        elif uppercaseType == 'LIMIT_MAKER':
            priceIsRequired = True
            quantityIsRequired = True
        if quantityIsRequired:
            request['quantity'] = self.amount_to_precision(symbol, amount)
        if priceIsRequired:
            if price is None:
                raise InvalidOrder(self.id + ' editOrder() requires a price argument for a ' + type + ' order')
            request['price'] = self.price_to_precision(symbol, price)
        if timeInForceIsRequired and (self.safe_string(params, 'timeInForce') is None):
            request['timeInForce'] = self.options['defaultTimeInForce']  # 'GTC' = Good To Cancel(default), 'IOC' = Immediate Or Cancel
        if triggerPriceIsRequired:
            if triggerPrice is None:
                raise InvalidOrder(self.id + ' editOrder() requires a triggerPrice extra param for a ' + type + ' order')
            else:
                request['stopPrice'] = self.price_to_precision(symbol, triggerPrice)
        request['cancelReplaceMode'] = 'STOP_ON_FAILURE'  # If the cancel request fails, the new order placement will not be attempted.
        cancelId = self.safe_string_2(params, 'cancelNewClientOrderId', 'cancelOrigClientOrderId')
        if cancelId is None:
            request['cancelOrderId'] = id  # user can provide either cancelOrderId, cancelOrigClientOrderId or cancelOrigClientOrderId
        # remove timeInForce from params because PO is only used by self.is_post_only and it's not a valid value for Binance
        if self.safe_string(params, 'timeInForce') == 'PO':
            params = self.omit(params, ['timeInForce'])
        params = self.omit(params, ['quoteOrderQty', 'cost', 'stopPrice', 'newClientOrderId', 'clientOrderId', 'postOnly'])
        return self.extend(request, params)

    def edit_contract_order_request(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        market = self.market(symbol)
        if not market['contract']:
            raise NotSupported(self.id + ' editContractOrder() does not support ' + market['type'] + ' orders')
        request: dict = {
            'orderId': id,
            'quantity': self.amount_to_precision(symbol, amount),
            'side': side.upper(),
            'symbol': market['id'],
        }
        clientOrderId = self.safe_string_n(params, ['newClientOrderId', 'clientOrderId', 'origClientOrderId'])
        if price is not None:
            request['price'] = self.price_to_precision(symbol, price)
        if clientOrderId is not None:
            request['origClientOrderId'] = clientOrderId
        params = self.omit(params, ['clientOrderId', 'newClientOrderId'])
        return request

    def edit_contract_order(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        edit a trade order

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Modify-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-UM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-CM-Order

        :param str id: cancel order id
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to edit an order in a portfolio margin account
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'editContractOrder', 'papi', 'portfolioMargin', False)
        if market['linear'] or isPortfolioMargin:
            if price is None:
                raise ArgumentsRequired(self.id + ' editOrder() requires a price argument for portfolio margin and linear orders')
        request = self.edit_contract_order_request(id, symbol, type, side, amount, price, params)
        response = None
        if market['linear']:
            if isPortfolioMargin:
                response = self.papiPutUmOrder(self.extend(request, params))
            else:
                response = self.fapiPrivatePutOrder(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                response = self.papiPutCmOrder(self.extend(request, params))
            else:
                response = self.dapiPrivatePutOrder(self.extend(request, params))
        #
        # swap and future
        #
        #     {
        #         "avgPrice": "0.00000",
        #         "clientOrderId": "web_pCCGp9AIHjziKLlpGpXI",
        #         "closePosition": False,
        #         "cumQty": "0",
        #         "cumQuote": "0",
        #         "executedQty": "0",
        #         "orderId": 151007482392,
        #         "origQty": "0.001",
        #         "origType": "LIMIT",
        #         "positionSide": "BOTH",
        #         "price": "25000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1684300587845,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        return self.parse_order(response, market)

    def edit_order(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: Num = None, price: Num = None, params={}):
        """
        edit a trade order

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#cancel-an-existing-order-and-send-a-new-order-trade
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Modify-Order

        :param str id: cancel order id
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to edit an order in a portfolio margin account
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if market['option']:
            raise NotSupported(self.id + ' editOrder() does not support ' + market['type'] + ' orders')
        if market['spot']:
            return self.edit_spot_order(id, symbol, type, side, amount, price, params)
        else:
            return self.edit_contract_order(id, symbol, type, side, amount, price, params)

    def parse_order_status(self, status: Str):
        statuses: dict = {
            'ACCEPTED': 'open',
            'CANCELED': 'canceled',
            'CANCELLED': 'canceled',
            'EXPIRED': 'expired',
            'EXPIRED_IN_MATCH': 'expired',
            'FILLED': 'closed',
            'NEW': 'open',
            'PARTIALLY_FILLED': 'open',
            'PENDING_CANCEL': 'canceling',  # currently unused
            'REJECTED': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        #
        # spot
        #
        #     {
        #         "clientOrderId": "myOrder1",
        #         "cummulativeQuoteQty": "0.0",
        #         "executedQty": "0.0",
        #         "icebergQty": "0.0",
        #         "isWorking": True,
        #         "orderId": 1,
        #         "origQty": "1.0",
        #         "price": "0.1",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0.0",
        #         "symbol": "LTCBTC",
        #         "time": 1499827319559,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1499827319559,
        #     }
        #
        # spot: editOrder
        #
        #     {
        #         "clientOrderId": "x-R4BD3S8222ecb58eb9074fb1be018c",
        #         "cummulativeQuoteQty": "0.00000000",
        #         "executedQty": "0.00000000",
        #         "fills": [],
        #         "orderId": 16383176297,
        #         "orderListId": -1,
        #         "origQty": "0.00085000",
        #         "price": "13500.00000000",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "transactTime": 1670891847932,
        #         "type": "LIMIT",
        #     }
        #
        # swap and future: editOrder
        #
        #     {
        #         "avgPrice": "0.00000",
        #         "clientOrderId": "web_pCCGp9AIHjziKLlpGpXI",
        #         "closePosition": False,
        #         "cumQty": "0",
        #         "cumQuote": "0",
        #         "executedQty": "0",
        #         "orderId": 151007482392,
        #         "origQty": "0.001",
        #         "origType": "LIMIT",
        #         "positionSide": "BOTH",
        #         "price": "25000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1684300587845,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # futures
        #
        #     {
        #         "clientOrderId": "myOrder1",
        #         "cumQuote": "10.0",
        #         "executedQty": "1.0",
        #         "orderId": 1,
        #         "origQty": "1.0",
        #         "price": "0.1",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0.0",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1499827319559
        #     }
        #
        # createOrder with {"newOrderRespType": "FULL"}
        #
        #     {
        #       "clientOrderId": "x-R4BD3S825e669e75b6c14f69a2c43e",
        #       "cummulativeQuoteQty": "29.47081500",
        #       "executedQty": "0.00050000",
        #       "fills": [
        #         {
        #           "commission": "0.00007050",
        #           "commissionAsset": "BNB",
        #           "price": "58941.63000000",
        #           "qty": "0.00050000",
        #           "tradeId": 737466631
        #         }
        #       ],
        #       "orderId": 5403233939,
        #       "orderListId": -1,
        #       "origQty": "0.00050000",
        #       "price": "0.00000000",
        #       "side": "BUY",
        #       "status": "FILLED",
        #       "symbol": "BTCUSDT",
        #       "timeInForce": "GTC",
        #       "transactTime": 1617151923742,
        #       "type": "MARKET",
        #     }
        #
        # delivery
        #
        #     {
        #       "avgPrice": "4522.14",
        #       "clientOrderId": "x-xcKtGhcu3e2d1503fdd543b3b02419",
        #       "closePosition": False,
        #       "cumBase": "0.00221134",
        #       "executedQty": "1",
        #       "orderId": "18742727411",
        #       "origQty": "1",
        #       "origType": "MARKET",
        #       "pair": "ETHUSD",
        #       "positionSide": "BOTH",
        #       "price": "0",
        #       "priceProtect": False,
        #       "reduceOnly": False,
        #       "side": "SELL",
        #       "status": "FILLED",
        #       "stopPrice": "0",
        #       "symbol": "ETHUSD_PERP",
        #       "time": "1636061952660",
        #       "timeInForce": "GTC",
        #       "type": "MARKET",
        #       "updateTime": "1636061952660"
        #       "workingType": "CONTRACT_PRICE",
        #     }
        #
        # option: createOrder, fetchOrder, fetchOpenOrders, fetchOrders
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "",
        #         "createTime": 1676083034462,
        #         "executedQty": "0.00",
        #         "fee": "0",
        #         "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
        #         "mmp": False,
        #         "optionSide": "CALL",
        #         "orderId": 4728833085436977152,
        #         "postOnly": False,
        #         "price": "10.0",
        #         "priceScale": 1,
        #         "quantity": "1.00",
        #         "quantityScale": 2,
        #         "quoteAsset": "USDT",
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "source": "API",
        #         "status": "ACCEPTED",
        #         "symbol": "ETH-230211-1500-C",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1676083034462,
        #     }
        #
        # cancelOrders/createOrders
        #
        #     {
        #         "code": -4005,
        #         "msg": "Quantity greater than max quantity."
        #     }
        #
        # createOrder, fetchOpenOrders, fetchOrder, cancelOrder, fetchOrders: portfolio margin linear swap and future
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcu02573c6f15e544e990057b",
        #         "cumQty": "0.000",
        #         "cumQuote": "0.00000",
        #         "executedQty": "0.000",
        #         "goodTillDate": 0,
        #         "orderId": 258649539704,
        #         "origQty": "0.010",
        #         "positionSide": "BOTH",
        #         "price": "35000.00",
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "status": "NEW"
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707110415436,
        #     }
        #
        # createOrder, fetchOpenOrders, fetchOrder, cancelOrder, fetchOrders: portfolio margin inverse swap and future
        #
        #     {
        #         "avgPrice": "0.00",
        #         "clientOrderId": "x-xcKtGhcuca5af3acfb5044198c5398",
        #         "cumBase": "0",
        #         "cumQty": "0",
        #         "executedQty": "0",
        #         "orderId": 71275227732,
        #         "origQty": "1",
        #         "pair": "ETHUSD",
        #         "positionSide": "BOTH",
        #         "price": "2000",
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW"
        #         "symbol": "ETHUSD_PERP",
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707110994334,
        #     }
        #
        # createOrder, fetchOpenOrders, fetchOpenOrder: portfolio margin linear swap and future conditional
        #
        #     {
        #         "bookTime": 1707112625879,
        #         "goodTillDate": 0,
        #         "newClientStrategyId": "x-xcKtGhcu27f109953d6e4dc0974006",
        #         "origQty": "0.010",
        #         "positionSide": "BOTH",
        #         "price": "35000.00",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE"
        #         "side": "BUY",
        #         "stopPrice": "45000.00",
        #         "strategyId": 3645916,
        #         "strategyStatus": "NEW",
        #         "strategyType": "STOP",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707112625879,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # createOrder, fetchOpenOrders: portfolio margin inverse swap and future conditional
        #
        #     {
        #         "bookTime": 1707113098840,
        #         "newClientStrategyId": "x-xcKtGhcuc6b86f053bb34933850739",
        #         "origQty": "1",
        #         "positionSide": "BOTH",
        #         "price": "2000",
        #         "priceProtect": False
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "stopPrice": "3000",
        #         "strategyId": 1423462,
        #         "strategyStatus": "NEW",
        #         "strategyType": "STOP",
        #         "symbol": "ETHUSD_PERP",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707113098840,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # createOrder, cancelAllOrders, cancelOrder: portfolio margin spot margin
        #
        #     {
        #         "clientOrderId": "x-R4BD3S82e9ef29d8346440f0b28b86",
        #         "cummulativeQuoteQty": "0.00000000",
        #         "executedQty": "0.00000000",
        #         "fills": [],
        #         "orderId": 24684460474,
        #         "origQty": "0.00100000",
        #         "price": "35000.00000000",
        #         "selfTradePreventionMode": "EXPIRE_MAKER",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "transactTime": 1707113538870,
        #         "type": "LIMIT"
        #     }
        #
        # fetchOpenOrders, fetchOrder, fetchOrders: portfolio margin spot margin
        #
        #     {
        #         "accountId": 200180970,
        #         "clientOrderId": "x-R4BD3S826f724c2a4af6425f98c7b6",
        #         "cummulativeQuoteQty": "0.00000000",
        #         "executedQty": "0.00000000",
        #         "icebergQty": "0.00000000",
        #         "isWorking": True,
        #         "orderId": 24700763749,
        #         "origQty": "0.00100000",
        #         "preventedMatchId": null,
        #         "preventedQuantity": null
        #         "price": "35000.00000000",
        #         "selfTradePreventionMode": "EXPIRE_MAKER",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0.00000000",
        #         "symbol": "BTCUSDT",
        #         "time": 1707199187679,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707199187679,
        #     }
        #
        # cancelOrder: portfolio margin linear and inverse swap conditional
        #
        #     {
        #         "activatePrice": null,  # only return with trailing orders
        #         "bookTime": 1707270098774,
        #         "goodTillDate": 0,
        #         "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
        #         "origQty": "0.010",
        #         "positionSide": "BOTH",
        #         "price": "35000.00",
        #         "priceProtect": False,
        #         "priceRate": null,      # only return with trailing orders
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "stopPrice": "50000.00",  # ignored with trailing orders
        #         "strategyId": 3733211,
        #         "strategyStatus": "CANCELED",
        #         "strategyType": "STOP",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707270119261,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # fetchOrders: portfolio margin linear and inverse swap conditional
        #
        #     {
        #         "bookTime": 1707270098774,
        #         "goodTillDate": 0,
        #         "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
        #         "orderId": 0,
        #         "origQty": "0.010",
        #         "positionSide": "BOTH",
        #         "price": "35000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE"
        #         "side": "BUY",
        #         "stopPrice": "50000",
        #         "strategyId": 3733211,
        #         "strategyStatus": "CANCELLED",
        #         "strategyType": "STOP",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "triggerTime": 0,
        #         "type": "LIMIT",
        #         "updateTime": 1707270119261,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # fetchOpenOrder: linear swap
        #
        #     {
        #         "avgPrice": "0.00000",
        #         "clientOrderId": "x-xcKtGhcufb20c5a7761a4aa09aa156",
        #         "closePosition": False,
        #         "cumQuote": "0.00000",
        #         "executedQty": "0.000",
        #         "goodTillDate": 0,
        #         "orderId": 3697213934,
        #         "origQty": "0.010",
        #         "origType": "LIMIT",
        #         "positionSide": "BOTH",
        #         "price": "33000.00",
        #         "priceMatch": "NONE",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0.00",
        #         "symbol": "BTCUSDT",
        #         "time": 1707892893502,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707892893515
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # fetchOpenOrder: inverse swap
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcubbde7ba93b1a4ab881eff3",
        #         "closePosition": False,
        #         "cumBase": "0",
        #         "executedQty": "0",
        #         "orderId": 597368542,
        #         "origQty": "1",
        #         "origType": "LIMIT",
        #         "pair": "BTCUSD",
        #         "positionSide": "BOTH",
        #         "price": "35000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSD_PERP",
        #         "time": 1707893453199,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707893453199
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # fetchOpenOrder: linear portfolio margin
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcu6278f1adbdf14f74ab432e",
        #         "cumQuote": "0",
        #         "executedQty": "0",
        #         "goodTillDate": 0,
        #         "orderId": 264895013409,
        #         "origQty": "0.010",
        #         "origType": "LIMIT",
        #         "positionSide": "LONG",
        #         "price": "35000",
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE"
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "BTCUSDT",
        #         "time": 1707893839364,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707893839364,
        #     }
        #
        # fetchOpenOrder: inverse portfolio margin
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcuec11030474204ab08ba2c2",
        #         "cumBase": "0",
        #         "executedQty": "0",
        #         "orderId": 71790316950,
        #         "origQty": "1",
        #         "origType": "LIMIT",
        #         "pair": "ETHUSD",
        #         "positionSide": "LONG",
        #         "price": "2500",
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "ETHUSD_PERP",
        #         "time": 1707894181694,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707894181694
        #     }
        #
        # fetchOpenOrder: inverse portfolio margin conditional
        #
        #     {
        #         "bookTime": 1707894782679,
        #         "newClientStrategyId": "x-xcKtGhcu2da9c765294b433994ffce",
        #         "origQty": "1",
        #         "positionSide": "LONG",
        #         "price": "2500",
        #         "priceProtect": False
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "stopPrice": "4000",
        #         "strategyId": 1423501,
        #         "strategyStatus": "NEW",
        #         "strategyType": "STOP",
        #         "symbol": "ETHUSD_PERP",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707894782679,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        code = self.safe_string(order, 'code')
        if code is not None:
            # cancelOrders/createOrders might have a partial success
            return self.safe_order({'info': order, 'status': 'rejected'}, market)
        status = self.parse_order_status(self.safe_string_2(order, 'status', 'strategyStatus'))
        marketId = self.safe_string(order, 'symbol')
        isContract = ('positionSide' in order) or ('cumQuote' in order)
        marketType = 'contract' if isContract else 'spot'
        symbol = self.safe_symbol(marketId, market, None, marketType)
        filled = self.safe_string(order, 'executedQty', '0')
        timestamp = self.safe_integer_n(order, ['time', 'createTime', 'workingTime', 'transactTime', 'updateTime'])  # order of the keys matters here
        lastTradeTimestamp = None
        if ('transactTime' in order) or ('updateTime' in order):
            timestampValue = self.safe_integer_2(order, 'updateTime', 'transactTime')
            if status == 'open':
                if Precise.string_gt(filled, '0'):
                    lastTradeTimestamp = timestampValue
            elif status == 'closed':
                lastTradeTimestamp = timestampValue
        lastUpdateTimestamp = self.safe_integer_2(order, 'transactTime', 'updateTime')
        average = self.safe_string(order, 'avgPrice')
        price = self.safe_string(order, 'price')
        amount = self.safe_string_2(order, 'origQty', 'quantity')
        # - Spot/Margin market: cummulativeQuoteQty
        # - Futures market: cumQuote.
        #   Note self is not the actual cost, since Binance futures uses leverage to calculate margins.
        cost = self.safe_string_2(order, 'cummulativeQuoteQty', 'cumQuote')
        cost = self.safe_string(order, 'cumBase', cost)
        type = self.safe_string_lower(order, 'type')
        side = self.safe_string_lower(order, 'side')
        fills = self.safe_list(order, 'fills', [])
        timeInForce = self.safe_string(order, 'timeInForce')
        if timeInForce == 'GTX':
            # GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = 'PO'
        postOnly = (type == 'limit_maker') or (timeInForce == 'PO')
        if type == 'limit_maker':
            type = 'limit'
        stopPriceString = self.safe_string(order, 'stopPrice')
        triggerPrice = self.parse_number(self.omit_zero(stopPriceString))
        feeCost = self.safe_number(order, 'fee')
        fee = None
        if feeCost is not None:
            fee = {
                'currency': self.safe_string(order, 'quoteAsset'),
                'cost': feeCost,
                'rate': None,
            }
        return self.safe_order({
            'amount': amount,
            'average': average,
            'clientOrderId': self.safe_string_2(order, 'clientOrderId', 'newClientStrategyId'),
            'cost': cost,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
            'filled': filled,
            'id': self.safe_string_2(order, 'strategyId', 'orderId'),
            'info': order,
            'lastTradeTimestamp': lastTradeTimestamp,
            'lastUpdateTimestamp': lastUpdateTimestamp,
            'postOnly': postOnly,
            'price': price,
            'reduceOnly': self.safe_bool(order, 'reduceOnly'),
            'remaining': None,
            'side': side,
            'status': status,
            'symbol': symbol,
            'timeInForce': timeInForce,
            'timestamp': timestamp,
            'trades': fills,
            'triggerPrice': triggerPrice,
            'type': type,
        }, market)

    def create_orders(self, orders: List[OrderRequest], params={}):
        """
        *contract only* create a list of trade orders

        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Place-Multiple-Orders
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Place-Multiple-Orders

        :param Array orders: list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        ordersRequests = []
        orderSymbols = []
        for i in range(0, len(orders)):
            rawOrder = orders[i]
            marketId = self.safe_string(rawOrder, 'symbol')
            orderSymbols.append(marketId)
            type = self.safe_string(rawOrder, 'type')
            side = self.safe_string(rawOrder, 'side')
            amount = self.safe_value(rawOrder, 'amount')
            price = self.safe_value(rawOrder, 'price')
            orderParams = self.safe_dict(rawOrder, 'params', {})
            orderRequest = self.create_order_request(marketId, type, side, amount, price, orderParams)
            ordersRequests.append(orderRequest)
        orderSymbols = self.market_symbols(orderSymbols, None, False, True, True)
        market = self.market(orderSymbols[0])
        if market['spot']:
            raise NotSupported(self.id + ' createOrders() does not support ' + market['type'] + ' orders')
        response = None
        request: dict = {
            'batchOrders': ordersRequests,
        }
        request = self.extend(request, params)
        if market['linear']:
            response = self.fapiPrivatePostBatchOrders(request)
        elif market['option']:
            response = self.eapiPrivatePostBatchOrders(request)
        else:
            response = self.dapiPrivatePostBatchOrders(request)
        #
        #   [
        #       {
        #          "code": -4005,
        #          "msg": "Quantity greater than max quantity."
        #       },
        #       {
        #          "avgPrice": "0.00",
        #          "clientOrderId": "x-xcKtGhcu32184eb13585491289bbaf",
        #          "closePosition": False,
        #          "cumQty": "0.000",
        #          "cumQuote": "0.00000",
        #          "executedQty": "0.000",
        #          "goodTillDate": 0,
        #          "orderId": 650640530,
        #          "origQty": "0.100",
        #          "origType": "LIMIT",
        #          "positionSide": "BOTH",
        #          "price": "54.00",
        #          "priceMatch": "NONE",
        #          "priceProtect": False,
        #          "reduceOnly": False,
        #          "selfTradePreventionMode": "NONE",
        #          "side": "BUY",
        #          "status": "NEW",
        #          "stopPrice": "0.00",
        #          "symbol": "LTCUSDT",
        #          "timeInForce": "GTC",
        #          "type": "LIMIT",
        #          "updateTime": 1698073926929
        #          "workingType": "CONTRACT_PRICE",
        #       }
        #   ]
        #
        return self.parse_orders(response)

    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        create a trade order

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#new-order-trade
        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/New-Order
        https://developers.binance.com/docs/derivatives/option/trade/New-Order
        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#sor
        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-using-sor-trade
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-Margin-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Conditional-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Conditional-Order

        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of you want to trade in units of the base currency
        :param float [price]: the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.reduceOnly]: for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to True or in hedge mode. For spot margin and option reduceOnly is a boolean.
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :param boolean [params.sor]: *spot only* whether to use SOR(Smart Order Routing) or not, default is False
        :param boolean [params.test]: *spot only* whether to use the test endpoint or not, default is False
        :param float [params.trailingPercent]: the percent to trail away from the current market price
        :param float [params.trailingTriggerPrice]: the price to trigger a trailing order, default uses the price argument
        :param float [params.triggerPrice]: the price that a trigger order is triggered at
        :param float [params.stopLossPrice]: the price that a stop loss order is triggered at
        :param float [params.takeProfitPrice]: the price that a take profit order is triggered at
        :param boolean [params.portfolioMargin]: set to True if you would like to create an order in a portfolio margin account
        :param str [params.stopLossOrTakeProfit]: 'stopLoss' or 'takeProfit', required for spot trailing orders
        :param str [params.positionSide]: *swap and portfolio margin only* "BOTH" for one-way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
        :param bool [params.hedged]: *swap and portfolio margin only* True for hedged mode, False for one way mode, default is False
        :param float [params.cost]: *spot market buy only* the quote quantity that can be used alternative for the amount
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        marketType = self.safe_string(params, 'type', market['type'])
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('createOrder', params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'createOrder', 'papi', 'portfolioMargin', False)
        triggerPrice = self.safe_string_2(params, 'triggerPrice', 'stopPrice')
        stopLossPrice = self.safe_string(params, 'stopLossPrice')
        takeProfitPrice = self.safe_string(params, 'takeProfitPrice')
        trailingPercent = self.safe_string_2(params, 'trailingPercent', 'callbackRate')
        isTrailingPercentOrder = trailingPercent is not None
        isStopLoss = stopLossPrice is not None
        isTakeProfit = takeProfitPrice is not None
        isConditional = (triggerPrice is not None) or isTrailingPercentOrder or isStopLoss or isTakeProfit
        sor = self.safe_bool_2(params, 'sor', 'SOR', False)
        test = self.safe_bool(params, 'test', False)
        params = self.omit(params, ['sor', 'SOR', 'test'])
        if isPortfolioMargin:
            params['portfolioMargin'] = isPortfolioMargin
        request = self.create_order_request(symbol, type, side, amount, price, params)
        response = None
        if market['option']:
            response = self.eapiPrivatePostOrder(request)
        elif sor:
            if test:
                response = self.privatePostSorOrderTest(request)
            else:
                response = self.privatePostSorOrder(request)
        elif market['linear']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiPostUmConditionalOrder(request)
                else:
                    response = self.papiPostUmOrder(request)
            else:
                response = self.fapiPrivatePostOrder(request)
        elif market['inverse']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiPostCmConditionalOrder(request)
                else:
                    response = self.papiPostCmOrder(request)
            else:
                response = self.dapiPrivatePostOrder(request)
        elif marketType == 'margin' or marginMode is not None or isPortfolioMargin:
            if isPortfolioMargin:
                response = self.papiPostMarginOrder(request)
            else:
                response = self.sapiPostMarginOrder(request)
        else:
            if test:
                response = self.privatePostOrderTest(request)
            else:
                response = self.privatePostOrder(request)
        return self.parse_order(response, market)

    def create_order_request(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
 @ignore
        helper function to build the request
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency
        :param float [price]: the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: request to be sent to the exchange
        """
        market = self.market(symbol)
        marketType = self.safe_string(params, 'type', market['type'])
        clientOrderId = self.safe_string_2(params, 'newClientOrderId', 'clientOrderId')
        initialUppercaseType = type.upper()
        isMarketOrder = initialUppercaseType == 'MARKET'
        isLimitOrder = initialUppercaseType == 'LIMIT'
        request: dict = {
            'symbol': market['id'],
            'side': side.upper(),
        }
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'createOrder', 'papi', 'portfolioMargin', False)
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('createOrder', params)
        reduceOnly = self.safe_bool(params, 'reduceOnly', False)
        if reduceOnly:
            if marketType == 'margin' or (not market['contract'] and (marginMode is not None)):
                params = self.omit(params, 'reduceOnly')
                request['sideEffectType'] = 'AUTO_REPAY'
        triggerPrice = self.safe_string_2(params, 'triggerPrice', 'stopPrice')
        stopLossPrice = self.safe_string(params, 'stopLossPrice', triggerPrice)  # fallback to stopLoss
        takeProfitPrice = self.safe_string(params, 'takeProfitPrice')
        trailingDelta = self.safe_string(params, 'trailingDelta')
        trailingTriggerPrice = self.safe_string_2(params, 'trailingTriggerPrice', 'activationPrice')
        trailingPercent = self.safe_string_n(params, ['trailingPercent', 'callbackRate', 'trailingDelta'])
        priceMatch = self.safe_string(params, 'priceMatch')
        isTrailingPercentOrder = trailingPercent is not None
        isStopLoss = stopLossPrice is not None or trailingDelta is not None
        isTakeProfit = takeProfitPrice is not None
        isTriggerOrder = triggerPrice is not None
        isConditional = isTriggerOrder or isTrailingPercentOrder or isStopLoss or isTakeProfit
        isPortfolioMarginConditional = (isPortfolioMargin and isConditional)
        isPriceMatch = priceMatch is not None
        uppercaseType = type.upper()
        stopPrice = None
        if isTrailingPercentOrder:
            if market['swap']:
                uppercaseType = 'TRAILING_STOP_MARKET'
                request['callbackRate'] = trailingPercent
                if trailingTriggerPrice is not None:
                    request['activationPrice'] = self.price_to_precision(symbol, trailingTriggerPrice)
            else:
                if isMarketOrder:
                    raise InvalidOrder(self.id + ' trailingPercent orders are not supported for ' + symbol + ' ' + type + ' orders')
                stopLossOrTakeProfit = self.safe_string(params, 'stopLossOrTakeProfit')
                params = self.omit(params, 'stopLossOrTakeProfit')
                if stopLossOrTakeProfit != 'stopLoss' and stopLossOrTakeProfit != 'takeProfit':
                    raise InvalidOrder(self.id + symbol + ' trailingPercent orders require a stopLossOrTakeProfit parameter of either stopLoss or takeProfit')
                if stopLossOrTakeProfit == 'stopLoss':
                    uppercaseType = 'STOP_LOSS_LIMIT'
                elif stopLossOrTakeProfit == 'takeProfit':
                    uppercaseType = 'TAKE_PROFIT_LIMIT'
                if trailingTriggerPrice is not None:
                    stopPrice = self.price_to_precision(symbol, trailingTriggerPrice)
                trailingPercentConverted = Precise.string_mul(trailingPercent, '100')
                request['trailingDelta'] = trailingPercentConverted
        elif isStopLoss:
            stopPrice = stopLossPrice
            if isMarketOrder:
                # spot STOP_LOSS market orders are not a valid order type
                uppercaseType = 'STOP_MARKET' if market['contract'] else 'STOP_LOSS'
            elif isLimitOrder:
                uppercaseType = 'STOP' if market['contract'] else 'STOP_LOSS_LIMIT'
        elif isTakeProfit:
            stopPrice = takeProfitPrice
            if isMarketOrder:
                # spot TAKE_PROFIT market orders are not a valid order type
                uppercaseType = 'TAKE_PROFIT_MARKET' if market['contract'] else 'TAKE_PROFIT'
            elif isLimitOrder:
                uppercaseType = 'TAKE_PROFIT' if market['contract'] else 'TAKE_PROFIT_LIMIT'
        if market['option']:
            if type == 'market':
                raise InvalidOrder(self.id + ' ' + type + ' is not a valid order type for the ' + symbol + ' market')
        else:
            validOrderTypes = self.safe_list(market['info'], 'orderTypes')
            if not self.in_array(uppercaseType, validOrderTypes):
                if initialUppercaseType != uppercaseType:
                    raise InvalidOrder(self.id + ' triggerPrice parameter is not allowed for ' + symbol + ' ' + type + ' orders')
                else:
                    raise InvalidOrder(self.id + ' ' + type + ' is not a valid order type for the ' + symbol + ' market')
        clientOrderIdRequest = 'newClientStrategyId' if isPortfolioMarginConditional else 'newClientOrderId'
        if clientOrderId is None:
            broker = self.safe_dict(self.options, 'broker', {})
            defaultId = 'x-xcKtGhcu' if (market['contract']) else 'x-R4BD3S82'
            brokerId = self.safe_string(broker, marketType, defaultId)
            request[clientOrderIdRequest] = brokerId + self.uuid22()
        else:
            request[clientOrderIdRequest] = clientOrderId
        postOnly = None
        if not isPortfolioMargin:
            postOnly = self.is_post_only(isMarketOrder, initialUppercaseType == 'LIMIT_MAKER', params)
            if market['spot'] or marketType == 'margin':
                # only supported for spot/margin api(all margin markets are spot markets)
                if postOnly:
                    uppercaseType = 'LIMIT_MAKER'
                if marginMode == 'isolated':
                    request['isIsolated'] = True
        else:
            postOnly = self.is_post_only(isMarketOrder, initialUppercaseType == 'LIMIT_MAKER', params)
            if postOnly:
                if not market['contract']:
                    uppercaseType = 'LIMIT_MAKER'
                else:
                    request['timeInForce'] = 'GTX'
        # handle newOrderRespType response type
        if ((marketType == 'spot') or (marketType == 'margin')) and not isPortfolioMargin:
            request['newOrderRespType'] = self.safe_string(self.options['newOrderRespType'], type, 'FULL')  # 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        else:
            # swap, futures and options
            request['newOrderRespType'] = 'RESULT'  # "ACK", "RESULT", default "ACK"
        typeRequest = 'strategyType' if isPortfolioMarginConditional else 'type'
        request[typeRequest] = uppercaseType
        # additional required fields depending on the order type
        closePosition = self.safe_bool(params, 'closePosition', False)
        timeInForceIsRequired = False
        priceIsRequired = False
        triggerPriceIsRequired = False
        quantityIsRequired = False
        #
        # spot/margin
        #
        #     LIMIT                timeInForce, quantity, price
        #     LIMIT_MAKER          quantity, price
        #     MARKET               quantity or quoteOrderQty
        #     STOP_LOSS            quantity, stopPrice
        #     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
        #     TAKE_PROFIT          quantity, stopPrice
        #     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
        #
        # futures
        #
        #     LIMIT                timeInForce, quantity, price
        #     MARKET               quantity
        #     STOP/TAKE_PROFIT     quantity, price, stopPrice
        #     STOP_MARKET          stopPrice
        #     TAKE_PROFIT_MARKET   stopPrice
        #     TRAILING_STOP_MARKET callbackRate
        #
        if uppercaseType == 'MARKET':
            if market['spot']:
                quoteOrderQty = self.safe_bool(self.options, 'quoteOrderQty', True)
                if quoteOrderQty:
                    quoteOrderQtyNew = self.safe_string_2(params, 'quoteOrderQty', 'cost')
                    precision = market['precision']['price']
                    if quoteOrderQtyNew is not None:
                        request['quoteOrderQty'] = self.decimal_to_precision(quoteOrderQtyNew, TRUNCATE, precision, self.precisionMode)
                    elif price is not None:
                        amountString = self.number_to_string(amount)
                        priceString = self.number_to_string(price)
                        quoteOrderQuantity = Precise.string_mul(amountString, priceString)
                        request['quoteOrderQty'] = self.decimal_to_precision(quoteOrderQuantity, TRUNCATE, precision, self.precisionMode)
                    else:
                        quantityIsRequired = True
                else:
                    quantityIsRequired = True
            else:
                quantityIsRequired = True
        elif uppercaseType == 'LIMIT':
            priceIsRequired = True
            timeInForceIsRequired = True
            quantityIsRequired = True
        elif (uppercaseType == 'STOP_LOSS') or (uppercaseType == 'TAKE_PROFIT'):
            triggerPriceIsRequired = True
            quantityIsRequired = True
            if market['linear'] or market['inverse']:
                priceIsRequired = True
        elif (uppercaseType == 'STOP_LOSS_LIMIT') or (uppercaseType == 'TAKE_PROFIT_LIMIT'):
            quantityIsRequired = True
            triggerPriceIsRequired = True
            priceIsRequired = True
            timeInForceIsRequired = True
        elif uppercaseType == 'LIMIT_MAKER':
            priceIsRequired = True
            quantityIsRequired = True
        elif uppercaseType == 'STOP':
            quantityIsRequired = True
            triggerPriceIsRequired = True
            priceIsRequired = True
        elif (uppercaseType == 'STOP_MARKET') or (uppercaseType == 'TAKE_PROFIT_MARKET'):
            if not closePosition:
                quantityIsRequired = True
            triggerPriceIsRequired = True
        elif uppercaseType == 'TRAILING_STOP_MARKET':
            if not closePosition:
                quantityIsRequired = True
            if trailingPercent is None:
                raise InvalidOrder(self.id + ' createOrder() requires a trailingPercent param for a ' + type + ' order')
        if quantityIsRequired:
            # portfolio margin has a different amount precision
            if isPortfolioMargin:
                request['quantity'] = self.parse_to_numeric(amount)
            else:
                marketAmountPrecision = self.safe_string(market['precision'], 'amount')
                isPrecisionAvailable = (marketAmountPrecision is not None)
                if isPrecisionAvailable:
                    request['quantity'] = self.amount_to_precision(symbol, amount)
                else:
                    request['quantity'] = self.parse_to_numeric(amount)  # some options don't have the precision available
        if priceIsRequired and not isPriceMatch:
            if price is None:
                raise InvalidOrder(self.id + ' createOrder() requires a price argument for a ' + type + ' order')
            pricePrecision = self.safe_string(market['precision'], 'price')
            isPricePrecisionAvailable = (pricePrecision is not None)
            if isPricePrecisionAvailable:
                request['price'] = self.price_to_precision(symbol, price)
            else:
                request['price'] = self.parse_to_numeric(price)  # some options don't have the precision available
        if triggerPriceIsRequired:
            if market['contract']:
                if stopPrice is None:
                    raise InvalidOrder(self.id + ' createOrder() requires a triggerPrice extra param for a ' + type + ' order')
            else:
                # check for delta price
                if trailingDelta is None and stopPrice is None and trailingPercent is None:
                    raise InvalidOrder(self.id + ' createOrder() requires a triggerPrice, trailingDelta or trailingPercent param for a ' + type + ' order')
            if stopPrice is not None:
                request['stopPrice'] = self.price_to_precision(symbol, stopPrice)
        if timeInForceIsRequired and (self.safe_string(params, 'timeInForce') is None) and (self.safe_string(request, 'timeInForce') is None):
            request['timeInForce'] = self.options['defaultTimeInForce']  # 'GTC' = Good To Cancel(default), 'IOC' = Immediate Or Cancel
        if not isPortfolioMargin and market['contract'] and postOnly:
            request['timeInForce'] = 'GTX'
        # remove timeInForce from params because PO is only used by self.is_post_only and it's not a valid value for Binance
        if self.safe_string(params, 'timeInForce') == 'PO':
            params = self.omit(params, 'timeInForce')
        hedged = self.safe_bool(params, 'hedged', False)
        if not market['spot'] and not market['option'] and hedged:
            if reduceOnly:
                params = self.omit(params, 'reduceOnly')
                side = 'sell' if (side == 'buy') else 'buy'
            request['positionSide'] = 'LONG' if (side == 'buy') else 'SHORT'
        requestParams = self.omit(params, ['type', 'newClientOrderId', 'clientOrderId', 'postOnly', 'stopLossPrice', 'takeProfitPrice', 'stopPrice', 'triggerPrice', 'trailingTriggerPrice', 'trailingPercent', 'quoteOrderQty', 'cost', 'test', 'hedged'])
        return self.extend(request, requestParams)

    def create_market_order_with_cost(self, symbol: str, side: OrderSide, cost: float, params={}):
        """
        create a market order by providing the symbol, side and cost

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#new-order-trade

        :param str symbol: unified symbol of the market to create an order in
        :param str side: 'buy' or 'sell'
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if not market['spot']:
            raise NotSupported(self.id + ' createMarketOrderWithCost() supports spot orders only')
        req = {
            'cost': cost,
        }
        return self.create_order(symbol, 'market', side, 0, None, self.extend(req, params))

    def create_market_buy_order_with_cost(self, symbol: str, cost: float, params={}):
        """
        create a market buy order by providing the symbol and cost

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#new-order-trade

        :param str symbol: unified symbol of the market to create an order in
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if not market['spot']:
            raise NotSupported(self.id + ' createMarketBuyOrderWithCost() supports spot orders only')
        req = {
            'cost': cost,
        }
        return self.create_order(symbol, 'market', 'buy', 0, None, self.extend(req, params))

    def create_market_sell_order_with_cost(self, symbol: str, cost: float, params={}):
        """
        create a market sell order by providing the symbol and cost

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#new-order-trade

        :param str symbol: unified symbol of the market to create an order in
        :param float cost: how much you want to trade in units of the quote currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if not market['spot']:
            raise NotSupported(self.id + ' createMarketSellOrderWithCost() supports spot orders only')
        params['quoteOrderQty'] = cost
        return self.create_order(symbol, 'market', 'sell', cost, None, params)

    def fetch_order(self, id: str, symbol: Str = None, params={}):
        """
        fetches information on an order made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#query-order-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Query-Order
        https://developers.binance.com/docs/derivatives/option/trade/Query-Single-Order
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-UM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-CM-Order

        :param str id: the order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch an order in a portfolio margin account
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'fetchOrder', 'defaultType', 'spot')
        type = self.safe_string(params, 'type', defaultType)
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('fetchOrder', params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchOrder', 'papi', 'portfolioMargin', False)
        request: dict = {
            'symbol': market['id'],
        }
        clientOrderId = self.safe_string_2(params, 'origClientOrderId', 'clientOrderId')
        if clientOrderId is not None:
            if market['option']:
                request['clientOrderId'] = clientOrderId
            else:
                request['origClientOrderId'] = clientOrderId
        else:
            request['orderId'] = id
        params = self.omit(params, ['type', 'clientOrderId', 'origClientOrderId'])
        response = None
        if market['option']:
            response = self.eapiPrivateGetOrder(self.extend(request, params))
        elif market['linear']:
            if isPortfolioMargin:
                response = self.papiGetUmOrder(self.extend(request, params))
            else:
                response = self.fapiPrivateGetOrder(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                response = self.papiGetCmOrder(self.extend(request, params))
            else:
                response = self.dapiPrivateGetOrder(self.extend(request, params))
        elif (type == 'margin') or (marginMode is not None) or isPortfolioMargin:
            if isPortfolioMargin:
                response = self.papiGetMarginOrder(self.extend(request, params))
            else:
                if marginMode == 'isolated':
                    request['isIsolated'] = True
                response = self.sapiGetMarginOrder(self.extend(request, params))
        else:
            response = self.privateGetOrder(self.extend(request, params))
        return self.parse_order(response, market)

    def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on multiple orders made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#all-orders-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/All-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders

        :param str symbol: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :param int [params.until]: the latest time in ms to fetch orders for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch orders in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to fetch portfolio margin account trigger or conditional orders
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a symbol argument')
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchOrders', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchOrders', symbol, since, limit, params)
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'fetchOrders', 'defaultType', market['type'])
        type = self.safe_string(params, 'type', defaultType)
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('fetchOrders', params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchOrders', 'papi', 'portfolioMargin', False)
        isConditional = self.safe_bool_n(params, ['stop', 'trigger', 'conditional'])
        params = self.omit(params, ['stop', 'trigger', 'conditional', 'type'])
        request: dict = {
            'symbol': market['id'],
        }
        request, params = self.handle_until_option('endTime', request, params)
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = None
        if market['option']:
            response = self.eapiPrivateGetHistoryOrders(self.extend(request, params))
        elif market['linear']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetUmConditionalAllOrders(self.extend(request, params))
                else:
                    response = self.papiGetUmAllOrders(self.extend(request, params))
            else:
                response = self.fapiPrivateGetAllOrders(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetCmConditionalAllOrders(self.extend(request, params))
                else:
                    response = self.papiGetCmAllOrders(self.extend(request, params))
            else:
                response = self.dapiPrivateGetAllOrders(self.extend(request, params))
        else:
            if isPortfolioMargin:
                response = self.papiGetMarginAllOrders(self.extend(request, params))
            elif type == 'margin' or marginMode is not None:
                if marginMode == 'isolated':
                    request['isIsolated'] = True
                response = self.sapiGetMarginAllOrders(self.extend(request, params))
            else:
                response = self.privateGetAllOrders(self.extend(request, params))
        #
        #  spot
        #
        #     [
        #         {
        #             "clientOrderId": "myOrder1",
        #             "cummulativeQuoteQty": "0.0",
        #             "executedQty": "0.0",
        #             "icebergQty": "0.0",
        #             "isWorking": True,
        #             "orderId": 1,
        #             "origQty": "1.0",
        #             "price": "0.1",
        #             "side": "BUY",
        #             "status": "NEW",
        #             "stopPrice": "0.0",
        #             "symbol": "LTCBTC",
        #             "time": 1499827319559,
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1499827319559,
        #         }
        #     ]
        #
        #  futures
        #
        #     [
        #         {
        #             "clientOrderId": "myOrder1",
        #             "cumQuote": "10.0",
        #             "executedQty": "1.0",
        #             "orderId": 1,
        #             "origQty": "1.0",
        #             "price": "0.1",
        #             "side": "BUY",
        #             "status": "NEW",
        #             "stopPrice": "0.0",
        #             "symbol": "BTCUSDT",
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1499827319559
        #         }
        #     ]
        #
        # options
        #
        #     [
        #         {
        #             "avgPrice": "0",
        #             "clientOrderId": "",
        #             "createTime": 1676083034462,
        #             "executedQty": "0.00",
        #             "fee": "0",
        #             "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
        #             "mmp": False,
        #             "optionSide": "CALL",
        #             "orderId": 4728833085436977152,
        #             "postOnly": False,
        #             "price": "10.0",
        #             "priceScale": 1,
        #             "quantity": "1.00",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT",
        #             "reduceOnly": False,
        #             "side": "BUY",
        #             "source": "API",
        #             "status": "ACCEPTED",
        #             "symbol": "ETH-230211-1500-C",
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1676083034462
        #         }
        #     ]
        #
        # inverse portfolio margin
        #
        #     [
        #         {
        #             "avgPrice": "0.00",
        #             "clientOrderId": "x-xcKtGhcu4b3e3d8515dd4dc5ba9ccc",
        #             "cumBase": "0",
        #             "executedQty": "0",
        #             "orderId": 71328442983,
        #             "origQty": "1",
        #             "origType": "LIMIT",
        #             "pair": "ETHUSD",
        #             "positionSide": "BOTH",
        #             "price": "2000",
        #             "reduceOnly": False,
        #             "side": "BUY",
        #             "status": "CANCELED",
        #             "symbol": "ETHUSD_PERP",
        #             "time": 1707197843046,
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1707197941373
        #         },
        #     ]
        #
        # linear portfolio margin
        #
        #     [
        #         {
        #             "avgPrice": "0.00000",
        #             "clientOrderId": "x-xcKtGhcu402881c9103f42bdb4183b",
        #             "cumQuote": "0",
        #             "executedQty": "0",
        #             "goodTillDate": 0,
        #             "orderId": 259235347005,
        #             "origQty": "0.010",
        #             "origType": "LIMIT",
        #             "positionSide": "BOTH",
        #             "price": "35000",
        #             "reduceOnly": False,
        #             "selfTradePreventionMode": "NONE",
        #             "side": "BUY",
        #             "status": "CANCELED",
        #             "symbol": "BTCUSDT",
        #             "time": 1707194702167,
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1707197804748
        #         },
        #     ]
        #
        # conditional portfolio margin
        #
        #     [
        #         {
        #             "bookTime": 1707270098774,
        #             "goodTillDate": 0,
        #             "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
        #             "orderId": 0,
        #             "origQty": "0.010",
        #             "positionSide": "BOTH",
        #             "price": "35000",
        #             "priceProtect": False,
        #             "reduceOnly": False,
        #             "selfTradePreventionMode": "NONE",
        #             "side": "BUY",
        #             "stopPrice": "50000",
        #             "strategyId": 3733211,
        #             "strategyStatus": "CANCELLED",
        #             "strategyType": "STOP",
        #             "symbol": "BTCUSDT",
        #             "timeInForce": "GTC",
        #             "triggerTime": 0,
        #             "type": "LIMIT",
        #             "updateTime": 1707270119261,
        #             "workingType": "CONTRACT_PRICE"
        #         },
        #     ]
        #
        # spot margin portfolio margin
        #
        #     [
        #         {
        #             "accountId": 200180970,
        #             "clientOrderId": "x-R4BD3S82e9ef29d8346440f0b28b86",
        #             "cummulativeQuoteQty": "0.00000000",
        #             "executedQty": "0.00000000",
        #             "icebergQty": "0.00000000",
        #             "isWorking": True,
        #             "orderId": 24684460474,
        #             "origQty": "0.00100000",
        #             "preventedMatchId": null,
        #             "preventedQuantity": null,
        #             "price": "35000.00000000",
        #             "selfTradePreventionMode": "EXPIRE_MAKER",
        #             "side": "BUY",
        #             "status": "CANCELED",
        #             "stopPrice": "0.00000000",
        #             "symbol": "BTCUSDT",
        #             "time": 1707113538870,
        #             "timeInForce": "GTC",
        #             "type": "LIMIT",
        #             "updateTime": 1707113797688
        #         },
        #     ]
        #
        return self.parse_orders(response, market, since, limit)

    def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetch all unfilled currently open orders

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#current-open-orders-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Current-All-Open-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Query-Current-Open-Option-Orders
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Conditional-Orders

        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open orders structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch open orders in the portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to fetch portfolio margin account conditional orders
        :param str [params.subType]: "linear" or "inverse"
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        market = None
        type = None
        request: dict = {}
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('fetchOpenOrders', params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchOpenOrders', 'papi', 'portfolioMargin', False)
        isConditional = self.safe_bool_n(params, ['stop', 'trigger', 'conditional'])
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
            defaultType = self.safe_string_2(self.options, 'fetchOpenOrders', 'defaultType', 'spot')
            marketType = market['type'] if ('type' in market) else defaultType
            type = self.safe_string(params, 'type', marketType)
        elif self.options['warnOnFetchOpenOrdersWithoutSymbol']:
            raise ExchangeError(self.id + ' fetchOpenOrders() WARNING: fetching open orders without specifying a symbol has stricter rate limits(10 times more for spot, 40 times more for other markets) compared to requesting with symbol argument. To acknowledge self warning, set ' + self.id + '.options["warnOnFetchOpenOrdersWithoutSymbol"] = False to suppress self warning message.')
        else:
            defaultType = self.safe_string_2(self.options, 'fetchOpenOrders', 'defaultType', 'spot')
            type = self.safe_string(params, 'type', defaultType)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchOpenOrders', market, params)
        params = self.omit(params, ['type', 'stop', 'trigger', 'conditional'])
        response = None
        if type == 'option':
            if since is not None:
                request['startTime'] = since
            if limit is not None:
                request['limit'] = limit
            response = self.eapiPrivateGetOpenOrders(self.extend(request, params))
        elif self.is_linear(type, subType):
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetUmConditionalOpenOrders(self.extend(request, params))
                else:
                    response = self.papiGetUmOpenOrders(self.extend(request, params))
            else:
                response = self.fapiPrivateGetOpenOrders(self.extend(request, params))
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetCmConditionalOpenOrders(self.extend(request, params))
                else:
                    response = self.papiGetCmOpenOrders(self.extend(request, params))
            else:
                response = self.dapiPrivateGetOpenOrders(self.extend(request, params))
        elif type == 'margin' or marginMode is not None or isPortfolioMargin:
            if isPortfolioMargin:
                response = self.papiGetMarginOpenOrders(self.extend(request, params))
            else:
                if marginMode == 'isolated':
                    request['isIsolated'] = True
                    if symbol is None:
                        raise ArgumentsRequired(self.id + ' fetchOpenOrders() requires a symbol argument for isolated markets')
                response = self.sapiGetMarginOpenOrders(self.extend(request, params))
        else:
            response = self.privateGetOpenOrders(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def fetch_open_order(self, id: str, symbol: Str = None, params={}):
        """
        fetch an open order by the id

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Current-Open-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Query-Current-Open-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Conditional-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Conditional-Order

        :param str id: order id
        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.trigger]: set to True if you would like to fetch portfolio margin account stop or conditional orders
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchOpenOrder', 'papi', 'portfolioMargin', False)
        isConditional = self.safe_bool_n(params, ['stop', 'trigger', 'conditional'])
        params = self.omit(params, ['stop', 'trigger', 'conditional'])
        isPortfolioMarginConditional = (isPortfolioMargin and isConditional)
        orderIdRequest = 'strategyId' if isPortfolioMarginConditional else 'orderId'
        request[orderIdRequest] = id
        response = None
        if market['linear']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetUmConditionalOpenOrder(self.extend(request, params))
                else:
                    response = self.papiGetUmOpenOrder(self.extend(request, params))
            else:
                response = self.fapiPrivateGetOpenOrder(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiGetCmConditionalOpenOrder(self.extend(request, params))
                else:
                    response = self.papiGetCmOpenOrder(self.extend(request, params))
            else:
                response = self.dapiPrivateGetOpenOrder(self.extend(request, params))
        else:
            if market['option']:
                raise NotSupported(self.id + ' fetchOpenOrder() does not support option markets')
            elif market['spot']:
                raise NotSupported(self.id + ' fetchOpenOrder() does not support spot markets')
        #
        # linear swap
        #
        #     {
        #         "avgPrice": "0.00000",
        #         "clientOrderId": "x-xcKtGhcufb20c5a7761a4aa09aa156",
        #         "closePosition": False,
        #         "cumQuote": "0.00000",
        #         "executedQty": "0.000",
        #         "goodTillDate": 0,
        #         "orderId": 3697213934,
        #         "origQty": "0.010",
        #         "origType": "LIMIT",
        #         "positionSide": "BOTH",
        #         "price": "33000.00",
        #         "priceMatch": "NONE",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0.00",
        #         "symbol": "BTCUSDT",
        #         "time": 1707892893502,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707892893515,
        #         "workingType": "CONTRACT_PRICE"
        #     }
        #
        # inverse swap
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcubbde7ba93b1a4ab881eff3",
        #         "closePosition": False,
        #         "cumBase": "0",
        #         "executedQty": "0",
        #         "orderId": 597368542,
        #         "origQty": "1",
        #         "origType": "LIMIT",
        #         "pair": "BTCUSD",
        #         "positionSide": "BOTH",
        #         "price": "35000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSD_PERP",
        #         "time": 1707893453199,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707893453199,
        #         "workingType": "CONTRACT_PRICE"
        #     }
        #
        # linear portfolio margin
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcu6278f1adbdf14f74ab432e",
        #         "cumQuote": "0",
        #         "executedQty": "0",
        #         "goodTillDate": 0,
        #         "orderId": 264895013409,
        #         "origQty": "0.010",
        #         "origType": "LIMIT",
        #         "positionSide": "LONG",
        #         "price": "35000",
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "BTCUSDT",
        #         "time": 1707893839364,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707893839364
        #     }
        #
        # inverse portfolio margin
        #
        #     {
        #         "avgPrice": "0",
        #         "clientOrderId": "x-xcKtGhcuec11030474204ab08ba2c2",
        #         "cumBase": "0",
        #         "executedQty": "0",
        #         "orderId": 71790316950,
        #         "origQty": "1",
        #         "origType": "LIMIT",
        #         "pair": "ETHUSD",
        #         "positionSide": "LONG",
        #         "price": "2500",
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "status": "NEW",
        #         "symbol": "ETHUSD_PERP",
        #         "time": 1707894181694,
        #         "timeInForce": "GTC",
        #         "type": "LIMIT",
        #         "updateTime": 1707894181694
        #     }
        #
        # linear portfolio margin conditional
        #
        #     {
        #         "bookTime": 1707894490094,
        #         "goodTillDate": 0,
        #         "newClientStrategyId": "x-xcKtGhcu2205fde44418483ca21874",
        #         "origQty": "0.010",
        #         "positionSide": "LONG",
        #         "price": "35000",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "selfTradePreventionMode": "NONE",
        #         "side": "BUY",
        #         "stopPrice": "60000",
        #         "strategyId": 4084339,
        #         "strategyStatus": "NEW",
        #         "strategyType": "STOP",
        #         "symbol": "BTCUSDT",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707894490094,
        #         "workingType": "CONTRACT_PRICE"
        #     }
        #
        # inverse portfolio margin conditional
        #
        #     {
        #         "bookTime": 1707894782679,
        #         "newClientStrategyId": "x-xcKtGhcu2da9c765294b433994ffce",
        #         "origQty": "1",
        #         "positionSide": "LONG",
        #         "price": "2500",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "BUY",
        #         "stopPrice": "4000",
        #         "strategyId": 1423501,
        #         "strategyStatus": "NEW",
        #         "strategyType": "STOP",
        #         "symbol": "ETHUSD_PERP",
        #         "timeInForce": "GTC",
        #         "updateTime": 1707894782679,
        #         "workingType": "CONTRACT_PRICE"
        #     }
        #
        return self.parse_order(response, market)

    def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on multiple closed orders made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#all-orders-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/All-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders

        :param str symbol: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch orders in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to fetch portfolio margin account trigger or conditional orders
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchClosedOrders() requires a symbol argument')
        orders = self.fetch_orders(symbol, since, None, params)
        filteredOrders = self.filter_by(orders, 'status', 'closed')
        return self.filter_by_since_limit(filteredOrders, since, limit)

    def fetch_canceled_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetches information on multiple canceled orders made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#all-orders-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/All-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders

        :param str symbol: unified market symbol of the market the orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch orders in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to fetch portfolio margin account trigger or conditional orders
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchCanceledOrders() requires a symbol argument')
        orders = self.fetch_orders(symbol, since, None, params)
        filteredOrders = self.filter_by(orders, 'status', 'canceled')
        return self.filter_by_since_limit(filteredOrders, since, limit)

    def fetch_canceled_and_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on multiple canceled orders made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#all-orders-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/All-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders

        :param str symbol: unified market symbol of the market the orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch orders in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to fetch portfolio margin account trigger or conditional orders
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchCanceledAndClosedOrders() requires a symbol argument')
        orders = self.fetch_orders(symbol, since, None, params)
        canceledOrders = self.filter_by(orders, 'status', 'canceled')
        closedOrders = self.filter_by(orders, 'status', 'closed')
        filteredOrders = self.array_concat(canceledOrders, closedOrders)
        sortedOrders = self.sort_by(filteredOrders, 'timestamp')
        return self.filter_by_since_limit(sortedOrders, since, limit)

    def cancel_order(self, id: str, symbol: Str = None, params={}):
        """
        cancels an open order

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#cancel-order-trade
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Cancel-Order
        https://developers.binance.com/docs/derivatives/option/trade/Cancel-Option-Order
        https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Conditional-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Conditional-Order
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-Order

        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to cancel an order in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to cancel a portfolio margin account conditional order
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'cancelOrder', 'defaultType', 'spot')
        type = self.safe_string(params, 'type', defaultType)
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('cancelOrder', params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'cancelOrder', 'papi', 'portfolioMargin', False)
        isConditional = self.safe_bool_n(params, ['stop', 'trigger', 'conditional'])
        request: dict = {
            'symbol': market['id'],
        }
        clientOrderId = self.safe_string_n(params, ['origClientOrderId', 'clientOrderId', 'newClientStrategyId'])
        if clientOrderId is not None:
            if market['option']:
                request['clientOrderId'] = clientOrderId
            else:
                if isPortfolioMargin and isConditional:
                    request['newClientStrategyId'] = clientOrderId
                else:
                    request['origClientOrderId'] = clientOrderId
        else:
            if isPortfolioMargin and isConditional:
                request['strategyId'] = id
            else:
                request['orderId'] = id
        params = self.omit(params, ['type', 'origClientOrderId', 'clientOrderId', 'newClientStrategyId', 'stop', 'trigger', 'conditional'])
        response = None
        if market['option']:
            response = self.eapiPrivateDeleteOrder(self.extend(request, params))
        elif market['linear']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiDeleteUmConditionalOrder(self.extend(request, params))
                else:
                    response = self.papiDeleteUmOrder(self.extend(request, params))
            else:
                response = self.fapiPrivateDeleteOrder(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiDeleteCmConditionalOrder(self.extend(request, params))
                else:
                    response = self.papiDeleteCmOrder(self.extend(request, params))
            else:
                response = self.dapiPrivateDeleteOrder(self.extend(request, params))
        elif (type == 'margin') or (marginMode is not None) or isPortfolioMargin:
            if isPortfolioMargin:
                response = self.papiDeleteMarginOrder(self.extend(request, params))
            else:
                if marginMode == 'isolated':
                    request['isIsolated'] = True
                response = self.sapiDeleteMarginOrder(self.extend(request, params))
        else:
            response = self.privateDeleteOrder(self.extend(request, params))
        return self.parse_order(response, market)

    def cancel_all_orders(self, symbol: Str = None, params={}):
        """
        cancel all open orders in a market

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#cancel-all-open-orders-on-a-symbol-trade
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders
        https://developers.binance.com/docs/derivatives/option/trade/Cancel-all-Option-orders-on-specific-symbol
        https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-All-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Conditional-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-All-Open-Orders-on-a-Symbol

        :param str symbol: unified market symbol of the market to cancel orders in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.marginMode]: 'cross' or 'isolated', for spot margin trading
        :param boolean [params.portfolioMargin]: set to True if you would like to cancel orders in a portfolio margin account
        :param boolean [params.trigger]: set to True if you would like to cancel portfolio margin account conditional orders
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelAllOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'cancelAllOrders', 'papi', 'portfolioMargin', False)
        isConditional = self.safe_bool_n(params, ['stop', 'trigger', 'conditional'])
        type = self.safe_string(params, 'type', market['type'])
        params = self.omit(params, ['type', 'stop', 'trigger', 'conditional'])
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('cancelAllOrders', params)
        response = None
        if market['option']:
            response = self.eapiPrivateDeleteAllOpenOrders(self.extend(request, params))
            #
            #    {
            #        "code": 0,
            #        "msg": "success"
            #    }
            #
        elif market['linear']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiDeleteUmConditionalAllOpenOrders(self.extend(request, params))
                    #
                    #    {
                    #        "code": "200",
                    #        "msg": "The operation of cancel all conditional open order is done."
                    #    }
                    #
                else:
                    response = self.papiDeleteUmAllOpenOrders(self.extend(request, params))
                    #
                    #    {
                    #        "code": 200,
                    #        "msg": "The operation of cancel all open order is done."
                    #    }
                    #
            else:
                response = self.fapiPrivateDeleteAllOpenOrders(self.extend(request, params))
                #
                #    {
                #        "code": 200,
                #        "msg": "The operation of cancel all open order is done."
                #    }
                #
        elif market['inverse']:
            if isPortfolioMargin:
                if isConditional:
                    response = self.papiDeleteCmConditionalAllOpenOrders(self.extend(request, params))
                    #
                    #    {
                    #        "code": "200",
                    #        "msg": "The operation of cancel all conditional open order is done."
                    #    }
                    #
                else:
                    response = self.papiDeleteCmAllOpenOrders(self.extend(request, params))
                    #
                    #    {
                    #        "code": 200,
                    #        "msg": "The operation of cancel all open order is done."
                    #    }
                    #
            else:
                response = self.dapiPrivateDeleteAllOpenOrders(self.extend(request, params))
                #
                #    {
                #        "code": 200,
                #        "msg": "The operation of cancel all open order is done."
                #    }
                #
        elif (type == 'margin') or (marginMode is not None) or isPortfolioMargin:
            if isPortfolioMargin:
                response = self.papiDeleteMarginAllOpenOrders(self.extend(request, params))
            else:
                if marginMode == 'isolated':
                    request['isIsolated'] = True
                response = self.sapiDeleteMarginOpenOrders(self.extend(request, params))
                #
                #    [
                #        {
                #          "symbol": "BTCUSDT",
                #          "isIsolated": True,       # if isolated margin
                #          "origClientOrderId": "E6APeyTJvkMvLMYMqu1KQ4",
                #          "orderId": 11,
                #          "orderListId": -1,
                #          "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                #          "price": "0.089853",
                #          "origQty": "0.178622",
                #          "executedQty": "0.000000",
                #          "cummulativeQuoteQty": "0.000000",
                #          "status": "CANCELED",
                #          "timeInForce": "GTC",
                #          "type": "LIMIT",
                #          "side": "BUY",
                #          "selfTradePreventionMode": "NONE"
                #        },
                #        ...
                #    ]
                #
        else:
            response = self.privateDeleteOpenOrders(self.extend(request, params))
            #
            #    [
            #        {
            #            "symbol": "ADAUSDT",
            #            "origClientOrderId": "x-R4BD3S82662cde7a90114475b86e21",
            #            "orderId": 3935107,
            #            "orderListId": -1,
            #            "clientOrderId": "bqM2w1oTlugfRAjnTIFBE8",
            #            "transactTime": 1720589016657,
            #            "price": "0.35000000",
            #            "origQty": "30.00000000",
            #            "executedQty": "0.00000000",
            #            "cummulativeQuoteQty": "0.00000000",
            #            "status": "CANCELED",
            #            "timeInForce": "GTC",
            #            "type": "LIMIT",
            #            "side": "BUY",
            #            "selfTradePreventionMode": "EXPIRE_MAKER"
            #        }
            #    ]
            #
        if isinstance(response, list):
            return self.parse_orders(response, market)
        else:
            return [
                self.safe_order({
                    'info': response,
                }),
            ]

    def cancel_orders(self, ids: List[str], symbol: Str = None, params={}):
        """
        cancel multiple orders

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Cancel-Multiple-Orders

        :param str[] ids: order ids
        :param str [symbol]: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint

 EXCHANGE SPECIFIC PARAMETERS
        :param str[] [params.origClientOrderIdList]: max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
        :param int[] [params.recvWindow]:
        :returns dict: an list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        if not market['contract']:
            raise BadRequest(self.id + ' cancelOrders is only supported for swap markets.')
        request: dict = {
            'symbol': market['id'],
            'orderidlist': ids,
        }
        response = None
        if market['linear']:
            response = self.fapiPrivateDeleteBatchOrders(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPrivateDeleteBatchOrders(self.extend(request, params))
        #
        #    [
        #        {
        #            "activatePrice": "9020",              # activation price, only return with TRAILING_STOP_MARKET order
        #            "clientOrderId": "myOrder1",
        #            "closePosition": False,               # if Close-All
        #            "cumQty": "0",
        #            "cumQuote": "0",
        #            "executedQty": "0",
        #            "goodTillDate": 0                     # order pre-set auot cancel time for TIF GTD order
        #            "orderId": 283194212,
        #            "origQty": "11",
        #            "origType": "TRAILING_STOP_MARKET",
        #            "positionSide": "SHORT",
        #            "price": "0",
        #            "priceMatch": "NONE",                 # price match mode
        #            "priceProtect": False,                # if conditional order trigger is protected
        #            "priceRate": "0.3",                   # callback rate, only return with TRAILING_STOP_MARKET order
        #            "reduceOnly": False,
        #            "selfTradePreventionMode": "NONE",    # self trading preventation mode
        #            "side": "BUY",
        #            "status": "CANCELED",
        #            "stopPrice": "9300",                  # please ignore when order type is TRAILING_STOP_MARKET
        #            "symbol": "BTCUSDT",
        #            "timeInForce": "GTC",
        #            "type": "TRAILING_STOP_MARKET",
        #            "updateTime": 1571110484038,
        #            "workingType": "CONTRACT_PRICE",
        #        },
        #        {
        #            "code": -2011,
        #            "msg": "Unknown order sent."
        #        }
        #    ]
        #
        return self.parse_orders(response, market)

    def fetch_order_trades(self, id: str, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all the trades made from a single order

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#account-trade-list-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Account-Trade-List
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List

        :param str id: order id
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trades to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrderTrades() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        type = self.safe_string(params, 'type', market['type'])
        params = self.omit(params, 'type')
        if type != 'spot':
            raise NotSupported(self.id + ' fetchOrderTrades() supports spot markets only')
        request: dict = {
            'orderId': id,
        }
        return self.fetch_my_trades(symbol, since, limit, self.extend(request, params))

    def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all trades made by the user

        https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#account-trade-list-user_data
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Account-Trade-List
        https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List
        https://developers.binance.com/docs/derivatives/option/trade/Account-Trade-List
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/UM-Account-Trade-List
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/CM-Account-Trade-List

        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trades structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param int [params.until]: the latest time in ms to fetch entries for
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch trades for a portfolio margin account
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchMyTrades', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchMyTrades', symbol, since, limit, params)
        request: dict = {}
        market = None
        type = None
        marginMode = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        type, params = self.handle_market_type_and_params('fetchMyTrades', market, params)
        endTime = self.safe_integer_2(params, 'until', 'endTime')
        if since is not None:
            startTime = since
            request['startTime'] = startTime
            # If startTime and endTime are both not sent, then the last 7 days' data will be returned.
            # The time between startTime and endTime cannot be longer than 7 days.
            # The parameter fromId cannot be sent with startTime or endTime.
            currentTimestamp = self.milliseconds()
            oneWeek = 7 * 24 * 60 * 60 * 1000
            if (currentTimestamp - startTime) >= oneWeek:
                if (endTime is None) and market['linear']:
                    endTime = self.sum(startTime, oneWeek)
                    endTime = min(endTime, currentTimestamp)
        if endTime is not None:
            request['endTime'] = endTime
            params = self.omit(params, ['endTime', 'until'])
        if limit is not None:
            if (type == 'option') or market['contract']:
                limit = min(limit, 1000)  # above 1000, returns error
            request['limit'] = limit
        response = None
        if type == 'option':
            response = self.eapiPrivateGetUserTrades(self.extend(request, params))
        else:
            if symbol is None:
                raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a symbol argument')
            marginMode, params = self.handle_margin_mode_and_params('fetchMyTrades', params)
            isPortfolioMargin = None
            isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchMyTrades', 'papi', 'portfolioMargin', False)
            if type == 'spot' or type == 'margin':
                if isPortfolioMargin:
                    response = self.papiGetMarginMyTrades(self.extend(request, params))
                elif (type == 'margin') or (marginMode is not None):
                    if marginMode == 'isolated':
                        request['isIsolated'] = True
                    response = self.sapiGetMarginMyTrades(self.extend(request, params))
                else:
                    response = self.privateGetMyTrades(self.extend(request, params))
            elif market['linear']:
                if isPortfolioMargin:
                    response = self.papiGetUmUserTrades(self.extend(request, params))
                else:
                    response = self.fapiPrivateGetUserTrades(self.extend(request, params))
            elif market['inverse']:
                if isPortfolioMargin:
                    response = self.papiGetCmUserTrades(self.extend(request, params))
                else:
                    response = self.dapiPrivateGetUserTrades(self.extend(request, params))
        #
        # spot trade
        #
        #     [
        #         {
        #             "commission": "10.10000000",
        #             "commissionAsset": "BNB",
        #             "id": 28457,
        #             "isBestMatch": True,
        #             "isBuyer": True,
        #             "isMaker": False,
        #             "orderId": 100234,
        #             "price": "4.00000100",
        #             "qty": "12.00000000",
        #             "symbol": "BNBBTC",
        #             "time": 1499865549590,
        #         }
        #     ]
        #
        # futures trade
        #
        #     [
        #         {
        #             "accountId": 20,
        #             "buyer": False,
        #             "commission": "-0.07819010",
        #             "commissionAsset": "USDT",
        #             "counterPartyId": 653,
        #             "id": 698759,
        #             "maker": False,
        #             "orderId": 25851813,
        #             "price": "7819.01",
        #             "qty": "0.002",
        #             "quoteQty": "0.01563",
        #             "realizedPnl": "-0.91539999",
        #             "side": "SELL",
        #             "symbol": "BTCUSDT",
        #             "time": 1569514978020
        #         }
        #     ]
        #
        # options(eapi)
        #
        #     [
        #         {
        #             "fee": "0.17305890",
        #             "id": 1125899906844226012,
        #             "liquidity": "MAKER",
        #             "optionSide": "CALL",
        #             "orderId": 4638761100843040768,
        #             "price": "18.70000000",
        #             "priceScale": 1,
        #             "quantity": "-0.57000000",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT"
        #             "realizedProfit": "-3.53400000",
        #             "side": "SELL",
        #             "symbol": "ETH-230211-1500-C",
        #             "time": 1676085216845,
        #             "tradeId": 73,
        #             "type": "LIMIT",
        #             "volatility": "0.30000000",
        #         }
        #     ]
        #
        # linear portfolio margin
        #
        #     [
        #         {
        #             "buyer": False,
        #             "commission": "0.18905360",
        #             "commissionAsset": "USDT",
        #             "id": 4575108247,
        #             "maker": False,
        #             "marginAsset": "USDT",
        #             "orderId": 261942655610,
        #             "positionSide": "LONG",
        #             "price": "47263.40",
        #             "qty": "0.010",
        #             "quoteQty": "472.63",
        #             "realizedPnl": "27.38400000",
        #             "side": "SELL",
        #             "symbol": "BTCUSDT",
        #             "time": 1707530039409,
        #         }
        #     ]
        #
        # inverse portfolio margin
        #
        #     [
        #         {
        #             "baseQty": "0.00400296",
        #             "buyer": False,
        #             "commission": "0.00000160",
        #             "commissionAsset": "ETH",
        #             "id": 701907838,
        #             "maker": False,
        #             "marginAsset": "ETH",
        #             "orderId": 71548909034,
        #             "pair": "ETHUSD",
        #             "positionSide": "LONG",
        #             "price": "2498.15",
        #             "qty": "1",
        #             "realizedPnl": "0.00012517",
        #             "side": "SELL",
        #             "symbol": "ETHUSD_PERP",
        #             "time": 1707530317519
        #         }
        #     ]
        #
        # spot margin portfolio margin
        #
        #     [
        #         {
        #             "commission": "0.00538800",
        #             "commissionAsset": "USDT",
        #             "id": 470227543,
        #             "isBestMatch": True,
        #             "isBuyer": False,
        #             "isMaker": False,
        #             "orderId": 4421170947,
        #             "price": "0.53880000",
        #             "qty": "10.00000000",
        #             "quoteQty": "5.38800000",
        #             "symbol": "ADAUSDT",
        #             "time": 1707545780522
        #         }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def fetch_my_dust_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all dust trades made by the user

        https://developers.binance.com/docs/wallet/asset/dust-log

        :param str symbol: not used by binance fetchMyDustTrades()
        :param int [since]: the earliest time in ms to fetch my dust trades for
        :param int [limit]: the maximum number of dust trades to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'margin', default spot
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        #
        # Binance provides an opportunity to trade insignificant(i.e. non-tradable and non-withdrawable)
        # token leftovers(of any asset) into `BNB` coin which in turn can be used to pay trading fees with it.
        # The corresponding trades history is called the `Dust Log` and can be requested via the following end-point:
        # https://github.com/binance-exchange/binance-official-api-docs/blob/master/wapi-api.md#dustlog-user_data
        #
        self.load_markets()
        request: dict = {}
        if since is not None:
            request['startTime'] = since
            request['endTime'] = self.sum(since, 7776000000)
        accountType = self.safe_string_upper(params, 'type')
        params = self.omit(params, 'type')
        if accountType is not None:
            request['accountType'] = accountType
        response = self.sapiGetAssetDribblet(self.extend(request, params))
        #     {
        #       "total": "4",
        #       "userAssetDribblets": [
        #         {
        #           "operateTime": "1627575731000",
        #           "totalServiceChargeAmount": "0.00001453",
        #           "totalTransferedAmount": "0.00072693",
        #           "transId": "70899815863",
        #           "userAssetDribbletDetails": [
        #             {
        #               "amount": "0.000006",
        #               "fromAsset": "LTC",
        #               "operateTime": "1627575731000",
        #               "serviceChargeAmount": "0.00000005",
        #               "transferedAmount": "0.00000267",
        #               "transId": "70899815863"
        #             },
        #             {
        #               "amount": "0.15949157",
        #               "fromAsset": "GBP",
        #               "operateTime": "1627575731000",
        #               "serviceChargeAmount": "0.00001448",
        #               "transferedAmount": "0.00072426",
        #               "transId": "70899815863"
        #             }
        #           ]
        #         },
        #       ]
        #     }
        results = self.safe_list(response, 'userAssetDribblets', [])
        rows = self.safe_integer(response, 'total', 0)
        data = []
        for i in range(0, rows):
            logs = self.safe_list(results[i], 'userAssetDribbletDetails', [])
            for j in range(0, len(logs)):
                logs[j]['isDustTrade'] = True
                data.append(logs[j])
        trades = self.parse_trades(data, None, since, limit)
        return self.filter_by_since_limit(trades, since, limit)

    def parse_dust_trade(self, trade, market: Market = None):
        #
        #     {
        #       "amount": "0.009669",
        #       "fromAsset": "USDT",
        #       "isDustTrade": True,
        #       "operateTime": "1628076010000",
        #       "serviceChargeAmount": "0.00000059",
        #       "transferedAmount": "0.00002992",
        #       "transId": "71416578712",
        #     }
        #
        orderId = self.safe_string(trade, 'transId')
        timestamp = self.safe_integer(trade, 'operateTime')
        currencyId = self.safe_string(trade, 'fromAsset')
        tradedCurrency = self.safe_currency_code(currencyId)
        bnb = self.currency('BNB')
        earnedCurrency = bnb['code']
        applicantSymbol = earnedCurrency + '/' + tradedCurrency
        tradedCurrencyIsQuote = False
        if applicantSymbol in self.markets:
            tradedCurrencyIsQuote = True
        feeCostString = self.safe_string(trade, 'serviceChargeAmount')
        fee = {
            'currency': earnedCurrency,
            'cost': self.parse_number(feeCostString),
        }
        symbol = None
        amountString = None
        costString = None
        side = None
        if tradedCurrencyIsQuote:
            symbol = applicantSymbol
            amountString = self.safe_string(trade, 'transferedAmount')
            costString = self.safe_string(trade, 'amount')
            side = 'buy'
        else:
            symbol = tradedCurrency + '/' + earnedCurrency
            amountString = self.safe_string(trade, 'amount')
            costString = self.safe_string(trade, 'transferedAmount')
            side = 'sell'
        priceString = None
        if costString is not None:
            if amountString:
                priceString = Precise.string_div(costString, amountString)
        id = None
        amount = self.parse_number(amountString)
        price = self.parse_number(priceString)
        cost = self.parse_number(costString)
        type = None
        takerOrMaker = None
        return {
            'amount': amount,
            'cost': cost,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
            'id': id,
            'info': trade,
            'order': orderId,
            'price': price,
            'side': side,
            'symbol': symbol,
            'takerOrMaker': takerOrMaker,
            'timestamp': timestamp,
            'type': type,
        }

    def fetch_deposits(self, code: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Transaction]:
        """
        fetch all deposits made to an account

        https://developers.binance.com/docs/wallet/capital/deposite-history
        https://developers.binance.com/docs/fiat/rest-api/Get-Fiat-Deposit-Withdraw-History

        :param str code: unified currency code
        :param int [since]: the earliest time in ms to fetch deposits for
        :param int [limit]: the maximum number of deposits structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param bool [params.fiat]: if True, only fiat deposits will be returned
        :param int [params.until]: the latest time in ms to fetch entries for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns dict[]: a list of `transaction structures <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchDeposits', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchDeposits', code, since, limit, params)
        currency = None
        response = None
        request: dict = {}
        legalMoney = self.safe_dict(self.options, 'legalMoney', {})
        fiatOnly = self.safe_bool(params, 'fiat', False)
        params = self.omit(params, 'fiatOnly')
        until = self.safe_integer(params, 'until')
        params = self.omit(params, 'until')
        if fiatOnly or (code in legalMoney):
            if code is not None:
                currency = self.currency(code)
            request['transactionType'] = 0
            if since is not None:
                request['beginTime'] = since
            if until is not None:
                request['endTime'] = until
            raw = self.sapiGetFiatOrders(self.extend(request, params))
            response = self.safe_list(raw, 'data', [])
            #     {
            #       "code": "000000",
            #       "data": [
            #         {
            #           "amount": "15.00",
            #           "createTime": 1627501026000,
            #           "fiatCurrency": "EUR",
            #           "indicatedAmount": "15.00",
            #           "method": "card",
            #           "orderNo": "25ced37075c1470ba8939d0df2316e23",
            #           "status": "Failed",
            #           "totalFee": "0.00",
            #           "updateTime": 1627501027000
            #         }
            #       ],
            #       "message": "success",
            #       "total": 1,
            #       "success": True
            #     }
        else:
            if code is not None:
                currency = self.currency(code)
                request['coin'] = currency['id']
            if since is not None:
                request['startTime'] = since
                # max 3 months range https://github.com/ccxt/ccxt/issues/6495
                endTime = self.sum(since, 7776000000)
                if until is not None:
                    endTime = min(endTime, until)
                request['endTime'] = endTime
            if limit is not None:
                request['limit'] = limit
            response = self.sapiGetCapitalDepositHisrec(self.extend(request, params))
            #     [
            #       {
            #         "address": "1NYxAJhW2281HK1KtJeaENBqHeygA88FzR",
            #         "addressTag": "",
            #         "amount": "0.01844487",
            #         "coin": "BCH",
            #         "confirmTimes": "2/2"
            #         "insertTime": 1610784980000,
            #         "network": "BCH",
            #         "status": 1,
            #         "transferType": 0,
            #         "txId": "bafc5902504d6504a00b7d0306a41154cbf1d1b767ab70f3bc226327362588af",
            #       },
            #       {
            #         "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
            #         "addressTag": "",
            #         "amount": "4500",
            #         "coin": "USDT",
            #         "confirmTimes": "1/15"
            #         "insertTime": 1618394381000,
            #         "network": "BSC",
            #         "status": 1,
            #         "transferType": 1,
            #         "txId": "Internal transfer 51376627901",
            #     }
            #   ]
        for i in range(0, len(response)):
            response[i]['type'] = 'deposit'
        return self.parse_transactions(response, currency, since, limit)

    def fetch_withdrawals(self, code: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Transaction]:
        """
        fetch all withdrawals made from an account

        https://developers.binance.com/docs/wallet/capital/withdraw-history
        https://developers.binance.com/docs/fiat/rest-api/Get-Fiat-Deposit-Withdraw-History

        :param str code: unified currency code
        :param int [since]: the earliest time in ms to fetch withdrawals for
        :param int [limit]: the maximum number of withdrawals structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param bool [params.fiat]: if True, only fiat withdrawals will be returned
        :param int [params.until]: the latest time in ms to fetch withdrawals for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns dict[]: a list of `transaction structures <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchWithdrawals', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchWithdrawals', code, since, limit, params)
        legalMoney = self.safe_dict(self.options, 'legalMoney', {})
        fiatOnly = self.safe_bool(params, 'fiat', False)
        params = self.omit(params, 'fiatOnly')
        request: dict = {}
        until = self.safe_integer(params, 'until')
        if until is not None:
            params = self.omit(params, 'until')
            request['endTime'] = until
        response = None
        currency = None
        if fiatOnly or (code in legalMoney):
            if code is not None:
                currency = self.currency(code)
            request['transactionType'] = 1
            if since is not None:
                request['beginTime'] = since
            raw = self.sapiGetFiatOrders(self.extend(request, params))
            response = self.safe_list(raw, 'data', [])
            #     {
            #       "code": "000000",
            #       "data": [
            #         {
            #           "amount": "100.00",
            #           "createTime": 1620037745000,
            #           "fiatCurrency": "GBP",
            #           "indicatedAmount": "10001.50",
            #           "method": "bank transfer",
            #           "orderNo": "CJW706452266115170304",
            #           "status": "Successful",
            #           "totalFee": "1.50",
            #           "updateTime": 1620038480000
            #         },
            #         {
            #           "amount": "100.00",
            #           "createTime": 1619998460000,
            #           "fiatCurrency": "GBP",
            #           "indicatedAmount": "10001.50",
            #           "method": "bank transfer",
            #           "orderNo": "CJW706287492781891584",
            #           "status": "Successful",
            #           "totalFee": "1.50",
            #           "updateTime": 1619998823000
            #         }
            #       ],
            #       "message": "success",
            #       "total": 39,
            #       "success": True
            #     }
        else:
            if code is not None:
                currency = self.currency(code)
                request['coin'] = currency['id']
            if since is not None:
                request['startTime'] = since
                # max 3 months range https://github.com/ccxt/ccxt/issues/6495
                request['endTime'] = self.sum(since, 7776000000)
            if limit is not None:
                request['limit'] = limit
            response = self.sapiGetCapitalWithdrawHistory(self.extend(request, params))
            #     [
            #       {
            #         "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
            #         "addressTag": "101286922",
            #         "amount": "28.75",
            #         "applyTime": "2021-04-15 12:09:16",
            #         "coin": "XRP",
            #         "id": "69e53ad305124b96b43668ceab158a18",
            #         "network": "XRP",
            #         "status": 6,
            #         "transactionFee": "0.25",
            #         "transferType": 0
            #         "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
            #       },
            #       {
            #         "address": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            #         "amount": "20",
            #         "applyTime": "2021-04-15 12:06:53",
            #         "coin": "USDT",
            #         "id": "9a67628b16ba4988ae20d329333f16bc",
            #         "network": "ETH",
            #         "status": 6,
            #         "transactionFee": "20",
            #         "transferType": 0
            #         "txId": "0x77fbf2cf2c85b552f0fd31fd2e56dc95c08adae031d96f3717d8b17e1aea3e46",
            #       },
            #       {
            #         "address": "TYDmtuWL8bsyjvcauUTerpfYyVhFtBjqyo",
            #         "amount": "51",
            #         "applyTime": "2021-04-13 12:46:59",
            #         "coin": "USDT",
            #         "id": "a7cdc0afbfa44a48bd225c9ece958fe2",
            #         "network": "TRX",
            #         "status": 6,
            #         "transactionFee": "1",
            #         "transferType": 0,
            #         "txId": "168a75112bce6ceb4823c66726ad47620ad332e69fe92d9cb8ceb76023f9a028",
            #       }
            #     ]
        for i in range(0, len(response)):
            response[i]['type'] = 'withdrawal'
        return self.parse_transactions(response, currency, since, limit)

    def parse_transaction_status_by_type(self, status, type=None):
        if type is None:
            return status
        statusesByType: dict = {
            'deposit': {
                '0': 'pending',
                '1': 'ok',
                '6': 'ok',
                # Fiat
                # Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
                'Failed': 'failed',
                'Processing': 'pending',
                'Refund Failed': 'failed',
                'Refunded': 'canceled',
                'Refunding': 'canceled',
                'Successful': 'ok',
            },
            'withdrawal': {
                '0': 'pending',  # Email Sent
                '1': 'canceled',  # Cancelled(different from 1 = ok in deposits)
                '2': 'pending',  # Awaiting Approval
                '3': 'failed',  # Rejected
                '4': 'pending',  # Processing
                '5': 'failed',  # Failure
                '6': 'ok',  # Completed
                # Fiat
                # Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
                'Failed': 'failed',
                'Processing': 'pending',
                'Refund Failed': 'failed',
                'Refunded': 'canceled',
                'Refunding': 'canceled',
                'Successful': 'ok',
            },
        }
        statuses = self.safe_dict(statusesByType, type, {})
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction: dict, currency: Currency = None) -> Transaction:
        #
        # fetchDeposits
        #
        #     {
        #       "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
        #       "addressTag": "",
        #       "amount": "4500",
        #       "coin": "USDT",
        #       "confirmTimes": "1/15"
        #       "insertTime": 1618394381000,
        #       "network": "BSC",
        #       "status": 1,
        #       "transferType": 1,
        #       "txId": "Internal transfer 51376627901",
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #       "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
        #       "addressTag": "101286922",
        #       "amount": "28.75",
        #       "applyTime": "2021-04-15 12:09:16",
        #       "coin": "XRP",
        #       "id": "69e53ad305124b96b43668ceab158a18",
        #       "network": "XRP",
        #       "status": 6,
        #       "transactionFee": "0.25",
        #       "transferType": 0,
        #       "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
        #     }
        #
        # fiat transaction
        # withdraw
        #     {
        #       "amount": "28.49",
        #       "createTime": 1614898701000,
        #       "fiatCurrency": "GBP",
        #       "indicatedAmount": "29.99",
        #       "method": "bank transfer",
        #       "orderNo": "CJW684897551397171200",
        #       "status": "Successful",
        #       "totalFee": "1.50",
        #       "updateTime": 1614898820000
        #     }
        #
        # deposit
        #     {
        #       "amount": "15.00",
        #       "createTime": "1627501026000",
        #       "fiatCurrency": "EUR",
        #       "indicatedAmount": "15.00",
        #       "method": "card",
        #       "orderNo": "25ced37075c1470ba8939d0df2316e23",
        #       "status": "Failed",
        #       "totalFee": "0.00",
        #       "transactionType": 0,
        #       "updateTime": "1627501027000"
        #     }
        #
        # withdraw
        #
        #    {id: "9a67628b16ba4988ae20d329333f16bc"}
        #
        id = self.safe_string_2(transaction, 'id', 'orderNo')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'addressTag')  # set but unused
        if tag is not None:
            if len(tag) < 1:
                tag = None
        txid = self.safe_string(transaction, 'txId')
        if (txid is not None) and (txid.find('Internal transfer ') >= 0):
            txid = txid[18:]
        currencyId = self.safe_string_2(transaction, 'coin', 'fiatCurrency')
        code = self.safe_currency_code(currencyId, currency)
        timestamp = None
        timestamp = self.safe_integer_2(transaction, 'insertTime', 'createTime')
        if timestamp is None:
            timestamp = self.parse8601(self.safe_string(transaction, 'applyTime'))
        updated = self.safe_integer_2(transaction, 'successTime', 'updateTime')
        type = self.safe_string(transaction, 'type')
        if type is None:
            txType = self.safe_string(transaction, 'transactionType')
            if txType is not None:
                type = 'deposit' if (txType == '0') else 'withdrawal'
            legalMoneyCurrenciesById = self.safe_dict(self.options, 'legalMoneyCurrenciesById')
            code = self.safe_string(legalMoneyCurrenciesById, code, code)
        status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'), type)
        amount = self.safe_number(transaction, 'amount')
        feeCost = self.safe_number_2(transaction, 'transactionFee', 'totalFee')
        fee = None
        if feeCost is not None:
            fee = {'currency': code, 'cost': feeCost}
        internalInteger = self.safe_integer(transaction, 'transferType')
        internal = None
        if internalInteger is not None:
            internal = True if internalInteger else False
        network = self.safe_string(transaction, 'network')
        return {
            'address': address,
            'addressFrom': None,
            'addressTo': address,
            'amount': amount,
            'comment': None,
            'currency': code,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
            'id': id,
            'info': transaction,
            'internal': internal,
            'network': network,
            'status': status,
            'tag': tag,
            'tagFrom': None,
            'tagTo': tag,
            'timestamp': timestamp,
            'txid': txid,
            'type': type,
            'updated': updated,
        }

    def parse_transfer_status(self, status: Str) -> Str:
        statuses: dict = {
            'CONFIRMED': 'ok',
        }
        return self.safe_string(statuses, status, status)

    def parse_transfer(self, transfer: dict, currency: Currency = None) -> TransferEntry:
        #
        # transfer
        #
        #     {
        #         "tranId":13526853623
        #     }
        #
        # fetchTransfers
        #
        #     {
        #         "amount": "25",
        #         "asset": "USDT",
        #         "status": "CONFIRMED",
        #         "timestamp": 1614640878000,
        #         "tranId": 43000126248
        #         "type": "MAIN_UMFUTURE",
        #     }
        #
        #     {
        #             "orderType": "C2C",  # EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment), REMITTANCESend cash)
        #             "transactionId": "M_P_71505104267788288",
        #             "transactionTime": 1610090460133,  #trade timestamp
        #             "amount": "23.72469206",  #order amount(up to 8 decimal places), positive is income, negative is expenditure
        #             "currency": "BNB",
        #             "walletType": 1,  #main wallet type, 1 for funding wallet, 2 for spot wallet, 3 for fiat wallet, 4 or 6 for card payment, 5 for earn wallet
        #             "walletTypes": [1,2],  #array formatthere are multiple values when using combination payment
        #             "fundsDetail": [ # details
        #                     {
        #                         "currency": "USDT",  #asset
        #                         "amount": "1.2",
        #                         "walletAssetCost":[ #details of asset cost per wallet
        #                             {"1":"0.6"},
        #                             {"2":"0.6"}
        #                         ]
        #                     },
        #                     {
        #                         "currency": "ETH",
        #                         "amount": "0.0001",
        #                         "walletAssetCost":[
        #                             {"1":"0.00005"},
        #                             {"2":"0.00005"}
        #                         ]
        #                     }
        #                 ],
        #             "payerInfo":{
        #                     "name":"Jack",  #nickname or merchant name
        #                     "type":"USER",  #account typeUSER for personalMERCHANT for merchant
        #                     "binanceId":"12345678",  #binance uid
        #                     "accountId":"67736251"  #binance pay id
        #                 },
        #             "receiverInfo":{
        #                     "name":"Alan",  #nickname or merchant name
        #                     "type":"MERCHANT",  #account typeUSER for personalMERCHANT for merchant
        #                     "email":"alan@binance.com",  #email
        #                     "binanceId":"34355667",  #binance uid
        #                     "accountId":"21326891",  #binance pay id
        #                     "countryCode":"1",  #International area code
        #                     "phoneNumber":"8057651210",
        #                     "mobileCode":"US",  #country code
        #                     "extend":[ #extension field
        #                             "institutionName": "",
        #                             "cardNumber": "",
        #                             "digitalWalletId": ""
        #                     ]
        #                 }
        #             }
        id = self.safe_string_2(transfer, 'tranId', 'transactionId')
        currencyId = self.safe_string_2(transfer, 'asset', 'currency')
        code = self.safe_currency_code(currencyId, currency)
        amount = self.safe_number(transfer, 'amount')
        type = self.safe_string(transfer, 'type')
        fromAccount = None
        toAccount = None
        accountsById = self.safe_dict(self.options, 'accountsById', {})
        if type is not None:
            parts = type.split('_')
            fromAccount = self.safe_value(parts, 0)
            toAccount = self.safe_value(parts, 1)
            fromAccount = self.safe_string(accountsById, fromAccount, fromAccount)
            toAccount = self.safe_string(accountsById, toAccount, toAccount)
        walletType = self.safe_integer(transfer, 'walletType')
        if walletType is not None:
            payer = self.safe_dict(transfer, 'payerInfo', {})
            receiver = self.safe_dict(transfer, 'receiverInfo', {})
            fromAccount = self.safe_string(payer, 'accountId')
            toAccount = self.safe_string(receiver, 'accountId')
        timestamp = self.safe_integer_2(transfer, 'timestamp', 'transactionTime')
        status = self.parse_transfer_status(self.safe_string(transfer, 'status'))
        return {
            'amount': amount,
            'currency': code,
            'datetime': self.iso8601(timestamp),
            'fromAccount': fromAccount,
            'id': id,
            'info': transfer,
            'status': status,
            'timestamp': timestamp,
            'toAccount': toAccount,
        }

    def parse_income(self, income, market: Market = None):
        #
        #     {
        #       "asset": "USDT",
        #       "income": "0.00134317",
        #       "incomeType": "FUNDING_FEE",
        #       "info": "FUNDING_FEE",
        #       "symbol": "ETHUSDT",
        #       "time": "1621584000000",
        #       "tradeId": ""
        #       "tranId": "4480321991774044580",
        #     }
        #
        marketId = self.safe_string(income, 'symbol')
        currencyId = self.safe_string(income, 'asset')
        timestamp = self.safe_integer(income, 'time')
        return {
            'info': income,
            'symbol': self.safe_symbol(marketId, market, None, 'swap'),
            'code': self.safe_currency_code(currencyId),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'id': self.safe_string(income, 'tranId'),
            'amount': self.safe_number(income, 'income'),
        }

    def transfer(self, code: str, amount: float, fromAccount: str, toAccount: str, params={}) -> TransferEntry:
        """
        transfer currency internally between wallets on the same account

        https://developers.binance.com/docs/wallet/asset/user-universal-transfer

        :param str code: unified currency code
        :param float amount: amount to transfer
        :param str fromAccount: account to transfer from
        :param str toAccount: account to transfer to
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: exchange specific transfer type
        :param str [params.symbol]: the unified symbol, required for isolated margin transfers
        :returns dict: a `transfer structure <https://docs.ccxt.com/#/?id=transfer-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'asset': currency['id'],
            'amount': self.currency_to_precision(code, amount),
        }
        request['type'] = self.safe_string(params, 'type')
        params = self.omit(params, 'type')
        if request['type'] is None:
            symbol = self.safe_string(params, 'symbol')
            market = None
            if symbol is not None:
                market = self.market(symbol)
                params = self.omit(params, 'symbol')
            fromId = self.convert_type_to_account(fromAccount).upper()
            toId = self.convert_type_to_account(toAccount).upper()
            isolatedSymbol = None
            if market is not None:
                isolatedSymbol = market['id']
            if fromId == 'ISOLATED':
                if symbol is None:
                    raise ArgumentsRequired(self.id + ' transfer() requires params["symbol"] when fromAccount is ' + fromAccount)
            if toId == 'ISOLATED':
                if symbol is None:
                    raise ArgumentsRequired(self.id + ' transfer() requires params["symbol"] when toAccount is ' + toAccount)
            accountsById = self.safe_dict(self.options, 'accountsById', {})
            fromIsolated = not (fromId in accountsById)
            toIsolated = not (toId in accountsById)
            if fromIsolated and (market is None):
                isolatedSymbol = fromId  # allow user provide symbol from/to account
            if toIsolated and (market is None):
                isolatedSymbol = toId
            if fromIsolated or toIsolated:  # Isolated margin transfer
                fromFuture = fromId == 'UMFUTURE' or fromId == 'CMFUTURE'
                toFuture = toId == 'UMFUTURE' or toId == 'CMFUTURE'
                fromSpot = fromId == 'MAIN'
                toSpot = toId == 'MAIN'
                funding = fromId == 'FUNDING' or toId == 'FUNDING'
                option = fromId == 'OPTION' or toId == 'OPTION'
                prohibitedWithIsolated = fromFuture or toFuture or funding or option
                if (fromIsolated or toIsolated) and prohibitedWithIsolated:
                    raise BadRequest(self.id + ' transfer() does not allow transfers between ' + fromAccount + ' and ' + toAccount)
                elif toSpot and fromIsolated:
                    fromId = 'ISOLATED_MARGIN'
                    request['fromSymbol'] = isolatedSymbol
                elif fromSpot and toIsolated:
                    toId = 'ISOLATED_MARGIN'
                    request['toSymbol'] = isolatedSymbol
                else:
                    if fromIsolated and toIsolated:
                        request['fromSymbol'] = fromId
                        request['toSymbol'] = toId
                        fromId = 'ISOLATEDMARGIN'
                        toId = 'ISOLATEDMARGIN'
                    else:
                        if fromIsolated:
                            request['fromSymbol'] = isolatedSymbol
                            fromId = 'ISOLATEDMARGIN'
                        if toIsolated:
                            request['toSymbol'] = isolatedSymbol
                            toId = 'ISOLATEDMARGIN'
                request['type'] = fromId + '_' + toId
            else:
                request['type'] = fromId + '_' + toId
        response = self.sapiPostAssetTransfer(self.extend(request, params))
        #
        #     {
        #         "tranId":13526853623
        #     }
        #
        return self.parse_transfer(response, currency)

    def fetch_transfers(self, code: Str = None, since: Int = None, limit: Int = None, params={}) -> List[TransferEntry]:
        """
        fetch a history of internal transfers made on an account

        https://developers.binance.com/docs/wallet/asset/query-user-universal-transfer

        :param str code: unified currency code of the currency transferred
        :param int [since]: the earliest time in ms to fetch transfers for
        :param int [limit]: the maximum number of transfers structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: the latest time in ms to fetch transfers for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.internal]: default False, when True will fetch pay trade history
        :returns dict[]: a list of `transfer structures <https://docs.ccxt.com/#/?id=transfer-structure>`
        """
        self.load_markets()
        internal = self.safe_bool(params, 'internal')
        params = self.omit(params, 'internal')
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchTransfers', 'paginate')
        if paginate and not internal:
            return self.fetch_paginated_call_dynamic('fetchTransfers', code, since, limit, params)
        currency = None
        if code is not None:
            currency = self.currency(code)
        request: dict = {}
        limitKey = 'limit'
        if not internal:
            defaultType = self.safe_string_2(self.options, 'fetchTransfers', 'defaultType', 'spot')
            fromAccount = self.safe_string(params, 'fromAccount', defaultType)
            defaultTo = 'spot' if (fromAccount == 'future') else 'future'
            toAccount = self.safe_string(params, 'toAccount', defaultTo)
            type = self.safe_string(params, 'type')
            accountsByType = self.safe_dict(self.options, 'accountsByType', {})
            fromId = self.safe_string(accountsByType, fromAccount)
            toId = self.safe_string(accountsByType, toAccount)
            if type is None:
                if fromId is None:
                    keys = list(accountsByType.keys())
                    raise ExchangeError(self.id + ' fromAccount parameter must be one of ' + ', '.join(keys))
                if toId is None:
                    keys = list(accountsByType.keys())
                    raise ExchangeError(self.id + ' toAccount parameter must be one of ' + ', '.join(keys))
                type = fromId + '_' + toId
            request['type'] = type
            limitKey = 'size'
        if limit is not None:
            request[limitKey] = limit
        if since is not None:
            request['startTime'] = since
        until = self.safe_integer(params, 'until')
        if until is not None:
            params = self.omit(params, 'until')
            request['endTime'] = until
        response = None
        if internal:
            response = self.sapiGetPayTransactions(self.extend(request, params))
            #
            # {
            #     "code": "000000",
            #     "message": "success",
            #     "data": [
            #     {
            #         "orderType": "C2C",  # EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment), REMITTANCESend cash)
            #         "transactionId": "M_P_71505104267788288",
            #         "transactionTime": 1610090460133,  #trade timestamp
            #         "amount": "23.72469206",  #order amount(up to 8 decimal places), positive is income, negative is expenditure
            #         "currency": "BNB",
            #         "walletType": 1,  #main wallet type, 1 for funding wallet, 2 for spot wallet, 3 for fiat wallet, 4 or 6 for card payment, 5 for earn wallet
            #         "walletTypes": [1,2],  #array formatthere are multiple values when using combination payment
            #         "fundsDetail": [ # details
            #                 {
            #                  "currency": "USDT",  #asset
            #                  "amount": "1.2",
            #                  "walletAssetCost":[ #details of asset cost per wallet
            #                      {"1":"0.6"},
            #                      {"2":"0.6"}
            #                  ]
            #                 },
            #                 {
            #                   "currency": "ETH",
            #                   "amount": "0.0001",
            #                   "walletAssetCost":[
            #                      {"1":"0.00005"},
            #                      {"2":"0.00005"}
            #                   ]
            #                 }
            #            ],
            #         "payerInfo":{
            #                 "name":"Jack",  #nickname or merchant name
            #                 "type":"USER",  #account typeUSER for personalMERCHANT for merchant
            #                 "binanceId":"12345678",  #binance uid
            #                 "accountId":"67736251"  #binance pay id
            #             },
            #         "receiverInfo":{
            #                 "name":"Alan",  #nickname or merchant name
            #                 "type":"MERCHANT",  #account typeUSER for personalMERCHANT for merchant
            #                 "email":"alan@binance.com",  #email
            #                 "binanceId":"34355667",  #binance uid
            #                 "accountId":"21326891",  #binance pay id
            #                 "countryCode":"1",  #International area code
            #                 "phoneNumber":"8057651210",
            #                 "mobileCode":"US",  #country code
            #                 "extend":[ #extension field
            #                      "institutionName": "",
            #                      "cardNumber": "",
            #                      "digitalWalletId": ""
            #                 ]
            #             }
            #       }
            #    ],
            #    "success": True
            # }
            #
        else:
            response = self.sapiGetAssetTransfer(self.extend(request, params))
            #
            #     {
            #         "rows": [
            #             {
            #                 "amount": "25",
            #                 "asset": "USDT",
            #                 "status": "CONFIRMED",
            #                 "timestamp": 1614640878000,
            #                 "tranId": 43000126248,
            #                 "type": "MAIN_UMFUTURE",
            #             },
            #         ]
            #         "total": 3,
            #     }
            #
        rows = self.safe_list_2(response, 'rows', 'data', [])
        return self.parse_transfers(rows, currency, since, limit)

    def fetch_deposit_address(self, code: str, params={}) -> DepositAddress:
        """
        fetch the deposit address for a currency associated with self account

        https://developers.binance.com/docs/wallet/capital/deposite-address

        :param str code: unified currency code
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.network]: network for fetch deposit address
        :returns dict: an `address structure <https://docs.ccxt.com/#/?id=address-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'coin': currency['id'],
            # 'network': 'ETH',  # 'BSC', 'XMR', you can get network and isDefault in networkList in the response of sapiGetCapitalConfigDetail
        }
        networks = self.safe_dict(self.options, 'networks', {})
        network = self.safe_string_upper(params, 'network')  # self line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks, network, network)  # handle ERC20>ETH alias
        if network is not None:
            request['network'] = network
            params = self.omit(params, 'network')
        # has support for the 'network' parameter
        response = self.sapiGetCapitalDepositAddress(self.extend(request, params))
        #
        #     {
        #         "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
        #         "currency": "XRP",
        #         "info": {
        #             "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
        #             "coin": "XRP",
        #             "tag": "108618262",
        #             "url": "https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh"
        #         },
        #         "tag": "108618262",
        #     }
        #
        return self.parse_deposit_address(response, currency)

    def parse_deposit_address(self, response, currency: Currency = None) -> DepositAddress:
        #
        #     {
        #         "currency": "XRP",
        #         "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
        #         "tag": "108618262",
        #         "info": {
        #             "coin": "XRP",
        #             "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
        #             "tag": "108618262",
        #             "url": "https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh"
        #         }
        #     }
        #
        info = self.safe_dict(response, 'info', {})
        url = self.safe_string(info, 'url')
        address = self.safe_string(response, 'address')
        currencyId = self.safe_string(response, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        impliedNetwork = None
        if url is not None:
            reverseNetworks = self.safe_dict(self.options, 'reverseNetworks', {})
            parts = url.split('/')
            topLevel = self.safe_string(parts, 2)
            if (topLevel == 'blockchair.com') or (topLevel == 'viewblock.io'):
                subLevel = self.safe_string(parts, 3)
                if subLevel is not None:
                    topLevel = topLevel + '/' + subLevel
            impliedNetwork = self.safe_string(reverseNetworks, topLevel)
            impliedNetworks = self.safe_dict(self.options, 'impliedNetworks', {
                'ETH': {'ERC20': 'ETH'},
                'TRX': {'TRC20': 'TRX'},
            })
            if code in impliedNetworks:
                conversion = self.safe_dict(impliedNetworks, code, {})
                impliedNetwork = self.safe_string(conversion, impliedNetwork, impliedNetwork)
        tag = self.safe_string(response, 'tag', '')
        if len(tag) == 0:
            tag = None
        self.check_address(address)
        return {
            'address': address,
            'currency': code,
            'info': response,
            'network': impliedNetwork,
            'tag': tag,
        }

    def fetch_transaction_fees(self, codes: Strings = None, params={}):
        """
 @deprecated
        please use fetchDepositWithdrawFees instead

        https://developers.binance.com/docs/wallet/capital/all-coins-info

        :param str[]|None codes: not used by binance fetchTransactionFees()
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `fee structures <https://docs.ccxt.com/#/?id=fee-structure>`
        """
        self.load_markets()
        response = self.sapiGetCapitalConfigGetall(params)
        #
        #  [
        #     {
        #       "coin": "BAT",
        #       "depositAllEnable": True,
        #       "free": "0",
        #       "freeze": "0",
        #       "ipoable": "0",
        #       "ipoing": "0",
        #       "isLegalMoney": False,
        #       "locked": "0",
        #       "name": "Basic Attention Token",
        #       "networkList": [
        #         {
        #           "addressRegex": "^(bnb1)[0-9a-z]{38}$",
        #           "coin": "BAT",
        #           "depositDesc": '',
        #           "depositEnable": True,
        #           "isDefault": False,
        #           "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
        #           "minConfirm": "1",
        #           "name": "BEP2",
        #           "network": "BNB",
        #           "resetAddressStatus": False,
        #           "specialTips": "The name of self asset is Basic Attention Token(BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
        #           "unLockConfirm": "0"
        #           "withdrawDesc": '',
        #           "withdrawEnable": True,
        #           "withdrawFee": "0.27",
        #           "withdrawIntegerMultiple": "0.00000001",
        #           "withdrawMax": "10000000000",
        #           "withdrawMin": "0.54",
        #         },
        #         {
        #           "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
        #           "coin": "BAT",
        #           "depositDesc": '',
        #           "depositEnable": True,
        #           "isDefault": False,
        #           "memoRegex": '',
        #           "minConfirm": "15",
        #           "name": "BEP20(BSC)",
        #           "network": "BSC",
        #           "resetAddressStatus": False,
        #           "specialTips": "The name of self asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token(BAT) tokens under the contract address ending in 9766e.",
        #           "unLockConfirm": "0"
        #           "withdrawDesc": '',
        #           "withdrawEnable": True,
        #           "withdrawFee": "0.27",
        #           "withdrawIntegerMultiple": "0.00000001",
        #           "withdrawMax": "10000000000",
        #           "withdrawMin": "0.54",
        #         },
        #         {
        #           "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
        #           "coin": "BAT",
        #           "depositDesc": '',
        #           "depositEnable": True,
        #           "isDefault": True,
        #           "memoRegex": '',
        #           "minConfirm": "12",
        #           "name": "ERC20",
        #           "network": "ETH",
        #           "resetAddressStatus": False,
        #           "specialTips": "The name of self asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token(BAT) tokens under the contract address ending in 887ef.",
        #           "unLockConfirm": "0"
        #           "withdrawDesc": '',
        #           "withdrawEnable": True,
        #           "withdrawFee": "27",
        #           "withdrawIntegerMultiple": "0.00000001",
        #           "withdrawMax": "10000000000",
        #           "withdrawMin": "54",
        #         }
        #       ],
        #       "storage": "0",
        #       "trading": True,
        #       "withdrawAllEnable": True,
        #       "withdrawing": "0",
        #     }
        #  ]
        #
        withdrawFees: dict = {}
        for i in range(0, len(response)):
            entry = response[i]
            currencyId = self.safe_string(entry, 'coin')
            code = self.safe_currency_code(currencyId)
            networkList = self.safe_list(entry, 'networkList', [])
            withdrawFees[code] = {}
            for j in range(0, len(networkList)):
                networkEntry = networkList[j]
                networkId = self.safe_string(networkEntry, 'network')
                networkCode = self.safe_currency_code(networkId)
                fee = self.safe_number(networkEntry, 'withdrawFee')
                withdrawFees[code][networkCode] = fee
        return {
            'withdraw': withdrawFees,
            'deposit': {},
            'info': response,
        }

    def fetch_deposit_withdraw_fees(self, codes: Strings = None, params={}):
        """
        fetch deposit and withdraw fees

        https://developers.binance.com/docs/wallet/capital/all-coins-info

        :param str[]|None codes: not used by binance fetchDepositWithdrawFees()
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `fee structures <https://docs.ccxt.com/#/?id=fee-structure>`
        """
        self.load_markets()
        response = self.sapiGetCapitalConfigGetall(params)
        #
        #    [
        #        {
        #            "coin": "BAT",
        #            "depositAllEnable": True,
        #            "free": "0",
        #            "freeze": "0",
        #            "ipoable": "0",
        #            "ipoing": "0",
        #            "isLegalMoney": False,
        #            "locked": "0",
        #            "name": "Basic Attention Token",
        #            "networkList": [
        #                {
        #                    "addressRegex": "^(bnb1)[0-9a-z]{38}$",
        #                    "coin": "BAT",
        #                    "depositDesc": '',
        #                    "depositEnable": True,
        #                    "isDefault": False,
        #                    "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
        #                    "minConfirm": "1",
        #                    "name": "BEP2",
        #                    "network": "BNB",
        #                    "resetAddressStatus": False,
        #                    "specialTips": "The name of self asset is Basic Attention Token(BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
        #                    "unLockConfirm": "0"
        #                    "withdrawDesc": '',
        #                    "withdrawEnable": True,
        #                    "withdrawFee": "0.27",
        #                    "withdrawIntegerMultiple": "0.00000001",
        #                    "withdrawMax": "10000000000",
        #                    "withdrawMin": "0.54",
        #                },
        #                ...
        #            ],
        #            "storage": "0",
        #            "trading": True,
        #            "withdrawAllEnable": True,
        #            "withdrawing": "0",
        #        }
        #    ]
        #
        return self.parse_deposit_withdraw_fees(response, codes, 'coin')

    def parse_deposit_withdraw_fee(self, fee, currency: Currency = None):
        #
        #    {
        #        "coin": "BAT",
        #        "depositAllEnable": True,
        #        "free": "0",
        #        "freeze": "0",
        #        "ipoable": "0",
        #        "ipoing": "0",
        #        "isLegalMoney": False,
        #        "locked": "0",
        #        "name": "Basic Attention Token",
        #        "networkList": [
        #            {
        #                "addressRegex": "^(bnb1)[0-9a-z]{38}$",
        #                "coin": "BAT",
        #                "depositDesc": '',
        #                "depositEnable": True,
        #                "isDefault": False,
        #                "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
        #                "minConfirm": "1",
        #                "name": "BEP2",
        #                "network": "BNB",
        #                "resetAddressStatus": False,
        #                "specialTips": "The name of self asset is Basic Attention Token(BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
        #                "unLockConfirm": "0"
        #                "withdrawDesc": '',
        #                "withdrawEnable": True,
        #                "withdrawFee": "0.27",
        #                "withdrawIntegerMultiple": "0.00000001",
        #                "withdrawMax": "10000000000",
        #                "withdrawMin": "0.54",
        #            },
        #            ...
        #        ],
        #        "storage": "0",
        #        "trading": True,
        #        "withdrawAllEnable": True,
        #        "withdrawing": "0",
        #    }
        #
        networkList = self.safe_list(fee, 'networkList', [])
        result = self.deposit_withdraw_fee(fee)
        for j in range(0, len(networkList)):
            networkEntry = networkList[j]
            networkId = self.safe_string(networkEntry, 'network')
            networkCode = self.network_id_to_code(networkId)
            withdrawFee = self.safe_number(networkEntry, 'withdrawFee')
            isDefault = self.safe_bool(networkEntry, 'isDefault')
            if isDefault is True:
                result['withdraw'] = {
                    'fee': withdrawFee,
                    'percentage': None,
                }
            result['networks'][networkCode] = {
                'withdraw': {
                    'fee': withdrawFee,
                    'percentage': None,
                },
                'deposit': {
                    'fee': None,
                    'percentage': None,
                },
            }
        return result

    def withdraw(self, code: str, amount: float, address: str, tag=None, params={}) -> Transaction:
        """
        make a withdrawal

        https://developers.binance.com/docs/wallet/capital/withdraw

        :param str code: unified currency code
        :param float amount: the amount to withdraw
        :param str address: the address to withdraw to
        :param str tag:
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `transaction structure <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        tag, params = self.handle_withdraw_tag_and_params(tag, params)
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'coin': currency['id'],
            'address': address,
            'amount': self.currency_to_precision(code, amount),
            # issue sapiGetCapitalConfigGetall() to get networks for withdrawing USDT ERC20 vs USDT Omni
            # 'network': 'ETH',  # 'BTC', 'TRX', etc, optional
        }
        if tag is not None:
            request['addressTag'] = tag
        networks = self.safe_dict(self.options, 'networks', {})
        network = self.safe_string_upper(params, 'network')  # self line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks, network, network)  # handle ERC20>ETH alias
        if network is not None:
            request['network'] = network
            params = self.omit(params, 'network')
        response = self.sapiPostCapitalWithdrawApply(self.extend(request, params))
        #     {id: '9a67628b16ba4988ae20d329333f16bc'}
        return self.parse_transaction(response, currency)

    def parse_trading_fee(self, fee: dict, market: Market = None) -> TradingFeeInterface:
        #
        # spot
        #     [
        #       {
        #         "makerCommission": "0.001",
        #         "symbol": "BTCUSDT",
        #         "takerCommission": "0.001"
        #       }
        #     ]
        #
        # swap
        #     {
        #         "makerCommissionRate": "0.00015",  # 0.015%
        #         "symbol": "BTCUSD_PERP",
        #         "takerCommissionRate": "0.00040"   # 0.040%
        #     }
        #
        marketId = self.safe_string(fee, 'symbol')
        symbol = self.safe_symbol(marketId, market, None, 'spot')
        return {
            'info': fee,
            'symbol': symbol,
            'maker': self.safe_number_2(fee, 'makerCommission', 'makerCommissionRate'),
            'taker': self.safe_number_2(fee, 'takerCommission', 'takerCommissionRate'),
            'percentage': None,
            'tierBased': None,
        }

    def fetch_trading_fee(self, symbol: str, params={}) -> TradingFeeInterface:
        """
        fetch the trading fees for a market

        https://developers.binance.com/docs/wallet/asset/trade-fee
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/User-Commission-Rate
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/User-Commission-Rate
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-UM
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-CM

        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch trading fees in a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a `fee structure <https://docs.ccxt.com/#/?id=fee-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        type = market['type']
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchTradingFee', market, params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchTradingFee', 'papi', 'portfolioMargin', False)
        isLinear = self.is_linear(type, subType)
        isInverse = self.is_inverse(type, subType)
        request: dict = {
            'symbol': market['id'],
        }
        response = None
        if isLinear:
            if isPortfolioMargin:
                response = self.papiGetUmCommissionRate(self.extend(request, params))
            else:
                response = self.fapiPrivateGetCommissionRate(self.extend(request, params))
        elif isInverse:
            if isPortfolioMargin:
                response = self.papiGetCmCommissionRate(self.extend(request, params))
            else:
                response = self.dapiPrivateGetCommissionRate(self.extend(request, params))
        else:
            response = self.sapiGetAssetTradeFee(self.extend(request, params))
        #
        # spot
        #
        #     [
        #       {
        #         "makerCommission": "0.001",
        #         "symbol": "BTCUSDT",
        #         "takerCommission": "0.001"
        #       }
        #     ]
        #
        # swap
        #
        #     {
        #         "makerCommissionRate": "0.00015",  # 0.015%
        #         "symbol": "BTCUSD_PERP",
        #         "takerCommissionRate": "0.00040"   # 0.040%
        #     }
        #
        data = response
        if isinstance(data, list):
            data = self.safe_dict(data, 0, {})
        return self.parse_trading_fee(data, market)

    def fetch_trading_fees(self, params={}) -> TradingFees:
        """
        fetch the trading fees for multiple markets

        https://developers.binance.com/docs/wallet/asset/trade-fee
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Config

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of `fee structures <https://docs.ccxt.com/#/?id=fee-structure>` indexed by market symbols
        """
        self.load_markets()
        type = None
        type, params = self.handle_market_type_and_params('fetchTradingFees', None, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchTradingFees', None, params, 'linear')
        isSpotOrMargin = (type == 'spot') or (type == 'margin')
        isLinear = self.is_linear(type, subType)
        isInverse = self.is_inverse(type, subType)
        response = None
        if isSpotOrMargin:
            response = self.sapiGetAssetTradeFee(params)
        elif isLinear:
            response = self.fapiPrivateGetAccountConfig(params)
        elif isInverse:
            response = self.dapiPrivateGetAccount(params)
        #
        # sapi / spot
        #
        #    [
        #       {
        #         "makerCommission": "0.001",
        #         "symbol": "ZRXBNB",
        #         "takerCommission": "0.001"
        #       },
        #       {
        #         "makerCommission": "0.001",
        #         "symbol": "ZRXBTC",
        #         "takerCommission": "0.001"
        #       },
        #    ]
        #
        # fapi / future / linear
        #
        #     {
        #         "availableBalance": "23.72469206",       # available balance, only for USDT asset
        #         "canDeposit": True,     # if can transfer in asset
        #         "canTrade": True,   # if can trade
        #         "canWithdraw": True,    # if can transfer out asset
        #         "feeTier": 0,       # account commisssion tier
        #         "maxWithdrawAmount": "23.72469206"     # maximum amount for transfer out, only for USDT asset
        #         "totalCrossUnPnl": "0.00000000",      # unrealized profit of crossed positions, only for USDT asset
        #         "totalCrossWalletBalance": "23.72469206",      # crossed wallet balance, only for USDT asset
        #         "totalInitialMargin": "0.00000000",    # total initial margin required with current mark price(useless with isolated positions), only for USDT asset
        #         "totalMaintMargin": "0.00000000",     # total maintenance margin required, only for USDT asset
        #         "totalMarginBalance": "23.72469206",     # total margin balance, only for USDT asset
        #         "totalOpenOrderInitialMargin": "0.00000000",   # initial margin required for open orders with current mark price, only for USDT asset
        #         "totalPositionInitialMargin": "0.00000000",    # initial margin required for positions with current mark price, only for USDT asset
        #         "totalUnrealizedProfit": "0.00000000",   # total unrealized profit, only for USDT asset
        #         "totalWalletBalance": "23.72469206",     # total wallet balance, only for USDT asset
        #         "updateTime": 0,
        #         ...
        #     }
        #
        # dapi / delivery / inverse
        #
        #     {
        #         "canDeposit": True,
        #         "canTrade": True,
        #         "canWithdraw": True,
        #         "feeTier": 2,
        #         "updateTime": 0
        #     }
        #
        if isSpotOrMargin:
            #
            #    [
            #       {
            #         "makerCommission": "0.001",
            #         "symbol": "ZRXBNB",
            #         "takerCommission": "0.001"
            #       },
            #       {
            #         "makerCommission": "0.001",
            #         "symbol": "ZRXBTC",
            #         "takerCommission": "0.001"
            #       },
            #    ]
            #
            result: dict = {}
            for i in range(0, len(response)):
                fee = self.parse_trading_fee(response[i])
                symbol = fee['symbol']
                result[symbol] = fee
            return result
        elif isLinear:
            #
            #     {
            #         "availableBalance": "23.72469206",       # available balance, only for USDT asset
            #         "canDeposit": True,     # if can transfer in asset
            #         "canTrade": True,   # if can trade
            #         "canWithdraw": True,    # if can transfer out asset
            #         "feeTier": 0,       # account commisssion tier
            #         "maxWithdrawAmount": "23.72469206"     # maximum amount for transfer out, only for USDT asset
            #         "totalCrossUnPnl": "0.00000000",      # unrealized profit of crossed positions, only for USDT asset
            #         "totalCrossWalletBalance": "23.72469206",      # crossed wallet balance, only for USDT asset
            #         "totalInitialMargin": "0.00000000",    # total initial margin required with current mark price(useless with isolated positions), only for USDT asset
            #         "totalMaintMargin": "0.00000000",     # total maintenance margin required, only for USDT asset
            #         "totalMarginBalance": "23.72469206",     # total margin balance, only for USDT asset
            #         "totalOpenOrderInitialMargin": "0.00000000",   # initial margin required for open orders with current mark price, only for USDT asset
            #         "totalPositionInitialMargin": "0.00000000",    # initial margin required for positions with current mark price, only for USDT asset
            #         "totalUnrealizedProfit": "0.00000000",   # total unrealized profit, only for USDT asset
            #         "totalWalletBalance": "23.72469206",     # total wallet balance, only for USDT asset
            #         "updateTime": 0,
            #         ...
            #     }
            #
            symbols = list(self.markets.keys())
            result: dict = {}
            feeTier = self.safe_integer(response, 'feeTier')
            feeTiers = self.fees['linear']['trading']['tiers']
            maker = feeTiers['maker'][feeTier][1]
            taker = feeTiers['taker'][feeTier][1]
            for i in range(0, len(symbols)):
                symbol = symbols[i]
                market = self.markets[symbol]
                if market['linear']:
                    result[symbol] = {
                        'maker': maker,
                        'info': {
                            'feeTier': feeTier,
                        },
                        'symbol': symbol,
                        'taker': taker,
                    }
            return result
        elif isInverse:
            #
            #     {
            #         "canDeposit": True,
            #         "canTrade": True,
            #         "canWithdraw": True,
            #         "feeTier": 2,
            #         "updateTime": 0
            #     }
            #
            symbols = list(self.markets.keys())
            result: dict = {}
            feeTier = self.safe_integer(response, 'feeTier')
            feeTiers = self.fees['inverse']['trading']['tiers']
            maker = feeTiers['maker'][feeTier][1]
            taker = feeTiers['taker'][feeTier][1]
            for i in range(0, len(symbols)):
                symbol = symbols[i]
                market = self.markets[symbol]
                if market['inverse']:
                    result[symbol] = {
                        'maker': maker,
                        'info': {
                            'feeTier': feeTier,
                        },
                        'symbol': symbol,
                        'taker': taker,
                    }
            return result
        return None

    def futures_transfer(self, code: str, amount, type, params={}):
        """
 @ignore
        transfer between futures account

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/New-Future-Account-Transfer

        :param str code: unified currency code
        :param float amount: the amount to transfer
        :param str type: 1 - transfer from spot account to USDT- futures account, 2 - transfer from USDT- futures account to spot account, 3 - transfer from spot account to COIN- futures account, 4 - transfer from COIN- futures account to spot account
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param float params.recvWindow:
        :returns dict: a `transfer structure <https://docs.ccxt.com/#/?id=futures-transfer-structure>`
        """
        if (type < 1) or (type > 4):
            raise ArgumentsRequired(self.id + ' type must be between 1 and 4')
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'asset': currency['id'],
            'amount': amount,
            'type': type,
        }
        response = self.sapiPostFuturesTransfer(self.extend(request, params))
        #
        #   {
        #       "tranId": 100000001
        #   }
        #
        return self.parse_transfer(response, currency)

    def fetch_funding_rate(self, symbol: str, params={}) -> FundingRate:
        """
        fetch the current funding rate

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Index-Price-and-Mark-Price

        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `funding rate structure <https://docs.ccxt.com/#/?id=funding-rate-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        response = None
        if market['linear']:
            response = self.fapiPublicGetPremiumIndex(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPublicGetPremiumIndex(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchFundingRate() supports linear and inverse contracts only')
        if market['inverse']:
            response = response[0]
        #
        #     {
        #         "estimatedSettlePrice": "45133.91753671",
        #         "indexPrice": "45745.47701915",
        #         "interestRate": "0.00010000",
        #         "lastFundingRate": "0.00063521",
        #         "markPrice": "45802.81129892",
        #         "nextFundingTime": "1621267200000",
        #         "symbol": "BTCUSDT",
        #         "time": "1621252344001"
        #     }
        #
        return self.parse_funding_rate(response, market)

    def fetch_funding_rate_history(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetches historical funding rate prices

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Get-Funding-Rate-History-of-Perpetual-Futures

        :param str symbol: unified symbol of the market to fetch the funding rate history for
        :param int [since]: timestamp in ms of the earliest funding rate to fetch
        :param int [limit]: the maximum amount of `funding rate structures <https://docs.ccxt.com/#/?id=funding-rate-history-structure>` to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: timestamp in ms of the latest funding rate
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param str [params.subType]: "linear" or "inverse"
        :returns dict[]: a list of `funding rate structures <https://docs.ccxt.com/#/?id=funding-rate-history-structure>`
        """
        self.load_markets()
        request: dict = {}
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchFundingRateHistory', 'paginate')
        if paginate:
            return self.fetch_paginated_call_deterministic('fetchFundingRateHistory', symbol, since, limit, '8h', params)
        defaultType = self.safe_string_2(self.options, 'fetchFundingRateHistory', 'defaultType', 'future')
        type = self.safe_string(params, 'type', defaultType)
        market = None
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
            request['symbol'] = market['id']
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchFundingRateHistory', market, params, 'linear')
        params = self.omit(params, 'type')
        if since is not None:
            request['startTime'] = since
        until = self.safe_integer(params, 'until')  # unified in milliseconds
        endTime = self.safe_integer(params, 'endTime', until)  # exchange-specific in milliseconds
        params = self.omit(params, ['endTime', 'until'])
        if endTime is not None:
            request['endTime'] = endTime
        if limit is not None:
            request['limit'] = limit
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetFundingRate(self.extend(request, params))
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetFundingRate(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchFundingRateHistory() is not supported for ' + type + ' markets')
        #
        #     {
        #         "fundingRate": "0.00063521",
        #         "fundingTime": "1621267200000",
        #         "symbol": "BTCUSDT",
        #     }
        #
        rates = []
        for i in range(0, len(response)):
            entry = response[i]
            timestamp = self.safe_integer(entry, 'fundingTime')
            rates.append({
                'datetime': self.iso8601(timestamp),
                'fundingRate': self.safe_number(entry, 'fundingRate'),
                'info': entry,
                'symbol': self.safe_symbol(self.safe_string(entry, 'symbol'), None, None, 'swap'),
                'timestamp': timestamp,
            })
        sorted = self.sort_by(rates, 'timestamp')
        return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)

    def fetch_funding_rates(self, symbols: Strings = None, params={}) -> FundingRates:
        """
        fetch the funding rate for multiple markets

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Index-Price-and-Mark-Price

        :param str[]|None symbols: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict[]: a list of `funding rate structures <https://docs.ccxt.com/#/?id=funding-rates-structure>`, indexed by market symbols
        """
        self.load_markets()
        symbols = self.market_symbols(symbols)
        defaultType = self.safe_string_2(self.options, 'fetchFundingRates', 'defaultType', 'future')
        type = self.safe_string(params, 'type', defaultType)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchFundingRates', None, params, 'linear')
        query = self.omit(params, 'type')
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetPremiumIndex(query)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetPremiumIndex(query)
        else:
            raise NotSupported(self.id + ' fetchFundingRates() supports linear and inverse contracts only')
        result = self.parse_funding_rates(response)
        return self.filter_by_array(result, 'symbol', symbols)

    def parse_funding_rate(self, contract, market: Market = None) -> FundingRate:
        # ensure it matches with https://www.binance.com/en/futures/funding-history/0
        #
        # fetchFundingRate, fetchFundingRates
        #
        #     {
        #         "estimatedSettlePrice": "45133.91753671",
        #         "indexPrice": "45745.47701915",
        #         "interestRate": "0.00010000",
        #         "lastFundingRate": "0.00063521",
        #         "markPrice": "45802.81129892",
        #         "nextFundingTime": "1621267200000",
        #         "symbol": "BTCUSDT",
        #         "time": "1621252344001"
        #     }
        #
        # fetchFundingInterval, fetchFundingIntervals
        #
        #     {
        #         "symbol": "BLZUSDT",
        #         "adjustedFundingRateCap": "0.03000000",
        #         "adjustedFundingRateFloor": "-0.03000000",
        #         "fundingIntervalHours": 4,
        #         "disclaimer": False
        #     }
        #
        timestamp = self.safe_integer(contract, 'time')
        marketId = self.safe_string(contract, 'symbol')
        symbol = self.safe_symbol(marketId, market, None, 'contract')
        markPrice = self.safe_number(contract, 'markPrice')
        indexPrice = self.safe_number(contract, 'indexPrice')
        interestRate = self.safe_number(contract, 'interestRate')
        estimatedSettlePrice = self.safe_number(contract, 'estimatedSettlePrice')
        fundingRate = self.safe_number(contract, 'lastFundingRate')
        fundingTime = self.safe_integer(contract, 'nextFundingTime')
        interval = self.safe_string(contract, 'fundingIntervalHours')
        intervalString = None
        if interval is not None:
            intervalString = interval + 'h'
        return {
            'datetime': self.iso8601(timestamp),
            'estimatedSettlePrice': estimatedSettlePrice,
            'fundingDatetime': self.iso8601(fundingTime),
            'fundingRate': fundingRate,
            'fundingTimestamp': fundingTime,
            'indexPrice': indexPrice,
            'info': contract,
            'interestRate': interestRate,
            'interval': intervalString,
            'markPrice': markPrice,
            'nextFundingDatetime': None,
            'nextFundingRate': None,
            'nextFundingTimestamp': None,
            'previousFundingDatetime': None,
            'previousFundingRate': None,
            'previousFundingTimestamp': None,
            'symbol': symbol,
            'timestamp': timestamp,
        }

    def parse_account_positions(self, account, filterClosed=False):
        positions = self.safe_list(account, 'positions')
        assets = self.safe_list(account, 'assets', [])
        balances: dict = {}
        for i in range(0, len(assets)):
            entry = assets[i]
            currencyId = self.safe_string(entry, 'asset')
            code = self.safe_currency_code(currencyId)
            crossWalletBalance = self.safe_string(entry, 'crossWalletBalance')
            crossUnPnl = self.safe_string(entry, 'crossUnPnl')
            balances[code] = {
                'crossMargin': Precise.string_add(crossWalletBalance, crossUnPnl),
                'crossWalletBalance': crossWalletBalance,
            }
        result = []
        for i in range(0, len(positions)):
            position = positions[i]
            marketId = self.safe_string(position, 'symbol')
            market = self.safe_market(marketId, None, None, 'contract')
            code = market['quote'] if market['linear'] else market['base']
            maintenanceMargin = self.safe_string(position, 'maintMargin')
            # check for maintenance margin so empty positions are not returned
            isPositionOpen = (maintenanceMargin != '0') and (maintenanceMargin != '0.00000000')
            if not filterClosed or isPositionOpen:
                # sometimes not all the codes are correctly returned...
                if code in balances:
                    parsed = self.parse_account_position(self.extend(position, {
                        'crossMargin': balances[code]['crossMargin'],
                        'crossWalletBalance': balances[code]['crossWalletBalance'],
                    }), market)
                    result.append(parsed)
        return result

    def parse_account_position(self, position, market: Market = None):
        #
        # usdm
        #
        # v3(similar for cross & isolated)
        #
        #    {
        #        "askNotional": "0",                      # in v2
        #        "bidNotional": "0",                      # in v2
        #        "breakEvenPrice": "2.3395788",           # in v2
        #        "entryPrice": "2.34",                    # in v2
        #        "initialMargin": "99.62303962",
        #        "isolated": False,                       # in v2
        #        "isolatedMargin": "0",
        #        "isolatedWallet": "0",
        #        "leverage": "50",                        # in v2
        #        "maintMargin": "11.95476475",
        #        "maxNotional": "25000",                  # in v2
        #        "notional": "-1992.46079250",
        #        "openOrderInitialMargin": "0",           # in v2
        #        "positionAmt": "-849",
        #        "positionInitialMargin": "118.82116614",  # in v2
        #        "positionSide": "BOTH",
        #        "symbol": "WLDUSDT",
        #        "unrealizedProfit": "11.17920750",
        #        "updateTime": "1721995760449",
        #     }
        #
        # coinm
        #
        #     {
        #       "crossMargin": "0.314"
        #       "crossWalletBalance": "34",
        #       "entryPrice": "41021.20000069",
        #       "initialMargin": "0.00024393",
        #       "isolated": False,
        #       "isolatedWallet": "0",
        #       "leverage": "10",
        #       "maintMargin": "0.00002439",
        #       "maxQty": "100",
        #       "notionalValue": "0.00243939",
        #       "openOrderInitialMargin": "0",
        #       "positionInitialMargin": "0.00024393",
        #       "positionSide": "BOTH",
        #       "symbol": "BTCUSD_210625",
        #       "unrealizedProfit": "-0.00000163",
        #     }
        #
        # linear portfolio margin
        #
        #     {
        #         "askNotional": "0",
        #         "bidNotional": "0",
        #         "breakEvenPrice": "0.0"
        #         "entryPrice": "0.0",
        #         "initialMargin": "0",
        #         "leverage": "20",
        #         "maintMargin": "0",
        #         "maxNotional": "25000",
        #         "notional": "0",
        #         "openOrderInitialMargin": "0",
        #         "positionAmt": "0",
        #         "positionInitialMargin": "0",
        #         "positionSide": "SHORT",
        #         "symbol": "CTSIUSDT",
        #         "unrealizedProfit": "0.00000000",
        #         "updateTime": 0,
        #     }
        #
        # inverse portoflio margin
        #
        #     {
        #         "breakEvenPrice": "0.00000000"
        #         "entryPrice": "0.00000000",
        #         "initialMargin": "0",
        #         "leverage": "20",
        #         "maintMargin": "0",
        #         "maxQty": "5000000",
        #         "notionalValue": "0",
        #         "openOrderInitialMargin": "0",
        #         "positionAmt": "0",
        #         "positionInitialMargin": "0",
        #         "positionSide": "SHORT",
        #         "symbol": "TRXUSD_PERP",
        #         "unrealizedProfit": "0.00000000",
        #         "updateTime": 0,
        #     }
        #
        marketId = self.safe_string(position, 'symbol')
        market = self.safe_market(marketId, market, None, 'contract')
        symbol = self.safe_string(market, 'symbol')
        leverageString = self.safe_string(position, 'leverage')
        leverage = int(leverageString) if (leverageString is not None) else None
        initialMarginString = self.safe_string(position, 'initialMargin')
        initialMargin = self.parse_number(initialMarginString)
        initialMarginPercentageString = None
        if leverageString is not None:
            initialMarginPercentageString = Precise.string_div('1', leverageString, 8)
            rational = self.is_round_number(1000 % leverage)
            if not rational:
                initialMarginPercentageString = Precise.string_div(Precise.string_add(initialMarginPercentageString, '1e-8'), '1', 8)
        # to notionalValue
        usdm = ('notional' in position)
        maintenanceMarginString = self.safe_string(position, 'maintMargin')
        maintenanceMargin = self.parse_number(maintenanceMarginString)
        entryPriceString = self.safe_string(position, 'entryPrice')
        entryPrice = self.parse_number(entryPriceString)
        notionalString = self.safe_string_2(position, 'notional', 'notionalValue')
        notionalStringAbs = Precise.string_abs(notionalString)
        notional = self.parse_number(notionalStringAbs)
        contractsString = self.safe_string(position, 'positionAmt')
        contractsStringAbs = Precise.string_abs(contractsString)
        if contractsString is None:
            entryNotional = Precise.string_mul(Precise.string_mul(leverageString, initialMarginString), entryPriceString)
            contractSizeNew = self.safe_string(market, 'contractSize')
            contractsString = Precise.string_div(entryNotional, contractSizeNew)
            contractsStringAbs = Precise.string_div(Precise.string_add(contractsString, '0.5'), '1', 0)
        contracts = self.parse_number(contractsStringAbs)
        leverageBrackets = self.safe_dict(self.options, 'leverageBrackets', {})
        leverageBracket = self.safe_list(leverageBrackets, symbol, [])
        maintenanceMarginPercentageString = None
        for i in range(0, len(leverageBracket)):
            bracket = leverageBracket[i]
            if Precise.string_lt(notionalStringAbs, bracket[0]):
                break
            maintenanceMarginPercentageString = bracket[1]
        maintenanceMarginPercentage = self.parse_number(maintenanceMarginPercentageString)
        unrealizedPnlString = self.safe_string(position, 'unrealizedProfit')
        unrealizedPnl = self.parse_number(unrealizedPnlString)
        timestamp = self.safe_integer(position, 'updateTime')
        if timestamp == 0:
            timestamp = None
        isolated = self.safe_bool(position, 'isolated')
        if isolated is None:
            isolatedMarginRaw = self.safe_string(position, 'isolatedMargin')
            isolated = not Precise.string_eq(isolatedMarginRaw, '0')
        marginMode = None
        collateralString = None
        walletBalance = None
        if isolated:
            marginMode = 'isolated'
            walletBalance = self.safe_string(position, 'isolatedWallet')
            collateralString = Precise.string_add(walletBalance, unrealizedPnlString)
        else:
            marginMode = 'cross'
            walletBalance = self.safe_string(position, 'crossWalletBalance')
            collateralString = self.safe_string(position, 'crossMargin')
        collateral = self.parse_number(collateralString)
        marginRatio = None
        side = None
        percentage = None
        liquidationPriceStringRaw = None
        liquidationPrice = None
        contractSize = self.safe_value(market, 'contractSize')
        contractSizeString = self.number_to_string(contractSize)
        if Precise.string_equals(notionalString, '0'):
            entryPrice = None
        else:
            side = 'short' if Precise.string_lt(notionalString, '0') else 'long'
            marginRatio = self.parse_number(Precise.string_div(Precise.string_add(Precise.string_div(maintenanceMarginString, collateralString), '5e-5'), '1', 4))
            percentage = self.parse_number(Precise.string_mul(Precise.string_div(unrealizedPnlString, initialMarginString, 4), '100'))
            if usdm:
                # calculate liquidation price
                #
                # liquidationPrice = (walletBalance / (contracts * (1 + mmp))) + (entryPrice / (1 + mmp))
                #
                # mmp = maintenanceMarginPercentage
                # where  is negative for long and positive for short
                # TODO: calculate liquidation price for coinm contracts
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.string_add('1', maintenanceMarginPercentageString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.string_add('-1', maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.string_mul('-1', entryPriceSignString)
                leftSide = Precise.string_div(walletBalance, Precise.string_mul(contractsStringAbs, onePlusMaintenanceMarginPercentageString))
                rightSide = Precise.string_div(entryPriceSignString, onePlusMaintenanceMarginPercentageString)
                liquidationPriceStringRaw = Precise.string_add(leftSide, rightSide)
            else:
                # calculate liquidation price
                #
                # liquidationPrice = (contracts * contractSize(1 - mmp)) / (1/entryPrice * contracts * contractSize - walletBalance)
                #
                onePlusMaintenanceMarginPercentageString = None
                entryPriceSignString = entryPriceString
                if side == 'short':
                    onePlusMaintenanceMarginPercentageString = Precise.string_sub('1', maintenanceMarginPercentageString)
                else:
                    onePlusMaintenanceMarginPercentageString = Precise.string_sub('-1', maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.string_mul('-1', entryPriceSignString)
                size = Precise.string_mul(contractsStringAbs, contractSizeString)
                leftSide = Precise.string_mul(size, onePlusMaintenanceMarginPercentageString)
                rightSide = Precise.string_sub(Precise.string_mul(Precise.string_div('1', entryPriceSignString), size), walletBalance)
                liquidationPriceStringRaw = Precise.string_div(leftSide, rightSide)
            pricePrecision = self.precision_from_string(self.safe_string(market['precision'], 'price'))
            pricePrecisionPlusOne = pricePrecision + 1
            pricePrecisionPlusOneString = str(pricePrecisionPlusOne)
            # round half up
            rounder = Precise('5e-' + pricePrecisionPlusOneString)
            rounderString = str(rounder)
            liquidationPriceRoundedString = Precise.string_add(rounderString, liquidationPriceStringRaw)
            truncatedLiquidationPrice = Precise.string_div(liquidationPriceRoundedString, '1', pricePrecision)
            if truncatedLiquidationPrice[0] == '-':
                # user cannot be liquidated
                # since he has more collateral than the size of the position
                truncatedLiquidationPrice = None
            liquidationPrice = self.parse_number(truncatedLiquidationPrice)
        positionSide = self.safe_string(position, 'positionSide')
        hedged = positionSide != 'BOTH'
        return {
            'collateral': collateral,
            'contracts': contracts,
            'contractSize': contractSize,
            'datetime': self.iso8601(timestamp),
            'entryPrice': entryPrice,
            'hedged': hedged,
            'id': None,
            'info': position,
            'initialMargin': initialMargin,
            'initialMarginPercentage': self.parse_number(initialMarginPercentageString),
            'leverage': self.parse_number(leverageString),
            'liquidationPrice': liquidationPrice,
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': maintenanceMarginPercentage,
            'marginMode': marginMode,
            'marginRatio': marginRatio,
            'markPrice': None,
            'notional': notional,
            'percentage': percentage,
            'side': side,
            'symbol': symbol,
            'timestamp': timestamp,
            'unrealizedPnl': unrealizedPnl,
        }

    def parse_position_risk(self, position, market: Market = None):
        #
        # usdm
        #
        #      {
        #          adl: "2",                            # not in v2
        #          askNotional: "0",                    # not in v2
        #          bidNotional: "0",                    # not in v2
        #          breakEvenPrice: "2.349356735",
        #          entryPrice: "2.3483",
        #          initialMargin: "2.39560000",         # not in v2
        #          isolatedMargin: "0",
        #          isolatedWallet: "0",
        #          liquidationPrice: "0",
        #          maintMargin: "0.07186800",           # not in v2
        #          marginAsset: "USDT",                 # not in v2
        #          markPrice: "2.39560000",
        #          notional: "11.97800000",
        #          openOrderInitialMargin: "0",         # not in v2
        #          positionAmt: "5",
        #          positionInitialMargin: "2.39560000",  # not in v2
        #          positionSide: "BOTH",
        #          symbol: "WLDUSDT",
        #          unRealizedProfit: "0.23650000",
        #          updateTime: "1722062678998",
        #          # the below fields are only in v2
        #          adlQuantile: "2",
        #          isAutoAddMargin: "false",
        #          isolated: False,
        #          leverage: "5",
        #          marginType: "cross",
        #          maxNotionalValue: "6000000",
        #      }
        #
        # coinm
        #
        #     {
        #          "entryPrice": "37643.10000021",
        #          "isAutoAddMargin": "false",
        #          "isolatedMargin": "0.00274471",
        #          "isolatedWallet": "0.00268058"
        #          "leverage": "2",
        #          "liquidationPrice": "25119.97445760",
        #          "marginType": "isolated",
        #          "markPrice": "38103.05510455",
        #          "maxQty": "1500",
        #          "notionalValue": "0.00524892",
        #          "positionAmt": "2",
        #          "positionSide": "BOTH",
        #          "symbol": "BTCUSD_PERP",
        #          "unRealizedProfit": "0.00006413",
        #     }
        #
        # inverse portfolio margin
        #
        #     {
        #          "breakEvenPrice": "2423.368960034"
        #          "entryPrice": "2422.400000007",
        #          "leverage": "100",
        #          "liquidationPrice": "293.57678898",
        #          "markPrice": "2424.51267823",
        #          "maxQty": "15",
        #          "notionalValue": "0.00412454",
        #          "positionAmt": "1",
        #          "positionSide": "LONG",
        #          "symbol": "ETHUSD_PERP",
        #          "unRealizedProfit": "0.0000036",
        #          "updateTime": 1707371941861,
        #     }
        #
        # linear portfolio margin
        #
        #     {
        #         "breakEvenPrice": "44542.81"
        #         "entryPrice": "44525.0",
        #         "leverage": "100",
        #         "liquidationPrice": "38007.16308568",
        #         "markPrice": "45464.1735922",
        #         "maxNotionalValue": "500000.0",
        #         "notional": "454.64173592",
        #         "positionAmt": "0.01",
        #         "positionSide": "LONG",
        #         "symbol": "BTCUSDT",
        #         "unRealizedProfit": "9.39173592",
        #         "updateTime": 1707371879042,
        #     }
        #
        marketId = self.safe_string(position, 'symbol')
        market = self.safe_market(marketId, market, None, 'contract')
        symbol = self.safe_string(market, 'symbol')
        isolatedMarginString = self.safe_string(position, 'isolatedMargin')
        leverageBrackets = self.safe_dict(self.options, 'leverageBrackets', {})
        leverageBracket = self.safe_list(leverageBrackets, symbol, [])
        notionalString = self.safe_string_2(position, 'notional', 'notionalValue')
        notionalStringAbs = Precise.string_abs(notionalString)
        maintenanceMarginPercentageString = None
        for i in range(0, len(leverageBracket)):
            bracket = leverageBracket[i]
            if Precise.string_lt(notionalStringAbs, bracket[0]):
                break
            maintenanceMarginPercentageString = bracket[1]
        notional = self.parse_number(notionalStringAbs)
        contractsAbs = Precise.string_abs(self.safe_string(position, 'positionAmt'))
        contracts = self.parse_number(contractsAbs)
        unrealizedPnlString = self.safe_string_2(position, 'unRealizedProfit', 'unrealizedProfit')
        unrealizedPnl = self.parse_number(unrealizedPnlString)
        liquidationPriceString = self.omit_zero(self.safe_string(position, 'liquidationPrice'))
        liquidationPrice = self.parse_number(liquidationPriceString)
        collateralString = None
        marginMode = self.safe_string(position, 'marginType')
        if marginMode is None and isolatedMarginString is not None:
            marginMode = 'cross' if Precise.string_eq(isolatedMarginString, '0') else 'isolated'
        side = None
        if Precise.string_gt(notionalString, '0'):
            side = 'long'
        elif Precise.string_lt(notionalString, '0'):
            side = 'short'
        entryPriceString = self.safe_string(position, 'entryPrice')
        entryPrice = self.parse_number(entryPriceString)
        contractSize = self.safe_value(market, 'contractSize')
        contractSizeString = self.number_to_string(contractSize)
        # to notionalValue
        linear = ('notional' in position)
        isolatedBool = self.safe_bool(position, 'isolated')
        if marginMode is None and isolatedBool is not None:
            marginMode = 'isolated' if isolatedBool else 'cross'
        if marginMode == 'cross':
            # calculate collateral
            precision = self.safe_dict(market, 'precision', {})
            basePrecisionValue = self.safe_string(precision, 'base')
            quotePrecisionValue = self.safe_string_2(precision, 'quote', 'price')
            precisionIsUndefined = (basePrecisionValue is None) and (quotePrecisionValue is None)
            if not precisionIsUndefined:
                if linear:
                    # walletBalance = (liquidationPrice * (1 + mmp)  entryPrice) * contracts
                    onePlusMaintenanceMarginPercentageString = None
                    entryPriceSignString = entryPriceString
                    if side == 'short':
                        onePlusMaintenanceMarginPercentageString = Precise.string_add('1', maintenanceMarginPercentageString)
                        entryPriceSignString = Precise.string_mul('-1', entryPriceSignString)
                    else:
                        onePlusMaintenanceMarginPercentageString = Precise.string_add('-1', maintenanceMarginPercentageString)
                    inner = Precise.string_mul(liquidationPriceString, onePlusMaintenanceMarginPercentageString)
                    leftSide = Precise.string_add(inner, entryPriceSignString)
                    quotePrecision = self.precision_from_string(self.safe_string_2(precision, 'quote', 'price'))
                    if quotePrecision is not None:
                        collateralString = Precise.string_div(Precise.string_mul(leftSide, contractsAbs), '1', quotePrecision)
                else:
                    # walletBalance = (contracts * contractSize) * (1/entryPrice - (1 - mmp) / liquidationPrice)
                    onePlusMaintenanceMarginPercentageString = None
                    entryPriceSignString = entryPriceString
                    if side == 'short':
                        onePlusMaintenanceMarginPercentageString = Precise.string_sub('1', maintenanceMarginPercentageString)
                    else:
                        onePlusMaintenanceMarginPercentageString = Precise.string_sub('-1', maintenanceMarginPercentageString)
                        entryPriceSignString = Precise.string_mul('-1', entryPriceSignString)
                    leftSide = Precise.string_mul(contractsAbs, contractSizeString)
                    rightSide = Precise.string_sub(Precise.string_div('1', entryPriceSignString), Precise.string_div(onePlusMaintenanceMarginPercentageString, liquidationPriceString))
                    basePrecision = self.precision_from_string(self.safe_string(precision, 'base'))
                    if basePrecision is not None:
                        collateralString = Precise.string_div(Precise.string_mul(leftSide, rightSide), '1', basePrecision)
        else:
            collateralString = self.safe_string(position, 'isolatedMargin')
        collateralString = '0' if (collateralString is None) else collateralString
        collateral = self.parse_number(collateralString)
        markPrice = self.parse_number(self.omit_zero(self.safe_string(position, 'markPrice')))
        timestamp = self.safe_integer(position, 'updateTime')
        if timestamp == 0:
            timestamp = None
        maintenanceMarginPercentage = self.parse_number(maintenanceMarginPercentageString)
        maintenanceMarginString = Precise.string_mul(maintenanceMarginPercentageString, notionalStringAbs)
        if maintenanceMarginString is None:
            # for a while, self new value was a backup to the existing calculations, but in future we might prioritize self
            maintenanceMarginString = self.safe_string(position, 'maintMargin')
        maintenanceMargin = self.parse_number(maintenanceMarginString)
        initialMarginString = None
        initialMarginPercentageString = None
        leverageString = self.safe_string(position, 'leverage')
        if leverageString is not None:
            leverage = int(leverageString)
            rational = self.is_round_number(1000 % leverage)
            initialMarginPercentageString = Precise.string_div('1', leverageString, 8)
            if not rational:
                initialMarginPercentageString = Precise.string_add(initialMarginPercentageString, '1e-8')
            unrounded = Precise.string_mul(notionalStringAbs, initialMarginPercentageString)
            initialMarginString = Precise.string_div(unrounded, '1', 8)
        else:
            initialMarginString = self.safe_string(position, 'initialMargin')
            unrounded = Precise.string_mul(initialMarginString, '1')
            initialMarginPercentageString = Precise.string_div(unrounded, notionalStringAbs, 8)
        marginRatio = None
        percentage = None
        if not Precise.string_equals(collateralString, '0'):
            marginRatio = self.parse_number(Precise.string_div(Precise.string_add(Precise.string_div(maintenanceMarginString, collateralString), '5e-5'), '1', 4))
            percentage = self.parse_number(Precise.string_mul(Precise.string_div(unrealizedPnlString, initialMarginString, 4), '100'))
        positionSide = self.safe_string(position, 'positionSide')
        hedged = positionSide != 'BOTH'
        return {
            'collateral': collateral,
            'contractSize': contractSize,
            'contracts': contracts,
            'datetime': self.iso8601(timestamp),
            'entryPrice': entryPrice,
            'hedged': hedged,
            'id': None,
            'info': position,
            'initialMargin': self.parse_number(initialMarginString),
            'initialMarginPercentage': self.parse_number(initialMarginPercentageString),
            'leverage': self.parse_number(leverageString),
            'liquidationPrice': liquidationPrice,
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': maintenanceMarginPercentage,
            'marginMode': marginMode,
            'marginRatio': marginRatio,
            'marginType': marginMode,  # deprecated
            'markPrice': markPrice,
            'notional': notional,
            'percentage': percentage,
            'side': side,
            'stopLossPrice': None,
            'symbol': symbol,
            'takeProfitPrice': None,
            'timestamp': timestamp,
            'unrealizedPnl': unrealizedPnl,
        }

    def load_leverage_brackets(self, reload=False, params={}):
        self.load_markets()
        # by default cache the leverage bracket
        # it contains useful stuff like the maintenance margin and initial margin for positions
        leverageBrackets = self.safe_dict(self.options, 'leverageBrackets')
        if (leverageBrackets is None) or (reload):
            defaultType = self.safe_string(self.options, 'defaultType', 'future')
            type = self.safe_string(params, 'type', defaultType)
            query = self.omit(params, 'type')
            subType = None
            subType, params = self.handle_sub_type_and_params('loadLeverageBrackets', None, params, 'linear')
            isPortfolioMargin = None
            isPortfolioMargin, params = self.handle_option_and_params_2(params, 'loadLeverageBrackets', 'papi', 'portfolioMargin', False)
            response = None
            leveragesFromOutside = self.safe_value(params, 'leveragesFromOutside', None)
            if not leveragesFromOutside:
                leveragesFromOutside = self.safe_value(self.options, 'leveragesFromOutside', None)
            if not leveragesFromOutside or reload:
                if self.is_linear(type, subType):
                    if isPortfolioMargin:
                        response = self.papiGetUmLeverageBracket(query)
                    else:
                        response = self.fapiPrivateGetLeverageBracket(query)
                elif self.is_inverse(type, subType):
                    if isPortfolioMargin:
                        response = self.papiGetCmLeverageBracket(query)
                    else:
                        response = self.dapiPrivateV2GetLeverageBracket(query)
                else:
                    raise NotSupported(self.id + ' loadLeverageBrackets() supports linear and inverse contracts only')
                fetchLeveragesCallback = self.safe_value(params, 'fetchLeveragesCallback', None)
                if not fetchLeveragesCallback:
                    fetchLeveragesCallback = self.safe_value(self.options, 'fetchLeveragesCallback', None)
                if fetchLeveragesCallback:
                    fetchLeveragesCallback(response)
                    self.omit(params, 'fetchLeveragesCallback')
                    self.omit(self.options, 'fetchLeveragesCallback')
            else:
                response = leveragesFromOutside
                self.omit(params, 'leveragesFromOutside')
                self.omit(self.options, 'leveragesFromOutside')
            self.options['leverageBrackets'] = {}
            for i in range(0, len(response)):
                entry = response[i]
                marketId = self.safe_string(entry, 'symbol')
                symbol = self.safe_symbol(marketId, None, None, 'contract')
                brackets = self.safe_list(entry, 'brackets', [])
                result = []
                for j in range(0, len(brackets)):
                    bracket = brackets[j]
                    floorValue = self.safe_string_2(bracket, 'notionalFloor', 'qtyFloor')
                    maintenanceMarginPercentage = self.safe_string(bracket, 'maintMarginRatio')
                    result.append([floorValue, maintenanceMarginPercentage])
                self.options['leverageBrackets'][symbol] = result
        return self.options['leverageBrackets']

    def fetch_leverage_tiers(self, symbols: Strings = None, params={}) -> LeverageTiers:
        """
        retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Notional-and-Leverage-Brackets
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Notional-Bracket-for-Symbol
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/UM-Notional-and-Leverage-Brackets
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/CM-Notional-and-Leverage-Brackets

        :param str[]|None symbols: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch the leverage tiers for a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a dictionary of `leverage tiers structures <https://docs.ccxt.com/#/?id=leverage-tiers-structure>`, indexed by market symbols
        """
        self.load_markets()
        type = None
        type, params = self.handle_market_type_and_params('fetchLeverageTiers', None, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchLeverageTiers', None, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchLeverageTiers', 'papi', 'portfolioMargin', False)
        response = None
        if self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmLeverageBracket(params)
            else:
                response = self.fapiPrivateGetLeverageBracket(params)
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmLeverageBracket(params)
            else:
                response = self.dapiPrivateV2GetLeverageBracket(params)
        else:
            raise NotSupported(self.id + ' fetchLeverageTiers() supports linear and inverse contracts only')
        #
        # usdm
        #
        #    [
        #        {
        #            "brackets": [
        #                {
        #                    "bracket": 1,
        #                    "cum": 0.0
        #                    "initialLeverage": 50,
        #                    "maintMarginRatio": 0.01,
        #                    "notionalCap": 50000,
        #                    "notionalFloor": 0,
        #                },
        #                ...
        #            ],
        #            "symbol": "SUSHIUSDT",
        #        }
        #    ]
        #
        # coinm
        #
        #     [
        #         {
        #             "brackets":[
        #                 {
        #                     "bracket":1,
        #                     "cum":0.0
        #                     "initialLeverage":20,
        #                     "maintMarginRatio":0.0185,
        #                     "qtyCap":500000,
        #                     "qtyFloor":0,
        #                 }
        #             ],
        #             "symbol":"XRPUSD_210326",
        #         }
        #     ]
        #
        return self.parse_leverage_tiers(response, symbols, 'symbol')

    def parse_market_leverage_tiers(self, info, market: Market = None) -> List[LeverageTier]:
        """
 @ignore
        :param dict info: Exchange response for 1 market
        :param dict market: CCXT market
        """
        #
        #    {
        #        "brackets": [
        #            {
        #                "bracket": 1,
        #                "cum": 0.0
        #                "initialLeverage": 50,
        #                "maintMarginRatio": 0.01,
        #                "notionalCap": 50000,
        #                "notionalFloor": 0,
        #            },
        #            ...
        #        ],
        #        "symbol": "SUSHIUSDT",
        #    }
        #
        marketId = self.safe_string(info, 'symbol')
        market = self.safe_market(marketId, market, None, 'contract')
        brackets = self.safe_list(info, 'brackets', [])
        tiers = []
        for j in range(0, len(brackets)):
            bracket = brackets[j]
            tiers.append({
                'currency': market['quote'],
                'info': bracket,
                'maintenanceMarginRate': self.safe_number(bracket, 'maintMarginRatio'),
                'maxLeverage': self.safe_number(bracket, 'initialLeverage'),
                'maxNotional': self.safe_number_2(bracket, 'notionalCap', 'qtyCap'),
                'minNotional': self.safe_number_2(bracket, 'notionalFloor', 'qtyFloor'),
                'symbol': self.safe_symbol(marketId, market),
                'tier': self.safe_number(bracket, 'bracket'),
            })
        return tiers

    def fetch_position(self, symbol: str, params={}):
        """
        fetch data on an open position

        https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information

        :param str symbol: unified market symbol of the market the position is held in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `position structure <https://docs.ccxt.com/#/?id=position-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if not market['option']:
            raise NotSupported(self.id + ' fetchPosition() supports option markets only')
        request: dict = {
            'symbol': market['id'],
        }
        response = self.eapiPrivateGetPosition(self.extend(request, params))
        #
        #     [
        #         {
        #             "entryPrice": "27.70000000",
        #             "expiryDate": 1682496000000,
        #             "markPrice": "20.5",
        #             "markValue": "10.250000000",
        #             "optionSide": "CALL",
        #             "positionCost": "13.85000000",
        #             "priceScale": 1,
        #             "quantity": "0.50000000",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT",
        #             "reducibleQty": "0.50000000",
        #             "ror": "-0.2599",
        #             "side": "LONG",
        #             "strikePrice": "1850.00000000",
        #             "symbol": "ETH-230426-1850-C",
        #             "time": 1682492427106,
        #             "unrealizedPNL": "-3.600000000",
        #         }
        #     ]
        #
        return self.parse_position(response[0], market)

    def fetch_option_positions(self, symbols: Strings = None, params={}):
        """
        fetch data on open options positions

        https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information

        :param str[]|None symbols: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `position structures <https://docs.ccxt.com/#/?id=position-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols)
        request: dict = {}
        market = None
        if symbols is not None:
            symbol = None
            if isinstance(symbols, list):
                symbolsLength = len(symbols)
                if symbolsLength > 1:
                    raise BadRequest(self.id + ' fetchPositions() symbols argument cannot contain more than 1 symbol')
                symbol = symbols[0]
            else:
                symbol = symbols
            market = self.market(symbol)
            request['symbol'] = market['id']
        response = self.eapiPrivateGetPosition(self.extend(request, params))
        #
        #     [
        #         {
        #             "entryPrice": "27.70000000",
        #             "expiryDate": 1682496000000,
        #             "markPrice": "20.5",
        #             "markValue": "10.250000000",
        #             "optionSide": "CALL",
        #             "positionCost": "13.85000000",
        #             "priceScale": 1,
        #             "quantity": "0.50000000",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT",
        #             "reducibleQty": "0.50000000",
        #             "ror": "-0.2599",
        #             "side": "LONG",
        #             "strikePrice": "1850.00000000",
        #             "symbol": "ETH-230426-1850-C",
        #             "time": 1682492427106,
        #             "unrealizedPNL": "-3.600000000",
        #         }
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_position(response[i], market))
        return self.filter_by_array_positions(result, 'symbol', symbols, False)

    def parse_position(self, position: dict, market: Market = None):
        #
        #     {
        #         "entryPrice": "27.70000000",
        #         "expiryDate": 1682496000000,
        #         "markPrice": "20.5",
        #         "markValue": "10.250000000",
        #         "optionSide": "CALL",
        #         "positionCost": "13.85000000",
        #         "priceScale": 1,
        #         "quantity": "0.50000000",
        #         "quantityScale": 2,
        #         "quoteAsset": "USDT",
        #         "reducibleQty": "0.50000000",
        #         "ror": "-0.2599",
        #         "side": "LONG",
        #         "strikePrice": "1850.00000000",
        #         "symbol": "ETH-230426-1850-C",
        #         "time": 1682492427106,
        #         "unrealizedPNL": "-3.600000000",
        #     }
        #
        marketId = self.safe_string(position, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        side = self.safe_string_lower(position, 'side')
        quantity = self.safe_string(position, 'quantity')
        if side != 'long':
            quantity = Precise.string_mul('-1', quantity)
        timestamp = self.safe_integer(position, 'time')
        return self.safe_position({
            'collateral': self.safe_number(position, 'positionCost'),
            'contracts': self.parse_number(quantity),
            'contractSize': None,
            'datetime': self.iso8601(timestamp),
            'entryPrice': self.safe_number(position, 'entryPrice'),
            'hedged': None,
            'id': None,
            'info': position,
            'initialMargin': None,
            'initialMarginPercentage': None,
            'leverage': None,
            'liquidationPrice': None,
            'maintenanceMargin': None,
            'maintenanceMarginPercentage': None,
            'marginMode': None,
            'marginRatio': None,
            'markPrice': self.safe_number(position, 'markPrice'),
            'notional': self.safe_number(position, 'markValue'),
            'percentage': None,
            'side': side,
            'symbol': symbol,
            'timestamp': timestamp,
            'unrealizedPnl': self.safe_number(position, 'unrealizedPNL'),
        })

    def fetch_positions(self, symbols: Strings = None, params={}):
        """
        fetch all open positions

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Position-Information
        https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information

        :param str[] [symbols]: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param dict [params.params]: extra parameters specific to the exchange API endpoint
        :param str [params.method]: method name to call, "positionRisk", "account" or "option", default is "positionRisk"
        :param bool [params.useV2]: set to True if you want to use the obsolete endpoint, where some more additional fields were provided
        :returns dict[]: a list of `position structure <https://docs.ccxt.com/#/?id=position-structure>`
        """
        defaultMethod = None
        defaultMethod, params = self.handle_option_and_params(params, 'fetchPositions', 'method')
        if defaultMethod is None:
            options = self.safe_dict(self.options, 'fetchPositions')
            if options is None:
                defaultMethod = self.safe_string(self.options, 'fetchPositions', 'positionRisk')
            else:
                defaultMethod = 'positionRisk'
        if defaultMethod == 'positionRisk':
            return self.fetch_positions_risk(symbols, params)
        elif defaultMethod == 'account':
            return self.fetch_account_positions(symbols, params)
        elif defaultMethod == 'option':
            return self.fetch_option_positions(symbols, params)
        else:
            raise NotSupported(self.id + '.options["fetchPositions"]["method"] or params["method"] = "' + defaultMethod + '" is invalid, please choose between "account", "positionRisk" and "option"')

    def fetch_account_positions(self, symbols: Strings = None, params={}):
        """
 @ignore
        fetch account positions

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Position-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V3

        :param str[] [symbols]: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch positions in a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :param boolean [params.filterClosed]: set to True if you would like to filter out closed positions, default is False
        :param boolean [params.useV2]: set to True if you want to use obsolete endpoint, where some more additional fields were provided
        :returns dict: data on account positions
        """
        if symbols is not None:
            if not isinstance(symbols, list):
                raise ArgumentsRequired(self.id + ' fetchPositions() requires an array argument for symbols')
        self.load_markets()
        self.load_leverage_brackets(False, params)
        defaultType = self.safe_string(self.options, 'defaultType', 'future')
        type = self.safe_string(params, 'type', defaultType)
        params = self.omit(params, 'type')
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchAccountPositions', None, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchAccountPositions', 'papi', 'portfolioMargin', False)
        response = None
        if self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmAccount(params)
            else:
                useV2 = None
                defaultUseV2 = self.safe_bool(self.options, 'useFapiPrivateV2', False)
                useV2, params = self.handle_option_and_params(params, 'fetchAccountPositions', 'useV2', defaultUseV2)
                if not useV2:
                    response = self.fapiPrivateV3GetAccount(params)
                else:
                    response = self.fapiPrivateV2GetAccount(params)
                #
                #    {
                #        "assets": [
                #            {
                #                "asset": "USDT",
                #                "availableBalance": "11.39916777",
                #                "crossUnPnl": "11.17920750",
                #                "crossWalletBalance": "72.72317863",
                #                "initialMargin": "99.62303962",
                #                "maintMargin": "11.95476475",
                #                "marginAvailable": True                   # in v2
                #                "marginBalance": "83.90238613",
                #                "maxWithdrawAmount": "11.39916777",
                #                "openOrderInitialMargin": "0.00000000",
                #                "positionInitialMargin": "99.62303962",
                #                "unrealizedProfit": "11.17920750",
                #                "updateTime": "1721995605338",
                #                "walletBalance": "72.72317863",
                #            },
                #            ... and some few supported settle currencies: USDC, BTC, ETH, BNB ..
                #        ],
                #        "availableBalance": "11.39894857",
                #        "canDeposit": True,                               # in v2
                #        "canTrade": True,                                 # in v2
                #        "canWithdraw": True,                              # in v2
                #        "feeBurn": True,                                  # in v2
                #        "feeTier": "0",                                   # in v2
                #        "maxWithdrawAmount": "11.39894857",
                #        "multiAssetsMargin": True                         # in v2
                #        "totalCrossUnPnl": "11.17675690",
                #        "totalCrossWalletBalance": "99.84331553",
                #        "totalInitialMargin": "99.62112386",
                #        "totalMaintMargin": "11.95453485",
                #        "totalMarginBalance": "111.02007243",
                #        "totalOpenOrderInitialMargin": "0.00000000",
                #        "totalPositionInitialMargin": "99.62112386",
                #        "totalUnrealizedProfit": "11.17675690",
                #        "totalWalletBalance": "99.84331553",
                #        "tradeGroupId": "-1",                             # in v2
                #        "updateTime": "0",                                # in v2
                #        "positions": [
                #            {
                #                "askNotional": "0"                       # in v2
                #                "bidNotional": "0",                      # in v2
                #                "breakEvenPrice": "2.3395788",           # in v2
                #                "entryPrice": "2.34",                    # in v2
                #                "initialMargin": "99.62303962",
                #                "isolated": False,                       # in v2
                #                "isolatedMargin": "0",
                #                "isolatedWallet": "0",
                #                "leverage": "50",                        # in v2
                #                "maintMargin": "11.95476475",
                #                "maxNotional": "25000",                  # in v2
                #                "notional": "-1992.46079250",
                #                "openOrderInitialMargin": "0",           # in v2
                #                "positionAmt": "-849",
                #                "positionInitialMargin": "118.82116614",  # in v2
                #                "positionSide": "BOTH",
                #                "symbol": "WLDUSDT",
                #                "unrealizedProfit": "11.17920750",
                #                "updateTime": "1721995760449"
                #            },
                #            ...
                #        ]
                #    }
                #
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmAccount(params)
            else:
                response = self.dapiPrivateGetAccount(params)
        else:
            raise NotSupported(self.id + ' fetchPositions() supports linear and inverse contracts only')
        filterClosed = None
        filterClosed, params = self.handle_option_and_params(params, 'fetchAccountPositions', 'filterClosed', False)
        result = self.parse_account_positions(response, filterClosed)
        symbols = self.market_symbols(symbols)
        return self.filter_by_array_positions(result, 'symbol', symbols, False)

    def fetch_positions_risk(self, symbols: Strings = None, params={}):
        """
 @ignore
        fetch positions risk

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Position-Information
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-UM-Position-Information
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-CM-Position-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3

        :param str[]|None symbols: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch positions for a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :param boolean [params.useV2]: set to True if you want to use the obsolete endpoint, where some more additional fields were provided
        :returns dict: data on the positions risk
        """
        if symbols is not None:
            if not isinstance(symbols, list):
                raise ArgumentsRequired(self.id + ' fetchPositionsRisk() requires an array argument for symbols')
        self.load_markets()
        self.load_leverage_brackets(False, params)
        request: dict = {}
        defaultType = 'future'
        defaultType = self.safe_string(self.options, 'defaultType', defaultType)
        type = self.safe_string(params, 'type', defaultType)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchPositionsRisk', None, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchPositionsRisk', 'papi', 'portfolioMargin', False)
        params = self.omit(params, 'type')
        response = None
        if self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmPositionRisk(self.extend(request, params))
            else:
                useV2 = None
                defaultUseV2 = self.safe_bool(self.options, 'useFapiPrivateV2', False)
                useV2, params = self.handle_option_and_params(params, 'fetchPositionsRisk', 'useV2', defaultUseV2)
                params = self.extend(request, params)
                if not useV2:
                    response = self.fapiPrivateV3GetPositionRisk(params)
                else:
                    response = self.fapiPrivateV2GetPositionRisk(params)
                #
                # [
                #  {
                #     adl: "2",                            # added in v3
                #     askNotional: "0",                    # added in v3
                #     bidNotional: "0",                    # added in v3
                #     breakEvenPrice: "2.349356735",
                #     entryPrice: "2.3483",
                #     initialMargin: "2.39560000",         # added in v3
                #     isolatedMargin: "0",
                #     isolatedWallet: "0",
                #     liquidationPrice: "0",
                #     maintMargin: "0.07186800",           # added in v3
                #     marginAsset: "USDT",                 # added in v3
                #     markPrice: "2.39560000",
                #     notional: "11.97800000",
                #     openOrderInitialMargin: "0",         # added in v3
                #     positionAmt: "5",
                #     positionInitialMargin: "2.39560000",  # added in v3
                #     positionSide: "BOTH",
                #     symbol: "WLDUSDT",
                #     unRealizedProfit: "0.23650000",
                #     updateTime: "1722062678998",
                #  },
                # ]
                #
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmPositionRisk(self.extend(request, params))
            else:
                response = self.dapiPrivateGetPositionRisk(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchPositionsRisk() supports linear and inverse contracts only')
        #  ### Response examples  ###
        #
        # For One-way position mode:
        #
        #     [
        #         {
        #             "entryPrice": "0.00000",
        #             "isAutoAddMargin": "false",
        #             "isolatedMargin": "0.00000000",
        #             "leverage": "10",
        #             "liquidationPrice": "0",
        #             "marginType": "isolated",
        #             "markPrice": "6679.50671178",
        #             "maxNotionalValue": "20000000",
        #             "positionAmt": "0.000",
        #             "positionSide": "BOTH",
        #             "symbol": "BTCUSDT",
        #             "unRealizedProfit": "0.00000000",
        #             "updateTime": 0
        #        }
        #     ]
        #
        # For Hedge position mode:
        #
        #     [
        #         {
        #             "entryPrice": "6563.66500",
        #             "isAutoAddMargin": "false",
        #             "isolatedMargin": "15517.54150468",
        #             "leverage": "10",
        #             "liquidationPrice": "5930.78",
        #             "marginType": "isolated",
        #             "markPrice": "6679.50671178",
        #             "maxNotionalValue": "20000000",
        #             "positionAmt": "20.000",  # negative value for 'SHORT'
        #             "positionSide": "LONG",
        #             "symbol": "BTCUSDT",
        #             "unRealizedProfit": "2316.83423560"
        #             "updateTime": 1625474304765
        #         },
        #         .. second dict is similar, but with `positionSide: SHORT`
        #     ]
        #
        # inverse portfolio margin:
        #
        #     [
        #         {
        #             "breakEvenPrice": "2423.368960034",
        #             "entryPrice": "2422.400000007",
        #             "leverage": "100",
        #             "liquidationPrice": "293.57678898",
        #             "markPrice": "2424.51267823",
        #             "maxQty": "15",
        #             "notionalValue": "0.00412454",
        #             "positionAmt": "1",
        #             "positionSide": "LONG",
        #             "symbol": "ETHUSD_PERP",
        #             "unRealizedProfit": "0.0000036",
        #             "updateTime": 1707371941861,
        #         }
        #     ]
        #
        # linear portfolio margin:
        #
        #     [
        #         {
        #             "breakEvenPrice": "44542.81",
        #             "entryPrice": "44525.0",
        #             "leverage": "100",
        #             "liquidationPrice": "38007.16308568",
        #             "markPrice": "45464.1735922",
        #             "maxNotionalValue": "500000.0",
        #             "notional": "454.64173592",
        #             "positionAmt": "0.01",
        #             "positionSide": "LONG",
        #             "symbol": "BTCUSDT",
        #             "unRealizedProfit": "9.39173592",
        #             "updateTime": 1707371879042,
        #         }
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            rawPosition = response[i]
            entryPriceString = self.safe_string(rawPosition, 'entryPrice')
            if Precise.string_gt(entryPriceString, '0'):
                result.append(self.parse_position_risk(response[i]))
        symbols = self.market_symbols(symbols)
        return self.filter_by_array_positions(result, 'symbol', symbols, False)

    def fetch_funding_history(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch the history of funding payments paid and received on self account

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Income-History
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Get-Income-History
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Income-History
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Income-History

        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch funding history for
        :param int [limit]: the maximum number of funding history structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: timestamp in ms of the latest funding history entry
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch the funding history for a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a `funding history structure <https://docs.ccxt.com/#/?id=funding-history-structure>`
        """
        self.load_markets()
        market = None
        request: dict = {
            'incomeType': 'FUNDING_FEE',  # "TRANSFER""WELCOME_BONUS", "REALIZED_PNL""FUNDING_FEE", "COMMISSION" and "INSURANCE_CLEAR"
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
            if not market['swap']:
                raise NotSupported(self.id + ' fetchFundingHistory() supports swap contracts only')
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchFundingHistory', market, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchFundingHistory', 'papi', 'portfolioMargin', False)
        request, params = self.handle_until_option('endTime', request, params)
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        defaultType = self.safe_string_2(self.options, 'fetchFundingHistory', 'defaultType', 'future')
        type = self.safe_string(params, 'type', defaultType)
        params = self.omit(params, 'type')
        response = None
        if self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmIncome(self.extend(request, params))
            else:
                response = self.fapiPrivateGetIncome(self.extend(request, params))
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmIncome(self.extend(request, params))
            else:
                response = self.dapiPrivateGetIncome(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchFundingHistory() supports linear and inverse contracts only')
        return self.parse_incomes(response, market, since, limit)

    def set_leverage(self, leverage: Int, symbol: Str = None, params={}):
        """
        set the level of leverage for a market

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Change-Initial-Leverage
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-UM-Initial-Leverage
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-CM-Initial-Leverage

        :param float leverage: the rate of leverage
        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to set the leverage for a trading pair in a portfolio margin account
        :returns dict: response from the exchange
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' setLeverage() requires a symbol argument')
        # WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        # AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (leverage < 1) or (leverage > 125):
            raise BadRequest(self.id + ' leverage should be between 1 and 125')
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'leverage': leverage,
            'symbol': market['id'],
        }
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'setLeverage', 'papi', 'portfolioMargin', False)
        response = None
        if market['linear']:
            if isPortfolioMargin:
                response = self.papiPostUmLeverage(self.extend(request, params))
            else:
                response = self.fapiPrivatePostLeverage(self.extend(request, params))
        elif market['inverse']:
            if isPortfolioMargin:
                response = self.papiPostCmLeverage(self.extend(request, params))
            else:
                response = self.dapiPrivatePostLeverage(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' setLeverage() supports linear and inverse contracts only')
        return response

    def set_margin_mode(self, marginMode: str, symbol: Str = None, params={}):
        """
        set margin mode to 'cross' or 'isolated'

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Change-Margin-Type

        :param str marginMode: 'cross' or 'isolated'
        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' setMarginMode() requires a symbol argument')
        #
        # {"code": -4048 , "msg": "Margin type cannot be changed if there exists position."}
        #
        # or
        #
        # {"code": 200, "msg": "success"}
        #
        marginMode = marginMode.upper()
        if marginMode == 'CROSS':
            marginMode = 'CROSSED'
        if (marginMode != 'ISOLATED') and (marginMode != 'CROSSED'):
            raise BadRequest(self.id + ' marginMode must be either isolated or cross')
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
            'marginType': marginMode,
        }
        response = None
        try:
            if market['linear']:
                response = self.fapiPrivatePostMarginType(self.extend(request, params))
            elif market['inverse']:
                response = self.dapiPrivatePostMarginType(self.extend(request, params))
            else:
                raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only')
        except Exception as e:
            # not an error
            # https://github.com/ccxt/ccxt/issues/11268
            # https://github.com/ccxt/ccxt/pull/11624
            # POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
            # binanceusdm
            if isinstance(e, MarginModeAlreadySet):
                throwMarginModeAlreadySet = self.safe_bool(self.options, 'throwMarginModeAlreadySet', False)
                if throwMarginModeAlreadySet:
                    raise e
                else:
                    response = {'code': -4046, 'msg': 'No need to change margin type.'}
            else:
                raise e
        return response

    def set_position_mode(self, hedged: bool, symbol: Str = None, params={}):
        """
        set hedged to True or False for a market

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Position-Mode
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Change-Position-Mode
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Current-Position-Mode
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Current-Position-Mode

        :param bool hedged: set to True to use dualSidePosition
        :param str symbol: not used by binance setPositionMode()
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to set the position mode for a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: response from the exchange
        """
        defaultType = self.safe_string(self.options, 'defaultType', 'future')
        type = self.safe_string(params, 'type', defaultType)
        params = self.omit(params, ['type'])
        subType = None
        subType, params = self.handle_sub_type_and_params('setPositionMode', None, params)
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'setPositionMode', 'papi', 'portfolioMargin', False)
        dualSidePosition = None
        if hedged:
            dualSidePosition = 'true'
        else:
            dualSidePosition = 'false'
        request: dict = {
            'dualSidePosition': dualSidePosition,
        }
        response = None
        if self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiPostCmPositionSideDual(self.extend(request, params))
            else:
                response = self.dapiPrivatePostPositionSideDual(self.extend(request, params))
        elif self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiPostUmPositionSideDual(self.extend(request, params))
            else:
                response = self.fapiPrivatePostPositionSideDual(self.extend(request, params))
        else:
            raise BadRequest(self.id + ' setPositionMode() supports linear and inverse contracts only')
        #
        #     {
        #       "code": 200,
        #       "msg": "success"
        #     }
        #
        return response

    def fetch_leverages(self, symbols: Strings = None, params={}) -> Leverages:
        """
        fetch the set leverage for all markets

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Account-Detail
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Account-Detail
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config

        :param str[] [symbols]: a list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a list of `leverage structures <https://docs.ccxt.com/#/?id=leverage-structure>`
        """
        self.load_markets()
        self.load_leverage_brackets(False, params)
        type = None
        type, params = self.handle_market_type_and_params('fetchLeverages', None, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchLeverages', None, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchLeverages', 'papi', 'portfolioMargin', False)
        response = None
        if self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmAccount(params)
            else:
                response = self.fapiPrivateGetSymbolConfig(params)
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmAccount(params)
            else:
                response = self.dapiPrivateGetAccount(params)
        else:
            raise NotSupported(self.id + ' fetchLeverages() supports linear and inverse contracts only')
        leverages = self.safe_list(response, 'positions', [])
        if isinstance(response, list):
            leverages = response
        return self.parse_leverages(leverages, symbols, 'symbol')

    def parse_leverage(self, leverage: dict, market: Market = None) -> Leverage:
        marketId = self.safe_string(leverage, 'symbol')
        marginModeRaw = self.safe_bool(leverage, 'isolated')
        marginMode = None
        if marginModeRaw is not None:
            marginMode = 'isolated' if marginModeRaw else 'cross'
        marginTypeRaw = self.safe_string_lower(leverage, 'marginType')
        if marginTypeRaw is not None:
            marginMode = 'cross' if (marginTypeRaw == 'crossed') else 'isolated'
        side = self.safe_string_lower(leverage, 'positionSide')
        longLeverage = None
        shortLeverage = None
        leverageValue = self.safe_integer(leverage, 'leverage')
        if (side is None) or (side == 'both'):
            longLeverage = leverageValue
            shortLeverage = leverageValue
        elif side == 'long':
            longLeverage = leverageValue
        elif side == 'short':
            shortLeverage = leverageValue
        return {
            'info': leverage,
            'symbol': self.safe_symbol(marketId, market),
            'marginMode': marginMode,
            'longLeverage': longLeverage,
            'shortLeverage': shortLeverage,
        }

    def fetch_settlement_history(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetches historical settlement records

        https://developers.binance.com/docs/derivatives/option/market-data/Historical-Exercise-Records

        :param str symbol: unified market symbol of the settlement history
        :param int [since]: timestamp in ms
        :param int [limit]: number of records, default 100, max 100
        :param dict [params]: exchange specific params
        :returns dict[]: a list of `settlement history objects <https://docs.ccxt.com/#/?id=settlement-history-structure>`
        """
        self.load_markets()
        market = None if (symbol is None) else self.market(symbol)
        type = None
        type, params = self.handle_market_type_and_params('fetchSettlementHistory', market, params)
        if type != 'option':
            raise NotSupported(self.id + ' fetchSettlementHistory() supports option markets only')
        request: dict = {}
        if symbol is not None:
            symbol = market['symbol']
            request['underlying'] = market['baseId'] + market['quoteId']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.eapiPublicGetExerciseHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "expiryDate": 1677139200000,
        #             "realStrikePrice": "1665.5897334",
        #             "strikePrice": "1900",
        #             "strikeResult": "REALISTIC_VALUE_STRICKEN",
        #             "symbol": "ETH-230223-1900-P",
        #         }
        #     ]
        #
        settlements = self.parse_settlements(response, market)
        sorted = self.sort_by(settlements, 'timestamp')
        return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)

    def fetch_my_settlement_history(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetches historical settlement records of the user

        https://developers.binance.com/docs/derivatives/option/trade/User-Exercise-Record

        :param str symbol: unified market symbol of the settlement history
        :param int [since]: timestamp in ms
        :param int [limit]: number of records
        :param dict [params]: exchange specific params
        :returns dict[]: a list of [settlement history objects]
        """
        self.load_markets()
        market = None if (symbol is None) else self.market(symbol)
        type = None
        type, params = self.handle_market_type_and_params('fetchMySettlementHistory', market, params)
        if type != 'option':
            raise NotSupported(self.id + ' fetchMySettlementHistory() supports option markets only')
        request: dict = {}
        if symbol is not None:
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.eapiPrivateGetExerciseRecord(self.extend(request, params))
        #
        #     [
        #         {
        #             "amount": "0.00000000",
        #             "createDate": 1690531200000,
        #             "currency": "USDT",
        #             "exercisePrice": "30000.00000000",
        #             "fee": "0.00000000",
        #             "id": "1125899906842897036",
        #             "markPrice": "29160.71284993",
        #             "optionSide": "CALL",
        #             "positionSide": "LONG",
        #             "priceScale": 0,
        #             "quantity": "1.00000000",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT",
        #             "symbol": "BTC-230728-30000-C",
        #         }
        #     ]
        #
        settlements = self.parse_settlements(response, market)
        sorted = self.sort_by(settlements, 'timestamp')
        return self.filter_by_symbol_since_limit(sorted, market['symbol'], since, limit)

    def parse_settlement(self, settlement, market):
        #
        # fetchSettlementHistory
        #
        #     {
        #         "expiryDate": 1677139200000,
        #         "realStrikePrice": "1665.5897334",
        #         "strikePrice": "1900",
        #         "strikeResult": "REALISTIC_VALUE_STRICKEN",
        #         "symbol": "ETH-230223-1900-P",
        #     }
        #
        # fetchMySettlementHistory
        #
        #     {
        #         "amount": "0.00000000",
        #         "createDate": 1690531200000,
        #         "currency": "USDT",
        #         "exercisePrice": "30000.00000000",
        #         "fee": "0.00000000",
        #         "id": "1125899906842897036",
        #         "markPrice": "29160.71284993",
        #         "optionSide": "CALL",
        #         "positionSide": "LONG",
        #         "priceScale": 0,
        #         "quantity": "1.00000000",
        #         "quantityScale": 2,
        #         "quoteAsset": "USDT",
        #         "symbol": "BTC-230728-30000-C",
        #     }
        #
        timestamp = self.safe_integer_2(settlement, 'expiryDate', 'createDate')
        marketId = self.safe_string(settlement, 'symbol')
        return {
            'info': settlement,
            'symbol': self.safe_symbol(marketId, market),
            'price': self.safe_number_2(settlement, 'realStrikePrice', 'exercisePrice'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
        }

    def parse_settlements(self, settlements, market):
        #
        # fetchSettlementHistory
        #
        #     [
        #         {
        #             "expiryDate": 1677139200000,
        #             "realStrikePrice": "1665.5897334",
        #             "strikePrice": "1900",
        #             "strikeResult": "EXTRINSIC_VALUE_EXPIRED",
        #             "symbol": "ETH-230223-1900-P",
        #         }
        #     ]
        #
        # fetchMySettlementHistory
        #
        #     [
        #         {
        #             "amount": "0.00000000",
        #             "createDate": 1690531200000,
        #             "currency": "USDT",
        #             "exercisePrice": "30000.00000000",
        #             "fee": "0.00000000",
        #             "id": "1125899906842897036",
        #             "markPrice": "29160.71284993",
        #             "optionSide": "CALL",
        #             "positionSide": "LONG",
        #             "priceScale": 0,
        #             "quantity": "1.00000000",
        #             "quantityScale": 2,
        #             "quoteAsset": "USDT",
        #             "symbol": "BTC-230728-30000-C",
        #         }
        #     ]
        #
        result = []
        for i in range(0, len(settlements)):
            result.append(self.parse_settlement(settlements[i], market))
        return result

    def fetch_ledger_entry(self, id: str, code: Str = None, params={}) -> LedgerEntry:
        """
        fetch the history of changes, actions done by the user or operations that altered the balance of the user

        https://developers.binance.com/docs/derivatives/option/account/Account-Funding-Flow

        :param str id: the identification number of the ledger entry
        :param str code: unified currency code
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ledger structure <https://docs.ccxt.com/#/?id=ledger>`
        """
        self.load_markets()
        type = None
        type, params = self.handle_market_type_and_params('fetchLedgerEntry', None, params)
        if type != 'option':
            raise BadRequest(self.id + ' fetchLedgerEntry() can only be used for type option')
        self.check_required_argument('fetchLedgerEntry', code, 'code')
        currency = self.currency(code)
        request: dict = {
            'recordId': id,
            'currency': currency['id'],
        }
        response = self.eapiPrivateGetBill(self.extend(request, params))
        #
        #     [
        #         {
        #             "id": "1125899906845701870",
        #             "asset": "USDT",
        #             "amount": "-0.16518203",
        #             "type": "FEE",
        #             "createDate": 1676621042489
        #         }
        #     ]
        #
        first = self.safe_dict(response, 0, response)
        return self.parse_ledger_entry(first, currency)

    def fetch_ledger(self, code: Str = None, since: Int = None, limit: Int = None, params={}) -> List[LedgerEntry]:
        """
        fetch the history of changes, actions done by the user or operations that altered the balance of the user

        https://developers.binance.com/docs/derivatives/option/account/Account-Funding-Flow
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Income-History
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Get-Income-History
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Income-History
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Income-History

        :param str [code]: unified currency code
        :param int [since]: timestamp in ms of the earliest ledger entry
        :param int [limit]: max number of ledger entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: timestamp in ms of the latest ledger entry
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch the ledger for a portfolio margin account
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a `ledger structure <https://docs.ccxt.com/#/?id=ledger>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchLedger', 'paginate')
        if paginate:
            return self.fetch_paginated_call_dynamic('fetchLedger', code, since, limit, params, None, False)
        type = None
        subType = None
        currency = None
        if code is not None:
            currency = self.currency(code)
        request: dict = {}
        type, params = self.handle_market_type_and_params('fetchLedger', None, params)
        subType, params = self.handle_sub_type_and_params('fetchLedger', None, params)
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        until = self.safe_integer(params, 'until')
        if until is not None:
            params = self.omit(params, 'until')
            request['endTime'] = until
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchLedger', 'papi', 'portfolioMargin', False)
        response = None
        if type == 'option':
            self.check_required_argument('fetchLedger', code, 'code')
            request['currency'] = currency['id']
            response = self.eapiPrivateGetBill(self.extend(request, params))
        elif self.is_linear(type, subType):
            if isPortfolioMargin:
                response = self.papiGetUmIncome(self.extend(request, params))
            else:
                response = self.fapiPrivateGetIncome(self.extend(request, params))
        elif self.is_inverse(type, subType):
            if isPortfolioMargin:
                response = self.papiGetCmIncome(self.extend(request, params))
            else:
                response = self.dapiPrivateGetIncome(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchLedger() supports contract wallets only')
        #
        # options(eapi)
        #
        #     [
        #         {
        #             "amount": "-0.16518203",
        #             "asset": "USDT",
        #             "createDate": 1676621042489,
        #             "id": "1125899906845701870",
        #             "type": "FEE",
        #         }
        #     ]
        #
        # futures(fapi, dapi, papi)
        #
        #     [
        #         {
        #             "asset": "USDT",
        #             "income": "10.00000000",
        #             "incomeType": "TRANSFER",
        #             "info": "TRANSFER",
        #             "symbol": "",
        #             "time": 1677645250000,
        #             "tradeId": ""
        #             "tranId": 131001573082,
        #         }
        #     ]
        #
        return self.parse_ledger(response, currency, since, limit)

    def parse_ledger_entry(self, item: dict, currency: Currency = None) -> LedgerEntry:
        #
        # options(eapi)
        #
        #     {
        #         "amount": "-0.16518203",
        #         "asset": "USDT",
        #         "createDate": 1676621042489
        #         "id": "1125899906845701870",
        #         "type": "FEE",
        #     }
        #
        # futures(fapi, dapi, papi)
        #
        #     {
        #         "asset": "USDT",
        #         "income": "10.00000000",
        #         "incomeType": "TRANSFER",
        #         "info": "TRANSFER",
        #         "symbol": "",
        #         "time": 1677645250000,
        #         "tradeId": "",
        #         "tranId": 131001573082,
        #     }
        #
        amount = self.safe_string_2(item, 'amount', 'income')
        direction = None
        if Precise.string_le(amount, '0'):
            direction = 'out'
            amount = Precise.string_mul('-1', amount)
        else:
            direction = 'in'
        currencyId = self.safe_string(item, 'asset')
        code = self.safe_currency_code(currencyId, currency)
        currency = self.safe_currency(currencyId, currency)
        timestamp = self.safe_integer_2(item, 'createDate', 'time')
        type = self.safe_string_2(item, 'type', 'incomeType')
        return self.safe_ledger_entry({
            'account': None,
            'amount': self.parse_number(amount),
            'currency': code,
            'datetime': self.iso8601(timestamp),
            'direction': direction,
            'fee': None,
            'id': self.safe_string_2(item, 'id', 'tranId'),
            'info': item,
            'referenceAccount': None,
            'referenceId': self.safe_string(item, 'tradeId'),
            'timestamp': timestamp,
            'type': self.parse_ledger_entry_type(type),
        }, currency)

    def parse_ledger_entry_type(self, type):
        ledgerType: dict = {
            'API_REBATE': 'rebate',
            'COIN_SWAP_DEPOSIT': 'deposit',
            'COIN_SWAP_WITHDRAW': 'withdrawal',
            'COMMISSION': 'commission',
            'COMMISSION_REBATE': 'rebate',
            'CONTEST_REWARD': 'cashback',
            'CONTRACT': 'trade',
            'CROSS_COLLATERAL_TRANSFER': 'transfer',
            'DELIVERED_SETTELMENT': 'settlement',
            'FEE': 'fee',
            'FUNDING_FEE': 'fee',
            'INTERNAL_TRANSFER': 'transfer',
            'OPTIONS_PREMIUM_FEE': 'fee',
            'OPTIONS_SETTLE_PROFIT': 'settlement',
            'POSITION_LIMIT_INCREASE_FEE': 'fee',
            'REALIZED_PNL': 'trade',
            'REFERRAL_KICKBACK': 'referral',
            'TRANSFER': 'transfer',
            'WELCOME_BONUS': 'cashback',
        }
        return self.safe_string(ledgerType, type, type)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        urls = self.urls
        if not (api in urls['api']):
            raise NotSupported(self.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints')
        url = self.urls['api'][api]
        url += '/' + path
        if path == 'historicalTrades':
            if self.apiKey:
                headers = {
                    'X-MBX-APIKEY': self.apiKey,
                }
            else:
                raise AuthenticationError(self.id + ' historicalTrades endpoint requires `apiKey` credential')
        userDataStream = (path == 'userDataStream') or (path == 'listenKey')
        if userDataStream:
            if self.apiKey:
                # v1 special case for userDataStream
                headers = {
                    'X-MBX-APIKEY': self.apiKey,
                    'Content-Type': 'application/x-www-form-urlencoded',
                }
                if method != 'GET':
                    body = self.urlencode(params)
            else:
                raise AuthenticationError(self.id + ' userDataStream endpoint requires `apiKey` credential')
        elif (api == 'private') or (api == 'eapiPrivate') or (api == 'sapi' and path != 'system/status') or (api == 'sapiV2') or (api == 'sapiV3') or (api == 'sapiV4') or (api == 'dapiPrivate') or (api == 'dapiPrivateV2') or (api == 'fapiPrivate') or (api == 'fapiPrivateV2') or (api == 'fapiPrivateV3') or (api == 'papi' and path != 'ping') or (api == 'papiV2'):
            self.check_required_credentials()
            if method == 'POST' and ((path == 'order') or (path == 'sor/order')):
                # inject in implicit API calls
                newClientOrderId = self.safe_string(params, 'newClientOrderId')
                if newClientOrderId is None:
                    isSpotOrMargin = (api.find('sapi') > -1 or api == 'private')
                    marketType = 'spot' if isSpotOrMargin else 'future'
                    defaultId = 'x-xcKtGhcu' if (not isSpotOrMargin) else 'x-R4BD3S82'
                    broker = self.safe_dict(self.options, 'broker', {})
                    brokerId = self.safe_string(broker, marketType, defaultId)
                    params['newClientOrderId'] = brokerId + self.uuid22()
            query = None
            # handle batchOrders
            if (path == 'batchOrders') and (method == 'POST'):
                batchOrders = self.safe_value(params, 'batchOrders')
                queryBatch = (self.json(batchOrders))
                params['batchOrders'] = queryBatch
            defaultRecvWindow = self.safe_integer(self.options, 'recvWindow')
            extendedParams = self.extend({
                'timestamp': self.nonce(),
            }, params)
            if defaultRecvWindow is not None:
                extendedParams['recvWindow'] = defaultRecvWindow
            recvWindow = self.safe_integer(params, 'recvWindow')
            if recvWindow is not None:
                extendedParams['recvWindow'] = recvWindow
            if (api == 'sapi') and (path == 'asset/dust'):
                query = self.urlencode_with_array_repeat(extendedParams)
            elif (path == 'batchOrders') or (path.find('sub-account') >= 0) or (path == 'capital/withdraw/apply') or (path.find('staking') >= 0) or (path.find('simple-earn') >= 0):
                if (method == 'DELETE') and (path == 'batchOrders'):
                    orderidlist = self.safe_list(extendedParams, 'orderidlist', [])
                    origclientorderidlist = self.safe_list(extendedParams, 'origclientorderidlist', [])
                    extendedParams = self.omit(extendedParams, ['orderidlist', 'origclientorderidlist'])
                    query = self.rawencode(extendedParams)
                    orderidlistLength = len(orderidlist)
                    origclientorderidlistLength = len(origclientorderidlist)
                    if orderidlistLength > 0:
                        query = query + '&' + 'orderidlist=%5B' + '%2C'.join(orderidlist) + '%5D'
                    if origclientorderidlistLength > 0:
                        query = query + '&' + 'origclientorderidlist=%5B' + '%2C'.join(origclientorderidlist) + '%5D'
                else:
                    query = self.rawencode(extendedParams)
            else:
                query = self.urlencode(extendedParams)
            signature = None
            if self.secret.find('PRIVATE KEY') > -1:
                if len(self.secret) > 120:
                    signature = self.encode_uri_component(self.rsa(query, self.secret, 'sha256'))
                else:
                    signature = self.encode_uri_component(self.eddsa(self.encode(query), self.secret, 'ed25519'))
            else:
                signature = self.hmac(self.encode(query), self.encode(self.secret), hashlib.sha256)
            query += '&' + 'signature=' + signature
            headers = {
                'X-MBX-APIKEY': self.apiKey,
            }
            if (method == 'GET') or (method == 'DELETE'):
                url += '?' + query
            else:
                body = query
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
        else:
            if params:
                url += '?' + self.urlencode(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def get_exceptions_by_url(self, url: str, exactOrBroad: str):
        marketType = None
        hostname = self.hostname if (self.hostname is not None) else 'binance.com'
        if url.startswith('https://api.' + hostname + '/') or url.startswith('https://testnet.binance.vision'):
            marketType = 'spot'
        elif url.startswith('https://dapi.' + hostname + '/') or url.startswith('https://testnet.binancefuture.com/dapi'):
            marketType = 'inverse'
        elif url.startswith('https://fapi.' + hostname + '/') or url.startswith('https://testnet.binancefuture.com/fapi'):
            marketType = 'linear'
        elif url.startswith('https://eapi.' + hostname + '/'):
            marketType = 'option'
        elif url.startswith('https://papi.' + hostname + '/'):
            marketType = 'portfolioMargin'
        if marketType is not None:
            exceptionsForMarketType = self.safe_dict(self.exceptions, marketType, {})
            return self.safe_dict(exceptionsForMarketType, exactOrBroad, {})
        return {}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if (code == 418) or (code == 429):
            raise DDoSProtection(self.id + ' ' + str(code) + ' ' + reason + ' ' + body)
        # error response in a form: {"code": -1013, "msg": "Invalid quantity."}
        # following block cointains legacy checks against message patterns in "msg" property
        # will switch "code" checks eventually, when we know all of them
        if code >= 400:
            if body.find('Price * QTY is zero or less') >= 0:
                raise InvalidOrder(self.id + ' order cost = amount * price is zero or less ' + body)
            if body.find('LOT_SIZE') >= 0:
                raise InvalidOrder(self.id + ' order amount should be evenly divisible by lot size ' + body)
            if body.find('PRICE_FILTER') >= 0:
                raise InvalidOrder(self.id + ' order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use self.price_to_precision(symbol, amount) ' + body)
        if response is None:
            return None  # fallback to default error handler
        # response in format {'msg': 'The coin does not exist.', 'success': True/false}
        success = self.safe_bool(response, 'success', True)
        if not success:
            messageNew = self.safe_string(response, 'msg')
            parsedMessage = None
            if messageNew is not None:
                try:
                    parsedMessage = json.loads(messageNew)
                except Exception as e:
                    # do nothing
                    parsedMessage = None
                if parsedMessage is not None:
                    response = parsedMessage
        message = self.safe_string(response, 'msg')
        if message is not None:
            self.throw_exactly_matched_exception(self.get_exceptions_by_url(url, 'exact'), message, self.id + ' ' + message)
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, self.id + ' ' + message)
            self.throw_broadly_matched_exception(self.get_exceptions_by_url(url, 'broad'), message, self.id + ' ' + message)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, self.id + ' ' + message)
        # checks against error codes
        error = self.safe_string(response, 'code')
        if error is not None:
            # https://github.com/ccxt/ccxt/issues/6501
            # https://github.com/ccxt/ccxt/issues/7742
            if (error == '200') or Precise.string_equals(error, '0'):
                return None
            # a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            # despite that their message is very confusing, it is raised by Binance
            # on a temporary ban, the API key is valid, but disabled for a while
            if (error == '-2015') and self.options['hasAlreadyAuthenticatedSuccessfully']:
                raise DDoSProtection(self.id + ' ' + body)
            feedback = self.id + ' ' + body
            if message == 'No need to change margin type.':
                # not an error
                # https://github.com/ccxt/ccxt/issues/11268
                # https://github.com/ccxt/ccxt/pull/11624
                # POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
                # binanceusdm {"code":-4046,"msg":"No need to change margin type."}
                raise MarginModeAlreadySet(feedback)
            self.throw_exactly_matched_exception(self.get_exceptions_by_url(url, 'exact'), error, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], error, feedback)
            raise ExchangeError(feedback)
        if not success:
            raise ExchangeError(self.id + ' ' + body)
        if isinstance(response, list):
            # cancelOrders returns an array like self: [{"code":-2011,"msg":"Unknown order sent."}]
            arrayLength = len(response)
            if arrayLength == 1:  # when there's a single error we can throw, otherwise we have a partial success
                element = response[0]
                errorCode = self.safe_string(element, 'code')
                if errorCode is not None:
                    self.throw_exactly_matched_exception(self.get_exceptions_by_url(url, 'exact'), errorCode, self.id + ' ' + body)
                    self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, self.id + ' ' + body)
        return None

    def calculate_rate_limiter_cost(self, api, method, path, params, config={}):
        if ('noCoin' in config) and not ('coin' in params):
            return config['noCoin']
        elif ('noSymbol' in config) and not ('symbol' in params):
            return config['noSymbol']
        elif ('noPoolId' in config) and not ('poolId' in params):
            return config['noPoolId']
        elif ('byLimit' in config) and ('limit' in params):
            limit = params['limit']
            byLimit = config['byLimit']
            for i in range(0, len(byLimit)):
                entry = byLimit[i]
                if limit <= entry[0]:
                    return entry[1]
        return self.safe_value(config, 'cost', 1)

    def request(self, path, api='public', method='GET', params={}, headers=None, body=None, config={}):
        response = self.fetch2(path, api, method, params, headers, body, config)
        # a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
        if api == 'private':
            self.options['hasAlreadyAuthenticatedSuccessfully'] = True
        return response

    def modify_margin_helper(self, symbol: str, amount, addOrReduce, params={}):
        # used to modify isolated positions
        defaultType = self.safe_string(self.options, 'defaultType', 'future')
        if defaultType == 'spot':
            defaultType = 'future'
        type = self.safe_string(params, 'type', defaultType)
        if (type == 'margin') or (type == 'spot'):
            raise NotSupported(self.id + ' add / reduce margin only supported with type future or delivery')
        self.load_markets()
        market = self.market(symbol)
        amount = self.amount_to_precision(symbol, amount)
        request: dict = {
            'amount': amount,
            'symbol': market['id'],
            'type': addOrReduce,
        }
        response = None
        code = None
        if market['linear']:
            code = market['quote']
            response = self.fapiPrivatePostPositionMargin(self.extend(request, params))
        else:
            code = market['base']
            response = self.dapiPrivatePostPositionMargin(self.extend(request, params))
        #
        #     {
        #         "amount": 0.001,
        #         "code": 200,
        #         "msg": "Successfully modify position margin.",
        #         "type": 1
        #     }
        #
        return self.extend(self.parse_margin_modification(response, market), {
            'code': code,
        })

    def parse_margin_modification(self, data: dict, market: Market = None) -> MarginModification:
        #
        # add/reduce margin
        #
        #     {
        #         "amount": 0.001,
        #         "code": 200,
        #         "msg": "Successfully modify position margin.",
        #         "type": 1
        #     }
        #
        # fetchMarginAdjustmentHistory
        #
        #    {
        #        amount: "2.57148240",
        #        asset: "USDT",
        #        clientTranId: ""
        #        deltaType: "TRADE",
        #        positionSide: "BOTH",
        #        symbol: "XRPUSDT",
        #        time: "1711046271555",
        #        type: "1",
        #    }
        #
        rawType = self.safe_integer(data, 'type')
        errorCode = self.safe_string(data, 'code')
        marketId = self.safe_string(data, 'symbol')
        timestamp = self.safe_integer(data, 'time')
        market = self.safe_market(marketId, market, None, 'swap')
        noErrorCode = errorCode is None
        success = errorCode == '200'
        return {
            'amount': self.safe_number(data, 'amount'),
            'code': self.safe_string(data, 'asset'),
            'datetime': self.iso8601(timestamp),
            'info': data,
            'marginMode': 'isolated',
            'status': 'ok' if (success or noErrorCode) else 'failed',
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'total': None,
            'type': 'add' if (rawType == 1) else 'reduce',
        }

    def reduce_margin(self, symbol: str, amount: float, params={}) -> MarginModification:
        """
        remove margin from a position

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Modify-Isolated-Position-Margin

        :param str symbol: unified market symbol
        :param float amount: the amount of margin to remove
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `margin structure <https://docs.ccxt.com/#/?id=reduce-margin-structure>`
        """
        return self.modify_margin_helper(symbol, amount, 2, params)

    def add_margin(self, symbol: str, amount: float, params={}) -> MarginModification:
        """
        add margin

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Modify-Isolated-Position-Margin

        :param str symbol: unified market symbol
        :param float amount: amount of margin to add
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `margin structure <https://docs.ccxt.com/#/?id=add-margin-structure>`
        """
        return self.modify_margin_helper(symbol, amount, 1, params)

    def fetch_cross_borrow_rate(self, code: str, params={}) -> CrossBorrowRate:
        """
        fetch the rate of interest to borrow a currency for margin trading

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Query-Margin-Interest-Rate-History

        :param str code: unified currency code
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `borrow rate structure <https://docs.ccxt.com/#/?id=borrow-rate-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'asset': currency['id'],
            # 'vipLevel': self.safe_integer(params, 'vipLevel'),
        }
        response = self.sapiGetMarginInterestRateHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "asset": "USDT",
        #             "dailyInterestRate": "0.0006",
        #             "timestamp": 1638230400000,
        #             "vipLevel": 0
        #         },
        #     ]
        #
        rate = self.safe_dict(response, 0)
        return self.parse_borrow_rate(rate)

    def fetch_isolated_borrow_rate(self, symbol: str, params={}) -> IsolatedBorrowRate:
        """
        fetch the rate of interest to borrow a currency for margin trading

        https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data

        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint

 EXCHANGE SPECIFIC PARAMETERS
        :param dict [params.vipLevel]: user's current specific margin data will be returned if viplevel is omitted
        :returns dict: an `isolated borrow rate structure <https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure>`
        """
        request: dict = {
            'symbol': symbol,
        }
        borrowRates = self.fetch_isolated_borrow_rates(self.extend(request, params))
        return self.safe_dict(borrowRates, symbol)

    def fetch_isolated_borrow_rates(self, params={}) -> IsolatedBorrowRates:
        """
        fetch the borrow interest rates of all currencies

        https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param dict [params.symbol]: unified market symbol

 EXCHANGE SPECIFIC PARAMETERS
        :param dict [params.vipLevel]: user's current specific margin data will be returned if viplevel is omitted
        :returns dict: a `borrow rate structure <https://docs.ccxt.com/#/?id=borrow-rate-structure>`
        """
        self.load_markets()
        request: dict = {}
        symbol = self.safe_string(params, 'symbol')
        params = self.omit(params, 'symbol')
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        response = self.sapiGetMarginIsolatedMarginData(self.extend(request, params))
        #
        #    [
        #        {
        #            "vipLevel": 0,
        #            "symbol": "BTCUSDT",
        #            "leverage": "10",
        #            "data": [
        #                {
        #                    "coin": "BTC",
        #                    "dailyInterest": "0.00026125",
        #                    "borrowLimit": "270"
        #                },
        #                {
        #                    "coin": "USDT",
        #                    "dailyInterest": "0.000475",
        #                    "borrowLimit": "2100000"
        #                }
        #            ]
        #        }
        #    ]
        #
        return self.parse_isolated_borrow_rates(response)

    def fetch_borrow_rate_history(self, code: str, since: Int = None, limit: Int = None, params={}):
        """
        retrieves a history of a currencies borrow interest rate at specific time slots

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Query-Margin-Interest-Rate-History

        :param str code: unified currency code
        :param int [since]: timestamp for the earliest borrow rate
        :param int [limit]: the maximum number of `borrow rate structures <https://docs.ccxt.com/#/?id=borrow-rate-structure>` to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: an array of `borrow rate structures <https://docs.ccxt.com/#/?id=borrow-rate-structure>`
        """
        self.load_markets()
        if limit is None:
            limit = 93
        elif limit > 93:
            # Binance API says the limit is 100, but "Illegal characters found in a parameter." is returned when limit is > 93
            raise BadRequest(self.id + ' fetchBorrowRateHistory() limit parameter cannot exceed 92')
        currency = self.currency(code)
        request: dict = {
            'asset': currency['id'],
            'limit': limit,
        }
        if since is not None:
            request['startTime'] = since
            endTime = self.sum(since, limit * 86400000) - 1  # required when startTime is further than 93 days in the past
            now = self.milliseconds()
            request['endTime'] = min(endTime, now)  # cannot have an endTime later than current time
        response = self.sapiGetMarginInterestRateHistory(self.extend(request, params))
        #
        #     [
        #         {
        #             "asset": "USDT",
        #             "dailyInterestRate": "0.0006",
        #             "timestamp": 1638230400000,
        #             "vipLevel": 0
        #         },
        #     ]
        #
        return self.parse_borrow_rate_history(response, code, since, limit)

    def parse_borrow_rate(self, info, currency: Currency = None):
        #
        #    {
        #        "asset": "USDT",
        #        "dailyInterestRate": "0.0006",
        #        "timestamp": 1638230400000,
        #        "vipLevel": 0
        #    }
        #
        timestamp = self.safe_integer(info, 'timestamp')
        currencyId = self.safe_string(info, 'asset')
        return {
            'currency': self.safe_currency_code(currencyId, currency),
            'datetime': self.iso8601(timestamp),
            'info': info,
            'period': 86400000,
            'rate': self.safe_number(info, 'dailyInterestRate'),
            'timestamp': timestamp,
        }

    def parse_isolated_borrow_rate(self, info: dict, market: Market = None) -> IsolatedBorrowRate:
        #
        #    {
        #        "vipLevel": 0,
        #        "symbol": "BTCUSDT",
        #        "leverage": "10",
        #        "data": [
        #            {
        #                "coin": "BTC",
        #                "dailyInterest": "0.00026125",
        #                "borrowLimit": "270"
        #            },
        #            {
        #                "coin": "USDT",
        #                "dailyInterest": "0.000475",
        #                "borrowLimit": "2100000"
        #            }
        #        ]
        #    }
        #
        marketId = self.safe_string(info, 'symbol')
        market = self.safe_market(marketId, market, None, 'spot')
        data = self.safe_list(info, 'data')
        baseInfo = self.safe_dict(data, 0)
        quoteInfo = self.safe_dict(data, 1)
        return {
            'info': info,
            'symbol': self.safe_string(market, 'symbol'),
            'base': self.safe_string(baseInfo, 'coin'),
            'baseRate': self.safe_number(baseInfo, 'dailyInterest'),
            'quote': self.safe_string(quoteInfo, 'coin'),
            'quoteRate': self.safe_number(quoteInfo, 'dailyInterest'),
            'period': 86400000,
            'timestamp': None,
            'datetime': None,
        }

    def create_gift_code(self, code: str, amount, params={}):
        """
        create gift code

        https://developers.binance.com/docs/gift_card/market-data/Create-a-single-token-gift-card

        :param str code: gift code
        :param float amount: amount of currency for the gift
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: The gift code id, code, currency and amount
        """
        self.load_markets()
        currency = self.currency(code)
        # ensure you have enough token in your funding account before calling self code
        request: dict = {
            'token': currency['id'],
            'amount': amount,
        }
        response = self.sapiPostGiftcardCreateCode(self.extend(request, params))
        #
        #     {
        #         "code": "000000",
        #         "data": {referenceNo: "0033002404219823", code: "AP6EXTLKNHM6CEX7"},
        #         "message": "success",
        #         "success": True
        #     }
        #
        data = self.safe_dict(response, 'data')
        giftcardCode = self.safe_string(data, 'code')
        id = self.safe_string(data, 'referenceNo')
        return {
            'amount': amount,
            'code': giftcardCode,
            'currency': code,
            'id': id,
            'info': response,
        }

    def redeem_gift_code(self, giftcardCode, params={}):
        """
        redeem gift code

        https://developers.binance.com/docs/gift_card/market-data/Redeem-a-Binance-Gift-Card

        :param str giftcardCode:
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        request: dict = {
            'code': giftcardCode,
        }
        response = self.sapiPostGiftcardRedeemCode(self.extend(request, params))
        #
        #     {
        #         "code": "000000",
        #         "data": {
        #             "identityNo": "10316431732801474560",
        #             "referenceNo": "0033002404219823",
        #         },
        #         "message": "success",
        #         "success": True
        #     }
        #
        return response

    def verify_gift_code(self, id: str, params={}):
        """
        verify gift code

        https://developers.binance.com/docs/gift_card/market-data/Verify-Binance-Gift-Card-by-Gift-Card-Number

        :param str id: reference number id
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: response from the exchange
        """
        request: dict = {
            'referenceNo': id,
        }
        response = self.sapiGetGiftcardVerify(self.extend(request, params))
        #
        #     {
        #         "code": "000000",
        #         "data": {valid: True},
        #         "message": "success",
        #         "success": True
        #     }
        #
        return response

    def fetch_borrow_interest(self, code: Str = None, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[BorrowInterest]:
        """
        fetch the interest owed by the user for borrowing currency for margin trading

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Get-Interest-History
        https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Margin-BorrowLoan-Interest-History

        :param str [code]: unified currency code
        :param str [symbol]: unified market symbol when fetch interest in isolated markets
        :param int [since]: the earliest time in ms to fetch borrrow interest for
        :param int [limit]: the maximum number of structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch the borrow interest in a portfolio margin account
        :returns dict[]: a list of `borrow interest structures <https://docs.ccxt.com/#/?id=borrow-interest-structure>`
        """
        self.load_markets()
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchBorrowInterest', 'papi', 'portfolioMargin', False)
        request: dict = {}
        market = None
        if code is not None:
            currency = self.currency(code)
            request['asset'] = currency['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['size'] = limit
        request, params = self.handle_until_option('endTime', request, params)
        response = None
        if isPortfolioMargin:
            response = self.papiGetMarginMarginInterestHistory(self.extend(request, params))
        else:
            if symbol is not None:
                market = self.market(symbol)
                request['isolatedSymbol'] = market['id']
            response = self.sapiGetMarginInterestHistory(self.extend(request, params))
        #
        # spot margin
        #
        #     {
        #         "rows":[
        #             {
        #                 "asset": "BNB",
        #                 "interest": "0.02414667",
        #                 "interestAccuredTime": 1566813600000,
        #                 "interestRate": "0.01600000",
        #                 "isolatedSymbol": "BNBUSDT",  # isolated symbol, will not be returned for crossed margin
        #                 "principal": "36.22000000",
        #                 "type": "ON_BORROW"
        #             }
        #         ],
        #         "total": 1
        #     }
        #
        # spot margin portfolio margin
        #
        #     {
        #         "rows": [
        #             {
        #                 "asset": "USDT",
        #                 "interest": "0.00000001",
        #                 "interestAccuredTime": 1707541200000,
        #                 "interestRate": "0.00089489",
        #                 "principal": "0.00011146",
        #                 "rawAsset": "USDT",
        #                 "txId": 1656187724899910076,
        #                 "type": "PERIODIC"
        #             },
        #         ],
        #         "total": 49
        #     }
        #
        rows = self.safe_list(response, 'rows')
        interest = self.parse_borrow_interests(rows, market)
        return self.filter_by_currency_since_limit(interest, code, since, limit)

    def parse_borrow_interest(self, info: dict, market: Market = None) -> BorrowInterest:
        symbol = self.safe_string(info, 'isolatedSymbol')
        timestamp = self.safe_integer(info, 'interestAccuredTime')
        marginMode = 'cross' if (symbol is None) else 'isolated'
        return {
            'amountBorrowed': self.safe_number(info, 'principal'),
            'currency': self.safe_currency_code(self.safe_string(info, 'asset')),
            'datetime': self.iso8601(timestamp),
            'info': info,
            'interest': self.safe_number(info, 'interest'),
            'interestRate': self.safe_number(info, 'interestRate'),
            'marginMode': marginMode,
            'symbol': symbol,
            'timestamp': timestamp,
        }

    def repay_cross_margin(self, code: str, amount, params={}):
        """
        repay borrowed margin and interest

        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay
        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay-Debt

        :param str code: unified currency code of the currency to repay
        :param float amount: the amount to repay
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to repay margin in a portfolio margin account
        :param str [params.repayCrossMarginMethod]: *portfolio margin only* 'papiPostRepayLoan'(default), 'papiPostMarginRepayDebt'(alternative)
        :param str [params.specifyRepayAssets]: *portfolio margin papiPostMarginRepayDebt only* specific asset list to repay debt
        :returns dict: a `margin loan structure <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'amount': self.currency_to_precision(code, amount),
            'asset': currency['id'],
        }
        response = None
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'repayCrossMargin', 'papi', 'portfolioMargin', False)
        if isPortfolioMargin:
            method = None
            method, params = self.handle_option_and_params_2(params, 'repayCrossMargin', 'repayCrossMarginMethod', 'method')
            if method == 'papiPostMarginRepayDebt':
                response = self.papiPostMarginRepayDebt(self.extend(request, params))
                #
                #     {
                #         "asset": "USDC",
                #         "amount": 10,
                #         "specifyRepayAssets": null,
                #         "updateTime": 1727170761267,
                #         "success": True
                #     }
                #
            else:
                response = self.papiPostRepayLoan(self.extend(request, params))
                #
                #     {
                #         "tranId": 108988250265,
                #         "clientTag":""
                #     }
                #
        else:
            request['isIsolated'] = 'FALSE'
            request['type'] = 'REPAY'
            response = self.sapiPostMarginBorrowRepay(self.extend(request, params))
        #
        #     {
        #         "clientTag":"",
        #         "tranId": 108988250265,
        #     }
        #
        return self.parse_margin_loan(response, currency)

    def repay_isolated_margin(self, symbol: str, code: str, amount, params={}):
        """
        repay borrowed margin and interest

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay

        :param str symbol: unified market symbol, required for isolated margin
        :param str code: unified currency code of the currency to repay
        :param float amount: the amount to repay
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `margin loan structure <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        market = self.market(symbol)
        request: dict = {
            'amount': self.currency_to_precision(code, amount),
            'asset': currency['id'],
            'isIsolated': 'TRUE',
            'symbol': market['id'],
            'type': 'REPAY',
        }
        response = self.sapiPostMarginBorrowRepay(self.extend(request, params))
        #
        #     {
        #         "clientTag":"",
        #         "tranId": 108988250265,
        #     }
        #
        return self.parse_margin_loan(response, currency)

    def borrow_cross_margin(self, code: str, amount: float, params={}):
        """
        create a loan to borrow margin

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Borrow

        :param str code: unified currency code of the currency to borrow
        :param float amount: the amount to borrow
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param boolean [params.portfolioMargin]: set to True if you would like to borrow margin in a portfolio margin account
        :returns dict: a `margin loan structure <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        request: dict = {
            'asset': currency['id'],
            'amount': self.currency_to_precision(code, amount),
        }
        response = None
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'borrowCrossMargin', 'papi', 'portfolioMargin', False)
        if isPortfolioMargin:
            response = self.papiPostMarginLoan(self.extend(request, params))
        else:
            request['isIsolated'] = 'FALSE'
            request['type'] = 'BORROW'
            response = self.sapiPostMarginBorrowRepay(self.extend(request, params))
        #
        #     {
        #         "clientTag":"",
        #         "tranId": 108988250265,
        #     }
        #
        return self.parse_margin_loan(response, currency)

    def borrow_isolated_margin(self, symbol: str, code: str, amount: float, params={}):
        """
        create a loan to borrow margin

        https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay

        :param str symbol: unified market symbol, required for isolated margin
        :param str code: unified currency code of the currency to borrow
        :param float amount: the amount to borrow
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `margin loan structure <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        self.load_markets()
        currency = self.currency(code)
        market = self.market(symbol)
        request: dict = {
            'amount': self.currency_to_precision(code, amount),
            'asset': currency['id'],
            'isIsolated': 'TRUE',
            'symbol': market['id'],
            'type': 'BORROW',
        }
        response = self.sapiPostMarginBorrowRepay(self.extend(request, params))
        #
        #     {
        #         "clientTag":"",
        #         "tranId": 108988250265,
        #     }
        #
        return self.parse_margin_loan(response, currency)

    def parse_margin_loan(self, info, currency: Currency = None):
        #
        #     {
        #         "clientTag":"",
        #         "tranId": 108988250265,
        #     }
        #
        # repayCrossMargin alternative endpoint
        #
        #     {
        #         "asset": "USDC",
        #         "amount": 10,
        #         "specifyRepayAssets": null,
        #         "updateTime": 1727170761267,
        #         "success": True
        #     }
        #
        currencyId = self.safe_string(info, 'asset')
        timestamp = self.safe_integer(info, 'updateTime')
        return {
            'amount': self.safe_number(info, 'amount'),
            'currency': self.safe_currency_code(currencyId, currency),
            'datetime': self.iso8601(timestamp),
            'id': self.safe_integer(info, 'tranId'),
            'info': info,
            'symbol': None,
            'timestamp': timestamp,
        }

    def fetch_open_interest_history(self, symbol: str, timeframe='5m', since: Int = None, limit: Int = None, params={}):
        """
        Retrieves the open interest history of a currency

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Open-Interest-Statistics

        :param str symbol: Unified CCXT market symbol
        :param str timeframe: "5m","15m","30m","1h","2h","4h","6h","12h", or "1d"
        :param int [since]: the time(ms) of the earliest record to retrieve unix timestamp
        :param int [limit]: default 30, max 500
        :param dict [params]: exchange specific parameters
        :param int [params.until]: the time(ms) of the latest record to retrieve unix timestamp
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns dict: an array of `open interest structure <https://docs.ccxt.com/#/?id=open-interest-structure>`
        """
        if timeframe == '1m':
            raise BadRequest(self.id + 'fetchOpenInterestHistory cannot use the 1m timeframe')
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchOpenInterestHistory', 'paginate', False)
        if paginate:
            return self.fetch_paginated_call_deterministic('fetchOpenInterestHistory', symbol, since, limit, timeframe, params, 500)
        market = self.market(symbol)
        request: dict = {
            'period': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        if limit is not None:
            request['limit'] = limit
        symbolKey = 'symbol' if market['linear'] else 'pair'
        request[symbolKey] = market['id']
        if market['inverse']:
            request['contractType'] = self.safe_string(params, 'contractType', 'CURRENT_QUARTER')
        if since is not None:
            request['startTime'] = since
        until = self.safe_integer(params, 'until')  # unified in milliseconds
        endTime = self.safe_integer(params, 'endTime', until)  # exchange-specific in milliseconds
        params = self.omit(params, ['endTime', 'until'])
        if endTime:
            request['endTime'] = endTime
        elif since:
            if limit is None:
                limit = 30  # Exchange default
            duration = self.parse_timeframe(timeframe)
            request['endTime'] = self.sum(since, duration * limit * 1000)
        response = None
        if market['inverse']:
            response = self.dapiDataGetOpenInterestHist(self.extend(request, params))
        else:
            response = self.fapiDataGetOpenInterestHist(self.extend(request, params))
        #
        #  [
        #      {
        #          "sumOpenInterest":"75375.61700000",
        #          "sumOpenInterestValue":"3248828883.71251440",
        #          "symbol":"BTCUSDT",
        #          "timestamp":1642179900000
        #      },
        #      ...
        #  ]
        #
        return self.parse_open_interests_history(response, market, since, limit)

    def fetch_open_interest(self, symbol: str, params={}):
        """
        retrieves the open interest of a contract trading pair

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Open-Interest
        https://developers.binance.com/docs/derivatives/option/market-data/Open-Interest

        :param str symbol: unified CCXT market symbol
        :param dict [params]: exchange specific parameters
        :returns dict} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure:
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {}
        if market['option']:
            request['underlyingAsset'] = market['baseId']
            if market['expiry'] is None:
                raise NotSupported(self.id + ' fetchOpenInterest does not support ' + symbol)
            request['expiration'] = self.yymmdd(market['expiry'])
        else:
            request['symbol'] = market['id']
        response = None
        if market['option']:
            response = self.eapiPublicGetOpenInterest(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPublicGetOpenInterest(self.extend(request, params))
        else:
            response = self.fapiPublicGetOpenInterest(self.extend(request, params))
        #
        # futures(fapi)
        #
        #     {
        #         "openInterest": "23581.677",
        #         "symbol": "ETHUSDT_230331",
        #         "time": 1677356872265
        #     }
        #
        # futures(dapi)
        #
        #     {
        #         "contractType": "PERPETUAL",
        #         "openInterest": "26542436",
        #         "pair": "ETHUSD",
        #         "symbol": "ETHUSD_PERP",
        #         "time": 1677360272224
        #     }
        #
        # options(eapi)
        #
        #     [
        #         {
        #             "sumOpenInterest": "460.50",
        #             "sumOpenInterestUsd": "734957.4358092150",
        #             "symbol": "ETH-230225-1625-C",
        #             "timestamp": "1677304860000"
        #         }
        #     ]
        #
        if market['option']:
            symbol = market['symbol']
            result = self.parse_open_interests_history(response, market)
            for i in range(0, len(result)):
                item = result[i]
                if item['symbol'] == symbol:
                    return item
        else:
            return self.parse_open_interest(response, market)
        return None

    def parse_open_interest(self, interest, market: Market = None):
        timestamp = self.safe_integer_2(interest, 'timestamp', 'time')
        id = self.safe_string(interest, 'symbol')
        amount = self.safe_number_2(interest, 'sumOpenInterest', 'openInterest')
        value = self.safe_number_2(interest, 'sumOpenInterestValue', 'sumOpenInterestUsd')
        # Inverse returns the number of contracts different from the base or quote hasattr(self, volume) case
        # compared with https://www.binance.com/en/futures/funding-history/quarterly/4
        return self.safe_open_interest({
            'baseVolume': None if market['inverse'] else amount,  # deprecated
            'datetime': self.iso8601(timestamp),
            'info': interest,
            'openInterestAmount': amount,
            'openInterestValue': value,
            'quoteVolume': value,  # deprecated
            'symbol': self.safe_symbol(id, market, None, 'contract'),
            'timestamp': timestamp,
        }, market)

    def fetch_my_liquidations(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        retrieves the users liquidated positions

        https://developers.binance.com/docs/margin_trading/trade/Get-Force-Liquidation-Record
        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Users-Force-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-UM-Force-Orders
        https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-CM-Force-Orders

        :param str [symbol]: unified CCXT market symbol
        :param int [since]: the earliest time in ms to fetch liquidations for
        :param int [limit]: the maximum number of liquidation structures to retrieve
        :param dict [params]: exchange specific parameters for the binance api endpoint
        :param int [params.until]: timestamp in ms of the latest liquidation
        :param boolean [params.paginate]: *spot only* default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :param boolean [params.portfolioMargin]: set to True if you would like to fetch liquidations in a portfolio margin account
        :param str [params.type]: "spot"
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: an array of `liquidation structures <https://docs.ccxt.com/#/?id=liquidation-structure>`
        """
        self.load_markets()
        paginate = False
        paginate, params = self.handle_option_and_params(params, 'fetchMyLiquidations', 'paginate')
        if paginate:
            return self.fetch_paginated_call_incremental('fetchMyLiquidations', symbol, since, limit, params, 'current', 100)
        market = None
        if symbol is not None:
            market = self.market(symbol)
        type = None
        type, params = self.handle_market_type_and_params('fetchMyLiquidations', market, params)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchMyLiquidations', market, params, 'linear')
        isPortfolioMargin = None
        isPortfolioMargin, params = self.handle_option_and_params_2(params, 'fetchMyLiquidations', 'papi', 'portfolioMargin', False)
        request: dict = {}
        if type != 'spot':
            request['autoCloseType'] = 'LIQUIDATION'
        if market is not None:
            symbolKey = 'isolatedSymbol' if market['spot'] else 'symbol'
            if not isPortfolioMargin:
                request[symbolKey] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            if type == 'spot':
                request['size'] = limit
            else:
                request['limit'] = limit
        request, params = self.handle_until_option('endTime', request, params)
        response = None
        if type == 'spot':
            if isPortfolioMargin:
                response = self.papiGetMarginForceOrders(self.extend(request, params))
            else:
                response = self.sapiGetMarginForceLiquidationRec(self.extend(request, params))
        elif subType == 'linear':
            if isPortfolioMargin:
                response = self.papiGetUmForceOrders(self.extend(request, params))
            else:
                response = self.fapiPrivateGetForceOrders(self.extend(request, params))
        elif subType == 'inverse':
            if isPortfolioMargin:
                response = self.papiGetCmForceOrders(self.extend(request, params))
            else:
                response = self.dapiPrivateGetForceOrders(self.extend(request, params))
        else:
            raise NotSupported(self.id + ' fetchMyLiquidations() does not support ' + market['type'] + ' markets')
        #
        # margin
        #
        #     {
        #         "rows": [
        #             {
        #                 "avgPrice": "0.00388359",
        #                 "executedQty": "31.39000000",
        #                 "isIsolated": True,
        #                 "orderId": 180015097,
        #                 "price": "0.00388110",
        #                 "qty": "31.39000000",
        #                 "side": "SELL",
        #                 "symbol": "BNBBTC",
        #                 "timeInForce": "GTC",
        #                 "updatedTime": 1558941374745
        #             }
        #         ],
        #         "total": 1
        #     }
        #
        # linear
        #
        #     [
        #         {
        #             "avgPrice": "10913.21000",
        #             "clientOrderId": "autoclose-1596107620040000020",
        #             "closePosition": False,
        #             "cumQuote": "10.91321",
        #             "executedQty": "0.001",
        #             "orderId": 6071832819,
        #             "origQty": "0.001",
        #             "origType": "LIMIT",
        #             "positionSide": "BOTH",
        #             "price": "10871.09",
        #             "reduceOnly": False,
        #             "side": "SELL",
        #             "status": "FILLED",
        #             "stopPrice": "0",
        #             "symbol": "BTCUSDT",
        #             "time": 1596107620044,
        #             "timeInForce": "IOC",
        #             "type": "LIMIT",
        #             "updateTime": 1596107620087,
        #             "workingType": "CONTRACT_PRICE",
        #         },
        #     ]
        #
        # inverse
        #
        #     [
        #         {
        #             "avgPrice": "11326.9",
        #             "clientOrderId": "autoclose-1596542005017000006",
        #             "closePosition": False,
        #             "cumBase": "0.00882854",
        #             "executedQty": "1",
        #             "orderId": 165123080,
        #             "origQty": "1",
        #             "origType": "LIMIT",
        #             "pair": "BTCUSD",
        #             "positionSide": "BOTH",
        #             "price": "11326.9",
        #             "priceProtect": False,
        #             "reduceOnly": False,
        #             "side": "SELL",
        #             "status": "FILLED",
        #             "stopPrice": "0",
        #             "symbol": "BTCUSD_200925",
        #             "time": 1596542005019,
        #             "timeInForce": "IOC",
        #             "type": "LIMIT",
        #             "updateTime": 1596542005050,
        #             "workingType": "CONTRACT_PRICE",
        #         },
        #     ]
        #
        liquidations = self.safe_list(response, 'rows', response)
        return self.parse_liquidations(liquidations, market, since, limit)

    def parse_liquidation(self, liquidation, market: Market = None):
        #
        # margin
        #
        #     {
        #         "avgPrice": "0.00388359",
        #         "executedQty": "31.39000000",
        #         "isIsolated": True,
        #         "orderId": 180015097,
        #         "price": "0.00388110",
        #         "qty": "31.39000000",
        #         "side": "SELL",
        #         "symbol": "BNBBTC",
        #         "timeInForce": "GTC",
        #         "updatedTime": 1558941374745
        #     }
        #
        # linear
        #
        #     {
        #         "avgPrice": "10913.21000",
        #         "clientOrderId": "autoclose-1596107620040000020",
        #         "closePosition": False,
        #         "cumQuote": "10.91321",
        #         "executedQty": "0.001",
        #         "orderId": 6071832819,
        #         "origQty": "0.001",
        #         "origType": "LIMIT",
        #         "positionSide": "BOTH",
        #         "price": "10871.09",
        #         "reduceOnly": False,
        #         "side": "SELL",
        #         "status": "FILLED",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSDT",
        #         "time": 1596107620044,
        #         "timeInForce": "IOC",
        #         "type": "LIMIT",
        #         "updateTime": 1596107620087,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        # inverse
        #
        #     {
        #         "avgPrice": "11326.9",
        #         "clientOrderId": "autoclose-1596542005017000006",
        #         "closePosition": False,
        #         "cumBase": "0.00882854",
        #         "executedQty": "1",
        #         "orderId": 165123080,
        #         "origQty": "1",
        #         "origType": "LIMIT",
        #         "pair": "BTCUSD",
        #         "positionSide": "BOTH",
        #         "price": "11326.9",
        #         "priceProtect": False,
        #         "reduceOnly": False,
        #         "side": "SELL",
        #         "status": "FILLED",
        #         "stopPrice": "0",
        #         "symbol": "BTCUSD_200925",
        #         "time": 1596542005019,
        #         "timeInForce": "IOC",
        #         "type": "LIMIT",
        #         "updateTime": 1596542005050,
        #         "workingType": "CONTRACT_PRICE",
        #     }
        #
        marketId = self.safe_string(liquidation, 'symbol')
        timestamp = self.safe_integer_2(liquidation, 'updatedTime', 'updateTime')
        return self.safe_liquidation({
            'baseValue': self.safe_number(liquidation, 'cumBase'),
            'contracts': self.safe_number(liquidation, 'executedQty'),
            'contractSize': self.safe_number(market, 'contractSize'),
            'datetime': self.iso8601(timestamp),
            'info': liquidation,
            'price': self.safe_number(liquidation, 'avgPrice'),
            'quoteValue': self.safe_number(liquidation, 'cumQuote'),
            'symbol': self.safe_symbol(marketId, market),
            'timestamp': timestamp,
        })

    def fetch_greeks(self, symbol: str, params={}) -> Greeks:
        """
        fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract

        https://developers.binance.com/docs/derivatives/option/market-data/Option-Mark-Price

        :param str symbol: unified symbol of the market to fetch greeks for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `greeks structure <https://docs.ccxt.com/#/?id=greeks-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        response = self.eapiPublicGetMark(self.extend(request, params))
        #
        #     [
        #         {
        #             "askIV": "0.62267244",
        #             "bidIV": "0.60236275",
        #             "delta": "0.39111646",
        #             "gamma": "0.00004656",
        #             "highPriceLimit": "6474",
        #             "lowPriceLimit": "5",
        #             "markIV": "0.6125176",
        #             "markPrice": "2012",
        #             "symbol": "BTC-231229-40000-C",
        #             "theta": "-32.13948531",
        #             "vega": "51.70062218",
        #         }
        #     ]
        #
        return self.parse_greeks(response[0], market)

    def parse_greeks(self, greeks: dict, market: Market = None) -> Greeks:
        #
        #     {
        #         "askIV": "0.62267244",
        #         "bidIV": "0.60236275",
        #         "delta": "0.39111646",
        #         "gamma": "0.00004656",
        #         "highPriceLimit": "6474",
        #         "lowPriceLimit": "5"
        #         "markIV": "0.6125176",
        #         "markPrice": "2012",
        #         "symbol": "BTC-231229-40000-C",
        #         "theta": "-32.13948531",
        #         "vega": "51.70062218",
        #     }
        #
        marketId = self.safe_string(greeks, 'symbol')
        symbol = self.safe_symbol(marketId, market)
        return {
            'askImpliedVolatility': self.safe_number(greeks, 'askIV'),
            'askPrice': None,
            'askSize': None,
            'bidImpliedVolatility': self.safe_number(greeks, 'bidIV'),
            'bidPrice': None,
            'bidSize': None,
            'datetime': None,
            'delta': self.safe_number(greeks, 'delta'),
            'gamma': self.safe_number(greeks, 'gamma'),
            'info': greeks,
            'lastPrice': None,
            'markImpliedVolatility': self.safe_number(greeks, 'markIV'),
            'markPrice': self.safe_number(greeks, 'markPrice'),
            'rho': None,
            'symbol': symbol,
            'theta': self.safe_number(greeks, 'theta'),
            'timestamp': None,
            'underlyingPrice': None,
            'vega': self.safe_number(greeks, 'vega'),
        }

    def fetch_trading_limits(self, symbols: Strings = None, params={}):
        # self method should not be called directly, use loadTradingLimits() instead
        markets = self.fetch_markets()
        tradingLimits: dict = {}
        for i in range(0, len(markets)):
            market = markets[i]
            symbol = market['symbol']
            if (symbols is None) or (self.in_array(symbol, symbols)):
                tradingLimits[symbol] = market['limits']['amount']
        return tradingLimits

    def fetch_position_mode(self, symbol: Str = None, params={}):
        """
        fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Current-Position-Mode
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Get-Current-Position-Mode

        :param str symbol: unified symbol of the market to fetch the order book for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: an object detailing whether the market is in hedged or one-way mode
        """
        market = None
        if symbol is not None:
            market = self.market(symbol)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchPositionMode', market, params)
        response = None
        if subType == 'linear':
            response = self.fapiPrivateGetPositionSideDual(params)
        elif subType == 'inverse':
            response = self.dapiPrivateGetPositionSideDual(params)
        else:
            raise BadRequest(self.id + ' fetchPositionMode requires either a symbol argument or params["subType"]')
        #
        #    {
        #        dualSidePosition: False
        #    }
        #
        dualSidePosition = self.safe_bool(response, 'dualSidePosition')
        return {
            'hedged': dualSidePosition,
            'info': response,
        }

    def fetch_margin_modes(self, symbols: Strings = None, params={}) -> MarginModes:
        """
        fetches margin modes("isolated" or "cross") that the market for the symbol in in, with symbol=None all markets for a subType(linear/inverse) are returned

        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config

        :param str[] symbols: unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a list of `margin mode structures <https://docs.ccxt.com/#/?id=margin-mode-structure>`
        """
        self.load_markets()
        market = None
        if symbols is not None:
            symbols = self.market_symbols(symbols)
            market = self.market(symbols[0])
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchMarginMode', market, params)
        response = None
        if subType == 'linear':
            response = self.fapiPrivateGetSymbolConfig(params)
            #
            # [
            #     {
            #         "isAutoAddMargin": "false",
            #         "leverage": 21,
            #         "marginType": "CROSSED",
            #         "maxNotionalValue": "1000000",
            #         "symbol": "BTCUSDT",
            #     }
            # ]
            #
        elif subType == 'inverse':
            response = self.dapiPrivateGetAccount(params)
            #
            #    {
            #        assets: [
            #            {
            #                asset: 'APT',
            #                availableBalance: '0.00000000',
            #                crossUnPnl: '0.00000000',
            #                crossWalletBalance: '0.00000000',
            #                initialMargin: '0.00000000',
            #                maintMargin: '0.00000000',
            #                marginBalance: '0.00000000',
            #                maxWithdrawAmount: '0.00000000',
            #                openOrderInitialMargin: '0.00000000',
            #                positionInitialMargin: '0.00000000',
            #                unrealizedProfit: '0.00000000',
            #                updateTime: '0'
            #                walletBalance: '0.00000000',
            #            },
            #            ...
            #        ],
            #        canDeposit: True,
            #        canTrade: True,
            #        canWithdraw: True,
            #        feeTier: '0',
            #        positions: [
            #            {
            #                breakEvenPrice: '0.00000000',
            #                entryPrice: '0.00000000',
            #                initialMargin: '0',
            #                isolated: False,
            #                isolatedWallet: '0',
            #                leverage: '20',
            #                maintMargin: '0',
            #                maxQty: '1000',
            #                notionalValue: '0',
            #                openOrderInitialMargin: '0',
            #                positionAmt: '0',
            #                positionInitialMargin: '0',
            #                positionSide: 'BOTH',
            #                symbol: 'BCHUSD_240329',
            #                unrealizedProfit: '0.00000000',
            #                updateTime: '0',
            #            },
            #            ...
            #        ],
            #        updateTime: '0',
            #    }
            #
        else:
            raise BadRequest(self.id + ' fetchMarginModes() supports linear and inverse subTypes only')
        assets = self.safe_list(response, 'positions', [])
        if isinstance(response, list):
            assets = response
        return self.parse_margin_modes(assets, symbols, 'symbol', 'swap')

    def fetch_margin_mode(self, symbol: str, params={}) -> MarginMode:
        """
        fetches the margin mode of a specific symbol

        https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
        https://developers.binance.com/docs/derivatives/coin-margined-futures/account/Account-Information

        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict: a `margin mode structure <https://docs.ccxt.com/#/?id=margin-mode-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchMarginMode', market, params)
        response = None
        if subType == 'linear':
            request: dict = {
                'symbol': market['id'],
            }
            response = self.fapiPrivateGetSymbolConfig(self.extend(request, params))
            #
            # [
            #     {
            #         "symbol": "BTCUSDT",
            #         "marginType": "CROSSED",
            #         "isAutoAddMargin": "false",
            #         "leverage": 21,
            #         "maxNotionalValue": "1000000",
            #     }
            # ]
            #
        elif subType == 'inverse':
            fetchMarginModesResponse = self.fetch_margin_modes([symbol], params)
            return fetchMarginModesResponse[symbol]
        else:
            raise BadRequest(self.id + ' fetchMarginMode() supports linear and inverse subTypes only')
        return self.parse_margin_mode(response[0], market)

    def parse_margin_mode(self, marginMode: dict, market=None) -> MarginMode:
        marketId = self.safe_string(marginMode, 'symbol')
        market = self.safe_market(marketId, market)
        marginModeRaw = self.safe_bool(marginMode, 'isolated')
        reMarginMode = None
        if marginModeRaw is not None:
            reMarginMode = 'isolated' if marginModeRaw else 'cross'
        marginTypeRaw = self.safe_string_lower(marginMode, 'marginType')
        if marginTypeRaw is not None:
            reMarginMode = 'cross' if (marginTypeRaw == 'crossed') else 'isolated'
        return {
            'info': marginMode,
            'symbol': market['symbol'],
            'marginMode': reMarginMode,
        }

    def fetch_option(self, symbol: str, params={}) -> Option:
        """
        fetches option data that is commonly found in an option chain

        https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics

        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `option chain structure <https://docs.ccxt.com/#/?id=option-chain-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['id'],
        }
        response = self.eapiPublicGetTicker(self.extend(request, params))
        #
        #     [
        #         {
        #             "amount": "0",
        #             "askPrice": "0",
        #             "bidPrice": "4880",
        #             "closeTime": 0,
        #             "exercisePrice": "63944.09893617",
        #             "firstTradeId": 0,
        #             "high": "2750",
        #             "lastPrice": "2750",
        #             "lastQty": "0",
        #             "low": "2750",
        #             "open": "2750",
        #             "openTime": 0,
        #             "priceChange": "0",
        #             "priceChangePercent": "0",
        #             "strikePrice": "80000",
        #             "symbol": "BTC-241227-80000-C",
        #             "tradeCount": 0,
        #             "volume": "0",
        #         }
        #     ]
        #
        chain = self.safe_dict(response, 0, {})
        return self.parse_option(chain, None, market)

    def parse_option(self, chain: dict, currency: Currency = None, market: Market = None) -> Option:
        #
        #     {
        #         "amount": "0",
        #         "askPrice": "0",
        #         "bidPrice": "4880",
        #         "closeTime": 0,
        #         "exercisePrice": "63944.09893617",
        #         "firstTradeId": 0,
        #         "high": "2750",
        #         "lastPrice": "2750",
        #         "lastQty": "0",
        #         "low": "2750",
        #         "open": "2750",
        #         "openTime": 0,
        #         "priceChange": "0",
        #         "priceChangePercent": "0",
        #         "strikePrice": "80000",
        #         "symbol": "BTC-241227-80000-C",
        #         "tradeCount": 0,
        #         "volume": "0",
        #     }
        #
        marketId = self.safe_string(chain, 'symbol')
        market = self.safe_market(marketId, market)
        return {
            'askPrice': self.safe_number(chain, 'askPrice'),
            'baseVolume': self.safe_number(chain, 'volume'),
            'bidPrice': self.safe_number(chain, 'bidPrice'),
            'change': self.safe_number(chain, 'priceChange'),
            'currency': None,
            'datetime': None,
            'impliedVolatility': None,
            'info': chain,
            'lastPrice': self.safe_number(chain, 'lastPrice'),
            'markPrice': None,
            'midPrice': None,
            'openInterest': None,
            'percentage': self.safe_number(chain, 'priceChangePercent'),
            'quoteVolume': None,
            'symbol': market['symbol'],
            'timestamp': None,
            'underlyingPrice': self.safe_number(chain, 'exercisePrice'),
        }

    def fetch_margin_adjustment_history(self, symbol: Str = None, type: Str = None, since: Num = None, limit: Num = None, params={}) -> List[MarginModification]:
        """
        fetches the history of margin added or reduced from contract isolated positions

        https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Position-Margin-Change-History
        https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/Get-Position-Margin-Change-History

        :param str symbol: unified market symbol
        :param str [type]: "add" or "reduce"
        :param int [since]: timestamp in ms of the earliest change to fetch
        :param int [limit]: the maximum amount of changes to fetch
        :param dict params: extra parameters specific to the exchange api endpoint
        :param int [params.until]: timestamp in ms of the latest change to fetch
        :returns dict[]: a list of `margin structures <https://docs.ccxt.com/#/?id=margin-loan-structure>`
        """
        self.load_markets()
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchMarginAdjustmentHistory() requires a symbol argument')
        market = self.market(symbol)
        until = self.safe_integer(params, 'until')
        params = self.omit(params, 'until')
        request: dict = {
            'symbol': market['id'],
        }
        if type is not None:
            request['type'] = 1 if (type == 'add') else 2
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        if until is not None:
            request['endTime'] = until
        response = None
        if market['linear']:
            response = self.fapiPrivateGetPositionMarginHistory(self.extend(request, params))
        elif market['inverse']:
            response = self.dapiPrivateGetPositionMarginHistory(self.extend(request, params))
        else:
            raise BadRequest(self.id + 'fetchMarginAdjustmentHistory() is not supported for markets of type ' + market['type'])
        #
        #    [
        #        {
        #            amount: "2.57148240",
        #            asset: "USDT",
        #            clientTranId: "",
        #            deltaType: "TRADE",
        #            positionSide: "BOTH",
        #            symbol: "XRPUSDT",
        #            time: "1711046271555",
        #            type: "1"
        #        }
        #        ...
        #    ]
        #
        modifications = self.parse_margin_modifications(response)
        return self.filter_by_symbol_since_limit(modifications, symbol, since, limit)

    def fetch_convert_currencies(self, params={}) -> Currencies:
        """
        fetches all available currencies that can be converted

        https://developers.binance.com/docs/convert/market-data/Query-order-quantity-precision-per-asset

        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an associative dictionary of currencies
        """
        self.load_markets()
        response = self.sapiGetConvertAssetInfo(params)
        #
        #     [
        #         {
        #             "asset": "BTC",
        #             "fraction": 8
        #         },
        #     ]
        #
        result: dict = {}
        for i in range(0, len(response)):
            entry = response[i]
            id = self.safe_string(entry, 'asset')
            code = self.safe_currency_code(id)
            result[code] = {
                'active': None,
                'code': code,
                'created': None,
                'deposit': None,
                'fee': None,
                'id': id,
                'info': entry,
                'limits': {
                    'amount': {
                        'max': None,
                        'min': None,
                    },
                    'deposit': {
                        'max': None,
                        'min': None,
                    },
                    'withdraw': {
                        'max': None,
                        'min': None,
                    },
                },
                'name': None,
                'networks': None,
                'precision': self.parse_number(self.parse_precision(self.safe_string(entry, 'fraction'))),
                'type': None,
                'withdraw': None,
            }
        return result

    def fetch_convert_quote(self, fromCode: str, toCode: str, amount: Num = None, params={}) -> Conversion:
        """
        fetch a quote for converting from one currency to another

        https://developers.binance.com/docs/convert/trade/Send-quote-request

        :param str fromCode: the currency that you want to sell and convert from
        :param str toCode: the currency that you want to buy and convert into
        :param float amount: how much you want to trade in units of the from currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.walletType]: either 'SPOT' or 'FUNDING', the default is 'SPOT'
        :returns dict: a `conversion structure <https://docs.ccxt.com/#/?id=conversion-structure>`
        """
        if amount is None:
            raise ArgumentsRequired(self.id + ' fetchConvertQuote() requires an amount argument')
        self.load_markets()
        request: dict = {
            'fromAsset': fromCode,
            'toAsset': toCode,
            'fromAmount': amount,
        }
        response = self.sapiPostConvertGetQuote(self.extend(request, params))
        #
        #     {
        #         "quoteId":"12415572564",
        #         "ratio":"38163.7",
        #         "inverseRatio":"0.0000262",
        #         "validTimestamp":1623319461670,
        #         "toAmount":"3816.37",
        #         "fromAmount":"0.1"
        #     }
        #
        fromCurrency = self.currency(fromCode)
        toCurrency = self.currency(toCode)
        return self.parse_conversion(response, fromCurrency, toCurrency)

    def create_convert_trade(self, id: str, fromCode: str, toCode: str, amount: Num = None, params={}) -> Conversion:
        """
        convert from one currency to another

        https://developers.binance.com/docs/convert/trade/Accept-Quote

        :param str id: the id of the trade that you want to make
        :param str fromCode: the currency that you want to sell and convert from
        :param str toCode: the currency that you want to buy and convert into
        :param float [amount]: how much you want to trade in units of the from currency
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `conversion structure <https://docs.ccxt.com/#/?id=conversion-structure>`
        """
        self.load_markets()
        request: dict = {}
        response = None
        if (fromCode == 'BUSD') or (toCode == 'BUSD'):
            if amount is None:
                raise ArgumentsRequired(self.id + ' createConvertTrade() requires an amount argument')
            request['clientTranId'] = id
            request['asset'] = fromCode
            request['targetAsset'] = toCode
            request['amount'] = amount
            response = self.sapiPostAssetConvertTransfer(self.extend(request, params))
            #
            #     {
            #         "tranId": 118263407119,
            #         "status": "S"
            #     }
            #
        else:
            request['quoteId'] = id
            response = self.sapiPostConvertAcceptQuote(self.extend(request, params))
            #
            #     {
            #         "orderId":"933256278426274426",
            #         "createTime":1623381330472,
            #         "orderStatus":"PROCESS"
            #     }
            #
        fromCurrency = self.currency(fromCode)
        toCurrency = self.currency(toCode)
        return self.parse_conversion(response, fromCurrency, toCurrency)

    def fetch_convert_trade(self, id: str, code: Str = None, params={}) -> Conversion:
        """
        fetch the data for a conversion trade

        https://developers.binance.com/docs/convert/trade/Order-Status

        :param str id: the id of the trade that you want to fetch
        :param str [code]: the unified currency code of the conversion trade
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `conversion structure <https://docs.ccxt.com/#/?id=conversion-structure>`
        """
        self.load_markets()
        request: dict = {}
        response = None
        if code == 'BUSD':
            msInDay = 86400000
            now = self.milliseconds()
            if code is not None:
                currency = self.currency(code)
                request['asset'] = currency['id']
            request['tranId'] = id
            request['startTime'] = now - msInDay
            request['endTime'] = now
            response = self.sapiGetAssetConvertTransferQueryByPage(self.extend(request, params))
            #
            #     {
            #         "total": 3,
            #         "rows": [
            #             {
            #                 "tranId": 118263615991,
            #                 "type": 244,
            #                 "time": 1664442078000,
            #                 "deductedAsset": "BUSD",
            #                 "deductedAmount": "1",
            #                 "targetAsset": "USDC",
            #                 "targetAmount": "1",
            #                 "status": "S",
            #                 "accountType": "MAIN"
            #             },
            #         ]
            #     }
            #
        else:
            request['orderId'] = id
            response = self.sapiGetConvertOrderStatus(self.extend(request, params))
            #
            #     {
            #         "orderId":933256278426274426,
            #         "orderStatus":"SUCCESS",
            #         "fromAsset":"BTC",
            #         "fromAmount":"0.00054414",
            #         "toAsset":"USDT",
            #         "toAmount":"20",
            #         "ratio":"36755",
            #         "inverseRatio":"0.00002721",
            #         "createTime":1623381330472
            #     }
            #
        data = response
        if code == 'BUSD':
            rows = self.safe_list(response, 'rows', [])
            data = self.safe_dict(rows, 0, {})
        fromCurrencyId = self.safe_string_2(data, 'deductedAsset', 'fromAsset')
        toCurrencyId = self.safe_string_2(data, 'targetAsset', 'toAsset')
        fromCurrency = None
        toCurrency = None
        if fromCurrencyId is not None:
            fromCurrency = self.currency(fromCurrencyId)
        if toCurrencyId is not None:
            toCurrency = self.currency(toCurrencyId)
        return self.parse_conversion(data, fromCurrency, toCurrency)

    def fetch_convert_trade_history(self, code: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Conversion]:
        """
        fetch the users history of conversion trades

        https://developers.binance.com/docs/convert/trade/Get-Convert-Trade-History

        :param str [code]: the unified currency code
        :param int [since]: the earliest time in ms to fetch conversions for
        :param int [limit]: the maximum number of conversion structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: timestamp in ms of the latest conversion to fetch
        :returns dict[]: a list of `conversion structures <https://docs.ccxt.com/#/?id=conversion-structure>`
        """
        self.load_markets()
        request: dict = {}
        msInThirtyDays = 2592000000
        now = self.milliseconds()
        if since is not None:
            request['startTime'] = since
        else:
            request['startTime'] = now - msInThirtyDays
        endTime = self.safe_integer_2(params, 'endTime', 'until')
        if endTime is not None:
            request['endTime'] = endTime
        else:
            request['endTime'] = now
        params = self.omit(params, 'until')
        response = None
        responseQuery = None
        fromCurrencyKey = None
        toCurrencyKey = None
        if code == 'BUSD':
            currency = self.currency(code)
            request['asset'] = currency['id']
            if limit is not None:
                request['size'] = limit
            fromCurrencyKey = 'deductedAsset'
            toCurrencyKey = 'targetAsset'
            responseQuery = 'rows'
            response = self.sapiGetAssetConvertTransferQueryByPage(self.extend(request, params))
            #
            #     {
            #         "total": 3,
            #         "rows": [
            #             {
            #                 "tranId": 118263615991,
            #                 "type": 244,
            #                 "time": 1664442078000,
            #                 "deductedAsset": "BUSD",
            #                 "deductedAmount": "1",
            #                 "targetAsset": "USDC",
            #                 "targetAmount": "1",
            #                 "status": "S",
            #                 "accountType": "MAIN"
            #             },
            #         ]
            #     }
            #
        else:
            if (request['endTime'] - request['startTime']) > msInThirtyDays:
                raise BadRequest(self.id + ' fetchConvertTradeHistory() the max interval between startTime and endTime is 30 days.')
            if limit is not None:
                request['limit'] = limit
            fromCurrencyKey = 'fromAsset'
            toCurrencyKey = 'toAsset'
            responseQuery = 'list'
            response = self.sapiGetConvertTradeFlow(self.extend(request, params))
            #
            #     {
            #         "list": [
            #             {
            #                 "quoteId": "f3b91c525b2644c7bc1e1cd31b6e1aa6",
            #                 "orderId": 940708407462087195,
            #                 "orderStatus": "SUCCESS",
            #                 "fromAsset": "USDT",
            #                 "fromAmount": "20",
            #                 "toAsset": "BNB",
            #                 "toAmount": "0.06154036",
            #                 "ratio": "0.00307702",
            #                 "inverseRatio": "324.99",
            #                 "createTime": 1624248872184
            #             }
            #         ],
            #         "startTime": 1623824139000,
            #         "endTime": 1626416139000,
            #         "limit": 100,
            #         "moreData": False
            #     }
            #
        rows = self.safe_list(response, responseQuery, [])
        return self.parse_conversions(rows, code, fromCurrencyKey, toCurrencyKey, since, limit)

    def parse_conversion(self, conversion: dict, fromCurrency: Currency = None, toCurrency: Currency = None) -> Conversion:
        #
        # fetchConvertQuote
        #
        #     {
        #         "quoteId":"12415572564",
        #         "ratio":"38163.7",
        #         "inverseRatio":"0.0000262",
        #         "validTimestamp":1623319461670,
        #         "toAmount":"3816.37",
        #         "fromAmount":"0.1"
        #     }
        #
        # createConvertTrade
        #
        #     {
        #         "orderId":"933256278426274426",
        #         "createTime":1623381330472,
        #         "orderStatus":"PROCESS"
        #     }
        #
        # createConvertTrade BUSD
        #
        #     {
        #         "tranId": 118263407119,
        #         "status": "S"
        #     }
        #
        # fetchConvertTrade, fetchConvertTradeHistory BUSD
        #
        #     {
        #         "tranId": 118263615991,
        #         "type": 244,
        #         "time": 1664442078000,
        #         "deductedAsset": "BUSD",
        #         "deductedAmount": "1",
        #         "targetAsset": "USDC",
        #         "targetAmount": "1",
        #         "status": "S",
        #         "accountType": "MAIN"
        #     }
        #
        # fetchConvertTrade
        #
        #     {
        #         "orderId":933256278426274426,
        #         "orderStatus":"SUCCESS",
        #         "fromAsset":"BTC",
        #         "fromAmount":"0.00054414",
        #         "toAsset":"USDT",
        #         "toAmount":"20",
        #         "ratio":"36755",
        #         "inverseRatio":"0.00002721",
        #         "createTime":1623381330472
        #     }
        #
        # fetchConvertTradeHistory
        #
        #     {
        #         "quoteId": "f3b91c525b2644c7bc1e1cd31b6e1aa6",
        #         "orderId": 940708407462087195,
        #         "orderStatus": "SUCCESS",
        #         "fromAsset": "USDT",
        #         "fromAmount": "20",
        #         "toAsset": "BNB",
        #         "toAmount": "0.06154036",
        #         "ratio": "0.00307702",
        #         "inverseRatio": "324.99",
        #         "createTime": 1624248872184
        #     }
        #
        timestamp = self.safe_integer_n(conversion, ['time', 'validTimestamp', 'createTime'])
        fromCur = self.safe_string_2(conversion, 'deductedAsset', 'fromAsset')
        fromCode = self.safe_currency_code(fromCur, fromCurrency)
        to = self.safe_string_2(conversion, 'targetAsset', 'toAsset')
        toCode = self.safe_currency_code(to, toCurrency)
        return {
            'info': conversion,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'id': self.safe_string_n(conversion, ['tranId', 'orderId', 'quoteId']),
            'fromCurrency': fromCode,
            'fromAmount': self.safe_number_2(conversion, 'deductedAmount', 'fromAmount'),
            'toCurrency': toCode,
            'toAmount': self.safe_number_2(conversion, 'targetAmount', 'toAmount'),
            'price': None,
            'fee': None,
        }

    def fetch_funding_intervals(self, symbols: Strings = None, params={}) -> FundingRates:
        """
        fetch the funding rate interval for multiple markets

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Info
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Get-Funding-Info

        :param str[] [symbols]: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.subType]: "linear" or "inverse"
        :returns dict[]: a list of `funding rate structures <https://docs.ccxt.com/#/?id=funding-rate-structure>`
        """
        self.load_markets()
        market = None
        if symbols is not None:
            symbols = self.market_symbols(symbols)
            market = self.market(symbols[0])
        type = 'swap'
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchFundingIntervals', market, params, 'linear')
        response = None
        if self.is_linear(type, subType):
            response = self.fapiPublicGetFundingInfo(params)
        elif self.is_inverse(type, subType):
            response = self.dapiPublicGetFundingInfo(params)
        else:
            raise NotSupported(self.id + ' fetchFundingIntervals() supports linear and inverse swap contracts only')
        #
        #     [
        #         {
        #             "symbol": "BLZUSDT",
        #             "adjustedFundingRateCap": "0.03000000",
        #             "adjustedFundingRateFloor": "-0.03000000",
        #             "fundingIntervalHours": 4,
        #             "disclaimer": False
        #         },
        #     ]
        #
        result = self.parse_funding_rates(response, market)
        return self.filter_by_array(result, 'symbol', symbols)

    def fetch_long_short_ratio_history(self, symbol: Str = None, timeframe: Str = None, since: Int = None, limit: Int = None, params={}) -> List[LongShortRatio]:
        """
        fetches the long short ratio history for a unified market symbol

        https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio
        https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/Long-Short-Ratio

        :param str symbol: unified symbol of the market to fetch the long short ratio for
        :param str [timeframe]: the period for the ratio, default is 24 hours
        :param int [since]: the earliest time in ms to fetch ratios for
        :param int [limit]: the maximum number of long short ratio structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: timestamp in ms of the latest ratio to fetch
        :returns dict[]: an array of `long short ratio structures <https://docs.ccxt.com/#/?id=long-short-ratio-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        if timeframe is None:
            timeframe = '1d'
        request: dict = {
            'period': timeframe,
        }
        request, params = self.handle_until_option('endTime', request, params)
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        subType = None
        subType, params = self.handle_sub_type_and_params('fetchLongShortRatioHistory', market, params)
        response = None
        if subType == 'linear':
            request['symbol'] = market['id']
            response = self.fapiDataGetGlobalLongShortAccountRatio(self.extend(request, params))
            #
            #     [
            #         {
            #             "symbol": "BTCUSDT",
            #             "longAccount": "0.4558",
            #             "longShortRatio": "0.8376",
            #             "shortAccount": "0.5442",
            #             "timestamp": 1726790400000
            #         },
            #     ]
            #
        elif subType == 'inverse':
            request['pair'] = market['info']['pair']
            response = self.dapiDataGetGlobalLongShortAccountRatio(self.extend(request, params))
            #
            #     [
            #         {
            #             "longAccount": "0.7262",
            #             "longShortRatio": "2.6523",
            #             "shortAccount": "0.2738",
            #             "pair": "BTCUSD",
            #             "timestamp": 1726790400000
            #         },
            #     ]
            #
        else:
            raise BadRequest(self.id + ' fetchLongShortRatioHistory() supports linear and inverse subTypes only')
        return self.parse_long_short_ratio_history(response, market)

    def parse_long_short_ratio(self, info: dict, market: Market = None) -> LongShortRatio:
        #
        # linear
        #
        #     {
        #         "symbol": "BTCUSDT",
        #         "longAccount": "0.4558",
        #         "longShortRatio": "0.8376",
        #         "shortAccount": "0.5442",
        #         "timestamp": 1726790400000
        #     }
        #
        # inverse
        #
        #     {
        #         "longAccount": "0.7262",
        #         "longShortRatio": "2.6523",
        #         "shortAccount": "0.2738",
        #         "pair": "BTCUSD",
        #         "timestamp": 1726790400000
        #     }
        #
        marketId = self.safe_string(info, 'symbol')
        timestamp = self.safe_integer_omit_zero(info, 'timestamp')
        return {
            'info': info,
            'symbol': self.safe_symbol(marketId, market, None, 'contract'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'timeframe': None,
            'longShortRatio': self.safe_number(info, 'longShortRatio'),
        }
